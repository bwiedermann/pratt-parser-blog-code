{"contents":"exports.__esModule = true;\nvar index_js_1 = __fusereq(52);\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\nfunction executeShifts(v) {\n  var shift = 0, change = 0, children = v.children, i = children.length, w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null;\n  this.a = this;\n  this.z = 0;\n  this.m = 0;\n  this.c = 0;\n  this.s = 0;\n  this.t = null;\n  this.i = i;\n}\nTreeNode.prototype = Object.create(index_js_1.Node.prototype);\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i, n;\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\nfunction __DefaultExport__() {\n  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;\n  function tree(root) {\n    var t = treeRoot(root);\n    (t.eachAfter(firstWalk), t.parent.m = -t.z);\n    t.eachBefore(secondWalk);\n    if (nodeSize) root.eachBefore(sizeNode); else {\n      var left = root, right = root, bottom = root;\n      root.eachBefore(function (node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);\n      root.eachBefore(function (node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n    return root;\n  }\n  function firstWalk(v) {\n    var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n      while ((vim = nextRight(vim), vip = nextLeft(vip), vim && vip)) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n  tree.separation = function (x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n  tree.size = function (x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];\n  };\n  tree.nodeSize = function (x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;\n  };\n  return tree;\n}\nexports.default = __DefaultExport__;\n"}