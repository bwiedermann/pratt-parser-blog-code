{"contents":"exports.__esModule = true;\nvar lezer_tree_1 = __fusereq(34);\nvar highlight_1 = __fusereq(30);\nvar language_1 = __fusereq(21);\nvar text_1 = __fusereq(35);\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) end = string.length;\n  }\n  return text_1.countColumn(string.slice(startIndex, end), startValue, tabSize);\n}\nclass StringStream {\n  constructor(string, tabSize, indentUnit) {\n    this.string = string;\n    this.tabSize = tabSize;\n    this.indentUnit = indentUnit;\n    this.pos = 0;\n    this.start = 0;\n    this.lastColumnPos = 0;\n    this.lastColumnValue = 0;\n  }\n  eol() {\n    return this.pos >= this.string.length;\n  }\n  sol() {\n    return this.pos == 0;\n  }\n  peek() {\n    return this.string.charAt(this.pos) || undefined;\n  }\n  next() {\n    if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n  }\n  eat(match) {\n    let ch = this.string.charAt(this.pos);\n    let ok;\n    if (typeof match == \"string\") ok = ch == match; else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n    if (ok) {\n      ++this.pos;\n      return ch;\n    }\n  }\n  eatWhile(match) {\n    let start = this.pos;\n    while (this.eat(match)) {}\n    return this.pos > start;\n  }\n  eatSpace() {\n    let start = this.pos;\n    while ((/[\\s\\u00a0]/).test(this.string.charAt(this.pos))) ++this.pos;\n    return this.pos > start;\n  }\n  skipToEnd() {\n    this.pos = this.string.length;\n  }\n  skipTo(ch) {\n    let found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {\n      this.pos = found;\n      return true;\n    }\n  }\n  backUp(n) {\n    this.pos -= n;\n  }\n  column() {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue;\n  }\n  indentation() {\n    return countCol(this.string, null, this.tabSize);\n  }\n  match(pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      let cased = str => caseInsensitive ? str.toLowerCase() : str;\n      let substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) this.pos += pattern.length;\n        return true;\n      } else return null;\n    } else {\n      let match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) return null;\n      if (match && consume !== false) this.pos += match[0].length;\n      return match;\n    }\n  }\n  current() {\n    return this.string.slice(this.start, this.pos);\n  }\n}\nfunction fullParser(spec) {\n  return {\n    token: spec.token,\n    blankLine: spec.blankLine || (() => {}),\n    startState: spec.startState || (() => true),\n    copyState: spec.copyState || defaultCopyState,\n    indent: spec.indent || (() => null),\n    languageData: spec.languageData || ({})\n  };\n}\nfunction defaultCopyState(state) {\n  if (typeof state != \"object\") return state;\n  let newState = {};\n  for (let prop in state) {\n    let val = state[prop];\n    newState[prop] = val instanceof Array ? val.slice() : val;\n  }\n  return newState;\n}\nclass StreamLanguage extends language_1.Language {\n  constructor(parser) {\n    let data = language_1.defineLanguageFacet(parser.languageData);\n    let p = fullParser(parser);\n    let startParse = (input, startPos, context) => new Parse(this, input, startPos, context);\n    super(data, {\n      startParse\n    }, docID(data), [language_1.indentService.of((cx, pos) => this.getIndent(cx, pos))]);\n    this.streamParser = p;\n    this.stateAfter = new WeakMap();\n  }\n  static define(spec) {\n    return new StreamLanguage(spec);\n  }\n  getIndent(cx, pos) {\n    let tree = language_1.syntaxTree(cx.state), at = tree.resolve(pos);\n    while (at && at.type != this.topNode) at = at.parent;\n    if (!at) return null;\n    let start = findState(this, tree, 0, at.from, pos), statePos, state;\n    if (start) {\n      state = start.state;\n      statePos = start.pos + 1;\n    } else {\n      state = this.streamParser.startState(cx.unit);\n      statePos = 0;\n    }\n    if (pos - statePos > 10000) return null;\n    while (statePos < pos) {\n      let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n      if (line.length) {\n        let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);\n        while (stream.pos < end - line.from) readToken(this.streamParser.token, stream, state);\n      } else {\n        this.streamParser.blankLine(state, cx.unit);\n      }\n      if (end == pos) break;\n      statePos = line.to + 1;\n    }\n    let {text} = cx.state.doc.lineAt(pos);\n    return this.streamParser.indent(state, (/^\\s*(.*)/).exec(text)[1], cx);\n  }\n  get allowsNesting() {\n    return false;\n  }\n}\nfunction findState(lang, tree, off, startPos, before) {\n  let state = off >= startPos && off + tree.length <= before && lang.stateAfter.get(tree);\n  if (state) return {\n    state: lang.streamParser.copyState(state),\n    pos: off + tree.length\n  };\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    let child = tree.children[i], pos = off + tree.positions[i];\n    let found = child instanceof lezer_tree_1.Tree && pos < before && findState(lang, child, pos, startPos, before);\n    if (found) return found;\n  }\n  return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n  if (inside && from <= 0 && to >= tree.length) return tree;\n  if (!inside && tree.type == lang.topNode) inside = true;\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    let pos = tree.positions[i] + from, child = tree.children[i], inner;\n    if (pos < to && child instanceof lezer_tree_1.Tree) {\n      if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n      return !inside ? inner : new lezer_tree_1.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n    }\n  }\n  return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, state) {\n  for (let f of fragments) {\n    let found = f.from <= startPos && f.to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, f.to), tree;\n    if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n      state: found.state,\n      tree\n    };\n  }\n  return {\n    state: lang.streamParser.startState(language_1.getIndentUnit(state)),\n    tree: lezer_tree_1.Tree.empty\n  };\n}\nclass Parse {\n  constructor(lang, input, startPos, context) {\n    this.lang = lang;\n    this.input = input;\n    this.startPos = startPos;\n    this.context = context;\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunk = [];\n    let {state, tree} = findStartInFragments(lang, context.fragments, startPos, context.state);\n    this.state = state;\n    this.pos = this.chunkStart = startPos + tree.length;\n    if (tree.length) {\n      this.chunks.push(tree);\n      this.chunkPos.push(0);\n    }\n    if (this.pos < context.viewport.from - 100000) {\n      this.state = this.lang.streamParser.startState(language_1.getIndentUnit(context.state));\n      context.skipUntilInView(this.pos, context.viewport.from);\n      this.pos = context.viewport.from;\n    }\n  }\n  advance() {\n    let end = Math.min(this.context.viewport.to, this.input.length, this.chunkStart + 2048);\n    while (this.pos < end) this.parseLine();\n    if (this.chunkStart < this.pos) this.finishChunk();\n    if (end < this.input.length && this.pos < this.context.viewport.to) return null;\n    this.context.skipUntilInView(this.pos, this.input.length);\n    return this.finish();\n  }\n  parseLine() {\n    let line = this.input.lineAfter(this.pos), {streamParser} = this.lang;\n    let stream = new StringStream(line, this.context ? this.context.state.tabSize : 4, language_1.getIndentUnit(this.context.state));\n    if (stream.eol()) {\n      streamParser.blankLine(this.state, stream.indentUnit);\n    } else {\n      while (!stream.eol()) {\n        let token = readToken(streamParser.token, stream, this.state);\n        if (token) this.chunk.push(tokenID(token), this.pos + stream.start, this.pos + stream.pos, 4);\n      }\n    }\n    this.pos += line.length;\n    if (this.pos < this.input.length) this.pos++;\n  }\n  finishChunk() {\n    let tree = lezer_tree_1.Tree.build({\n      buffer: this.chunk,\n      start: this.chunkStart,\n      length: this.pos - this.chunkStart,\n      nodeSet,\n      topID: 0,\n      maxBufferLength: 2048\n    });\n    this.lang.stateAfter.set(tree, this.lang.streamParser.copyState(this.state));\n    this.chunks.push(tree);\n    this.chunkPos.push(this.chunkStart - this.startPos);\n    this.chunk = [];\n    this.chunkStart = this.pos;\n  }\n  finish() {\n    return new lezer_tree_1.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.pos - this.startPos).balance();\n  }\n  forceFinish() {\n    return this.finish();\n  }\n}\nfunction readToken(token, stream, state) {\n  stream.start = stream.pos;\n  for (let i = 0; i < 10; i++) {\n    let result = token(stream, state);\n    if (stream.pos > stream.start) return result;\n  }\n  throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst tokenTable = Object.create(null);\nconst typeArray = [lezer_tree_1.NodeType.none];\nconst nodeSet = new lezer_tree_1.NodeSet(typeArray);\nconst warned = [];\nfunction tokenID(tag) {\n  return !tag ? 0 : tokenTable[tag] || (tokenTable[tag] = createTokenType(tag));\n}\nfor (let [legacyName, name] of [[\"variable\", \"variableName\"], [\"variable-2\", \"variableName.special\"], [\"string-2\", \"string.special\"], [\"def\", \"variableName.definition\"], [\"tag\", \"typeName\"], [\"attribute\", \"propertyName\"], [\"type\", \"typeName\"], [\"builtin\", \"variableName.standard\"], [\"qualifier\", \"modifier\"], [\"error\", \"invalid\"], [\"header\", \"heading\"], [\"property\", \"propertyName\"]]) tokenTable[legacyName] = tokenID(name);\nfunction warnForPart(part, msg) {\n  if (warned.indexOf(part) > -1) return;\n  warned.push(part);\n  console.warn(msg);\n}\nfunction createTokenType(tagStr) {\n  let tag = null;\n  for (let part of tagStr.split(\".\")) {\n    let value = highlight_1.tags[part];\n    if (!value) {\n      warnForPart(part, `Unknown highlighting tag ${part}`);\n    } else if (typeof value == \"function\") {\n      if (!tag) warnForPart(part, `Modifier ${part} used at start of tag`); else tag = value(tag);\n    } else {\n      if (tag) warnForPart(part, `Tag ${part} used as modifier`); else tag = value;\n    }\n  }\n  if (!tag) return 0;\n  let name = tagStr.replace(/ /g, \"_\"), type = lezer_tree_1.NodeType.define({\n    id: typeArray.length,\n    name,\n    props: [highlight_1.styleTags({\n      [name]: tag\n    })]\n  });\n  typeArray.push(type);\n  return type.id;\n}\nfunction docID(data) {\n  let type = lezer_tree_1.NodeType.define({\n    id: typeArray.length,\n    name: \"Document\",\n    props: [language_1.languageDataProp.add(() => data)]\n  });\n  typeArray.push(type);\n  return type;\n}\nexports.StreamLanguage = StreamLanguage;\nexports.StringStream = StringStream;\n"}