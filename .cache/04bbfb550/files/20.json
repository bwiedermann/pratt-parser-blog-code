{"contents":"exports.__esModule = true;\nvar state_1 = __fusereq(16);\nvar view_1 = __fusereq(18);\nvar language_1 = __fusereq(21);\nvar gutter_1 = __fusereq(22);\nvar rangeset_1 = __fusereq(39);\nfunction mapRange(range, mapping) {\n  let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n  return from >= to ? undefined : {\n    from,\n    to\n  };\n}\nconst foldEffect = state_1.StateEffect.define({\n  map: mapRange\n});\nconst unfoldEffect = state_1.StateEffect.define({\n  map: mapRange\n});\nfunction selectedLines(view) {\n  let lines = [];\n  for (let {head} of view.state.selection.ranges) {\n    if (lines.some(l => l.from <= head && l.to >= head)) continue;\n    lines.push(view.visualLineAt(head));\n  }\n  return lines;\n}\nconst foldState = state_1.StateField.define({\n  create() {\n    return view_1.Decoration.none;\n  },\n  update(folded, tr) {\n    folded = folded.map(tr.changes);\n    for (let e of tr.effects) {\n      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) folded = folded.update({\n        add: [foldWidget.range(e.value.from, e.value.to)]\n      }); else if (e.is(unfoldEffect)) {\n        folded = folded.update({\n          filter: (from, to) => e.value.from != from || e.value.to != to,\n          filterFrom: e.value.from,\n          filterTo: e.value.to\n        });\n      }\n    }\n    if (tr.selection) {\n      let onSelection = false, {head} = tr.selection.main;\n      folded.between(head, head, (a, b) => {\n        if (a < head && b > head) onSelection = true;\n      });\n      if (onSelection) folded = folded.update({\n        filterFrom: head,\n        filterTo: head,\n        filter: (a, b) => b <= head || a >= head\n      });\n    }\n    return folded;\n  },\n  provide: f => view_1.EditorView.decorations.compute([f], s => s.field(f))\n});\nfunction foldInside(state, from, to) {\n  var _a;\n  let found = null;\n  (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n    if (!found || found.from > from) found = {\n      from,\n      to\n    };\n  });\n  return found;\n}\nfunction foldExists(folded, from, to) {\n  let found = false;\n  folded.between(from, from, (a, b) => {\n    if (a == from && b == to) found = true;\n  });\n  return found;\n}\nfunction maybeEnable(state, other) {\n  return state.field(foldState, false) ? other : other.concat(state_1.StateEffect.appendConfig.of(codeFolding()));\n}\nconst foldCode = view => {\n  for (let line of selectedLines(view)) {\n    let range = language_1.foldable(view.state, line.from, line.to);\n    if (range) {\n      view.dispatch({\n        effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])\n      });\n      return true;\n    }\n  }\n  return false;\n};\nconst unfoldCode = view => {\n  if (!view.state.field(foldState, false)) return false;\n  let effects = [];\n  for (let line of selectedLines(view)) {\n    let folded = foldInside(view.state, line.from, line.to);\n    if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n  }\n  if (effects.length) view.dispatch({\n    effects\n  });\n  return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n  let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\n  return view_1.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\nconst foldAll = view => {\n  let {state} = view, effects = [];\n  for (let pos = 0; pos < state.doc.length; ) {\n    let line = view.visualLineAt(pos), range = language_1.foldable(state, line.from, line.to);\n    if (range) effects.push(foldEffect.of(range));\n    pos = (range ? view.visualLineAt(range.to) : line).to + 1;\n  }\n  if (effects.length) view.dispatch({\n    effects: maybeEnable(view.state, effects)\n  });\n  return !!effects.length;\n};\nconst unfoldAll = view => {\n  let field = view.state.field(foldState, false);\n  if (!field || !field.size) return false;\n  let effects = [];\n  field.between(0, view.state.doc.length, (from, to) => {\n    effects.push(unfoldEffect.of({\n      from,\n      to\n    }));\n  });\n  view.dispatch({\n    effects\n  });\n  return true;\n};\nconst foldKeymap = [{\n  key: \"Ctrl-Shift-[\",\n  mac: \"Cmd-Alt-[\",\n  run: foldCode\n}, {\n  key: \"Ctrl-Shift-]\",\n  mac: \"Cmd-Alt-]\",\n  run: unfoldCode\n}, {\n  key: \"Ctrl-Alt-[\",\n  run: foldAll\n}, {\n  key: \"Ctrl-Alt-]\",\n  run: unfoldAll\n}];\nconst defaultConfig = {\n  placeholderDOM: null,\n  placeholderText: \"…\"\n};\nconst foldConfig = state_1.Facet.define({\n  combine(values) {\n    return state_1.combineConfig(values, defaultConfig);\n  }\n});\nfunction codeFolding(config) {\n  let result = [foldState, baseTheme];\n  if (config) result.push(foldConfig.of(config));\n  return result;\n}\nconst foldWidget = view_1.Decoration.replace({\n  widget: new (class extends view_1.WidgetType {\n    ignoreEvents() {\n      return false;\n    }\n    toDOM(view) {\n      let {state} = view, conf = state.facet(foldConfig);\n      if (conf.placeholderDOM) return conf.placeholderDOM();\n      let element = document.createElement(\"span\");\n      element.textContent = conf.placeholderText;\n      element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n      element.title = state.phrase(\"unfold\");\n      element.className = \"cm-foldPlaceholder\";\n      element.onclick = event => {\n        let line = view.visualLineAt(view.posAtDOM(event.target));\n        let folded = foldInside(view.state, line.from, line.to);\n        if (folded) view.dispatch({\n          effects: unfoldEffect.of(folded)\n        });\n        event.preventDefault();\n      };\n      return element;\n    }\n  })()\n});\nconst foldGutterDefaults = {\n  openText: \"⌄\",\n  closedText: \"›\"\n};\nclass FoldMarker extends gutter_1.GutterMarker {\n  constructor(config, open) {\n    super();\n    this.config = config;\n    this.open = open;\n  }\n  eq(other) {\n    return this.config == other.config && this.open == other.open;\n  }\n  toDOM(view) {\n    let span = document.createElement(\"span\");\n    span.textContent = this.open ? this.config.openText : this.config.closedText;\n    span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n    return span;\n  }\n}\nfunction foldGutter(config = {}) {\n  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n  let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n  let markers = view_1.ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.from = view.viewport.from;\n      this.markers = rangeset_1.RangeSet.of(this.buildMarkers(view));\n    }\n    update(update) {\n      let firstChange = -1;\n      update.changes.iterChangedRanges(from => {\n        if (firstChange < 0) firstChange = from;\n      });\n      let foldChange = update.startState.field(foldState, false) != update.state.field(foldState, false);\n      if (!foldChange && update.docChanged && update.view.viewport.from == this.from && firstChange > this.from) {\n        let start = update.view.visualLineAt(firstChange).from;\n        this.markers = this.markers.update({\n          filter: () => false,\n          filterFrom: start,\n          add: this.buildMarkers(update.view, start)\n        });\n      } else if (foldChange || update.docChanged || update.viewportChanged) {\n        this.from = update.view.viewport.from;\n        this.markers = rangeset_1.RangeSet.of(this.buildMarkers(update.view));\n      }\n    }\n    buildMarkers(view, from = 0) {\n      let ranges = [];\n      view.viewportLines(line => {\n        if (line.from >= from) {\n          let mark = foldInside(view.state, line.from, line.to) ? canUnfold : language_1.foldable(view.state, line.from, line.to) ? canFold : null;\n          if (mark) ranges.push(mark.range(line.from));\n        }\n      });\n      return ranges;\n    }\n  });\n  return [markers, gutter_1.gutter({\n    class: \"cm-foldGutter\",\n    markers(view) {\n      var _a;\n      return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || rangeset_1.RangeSet.empty;\n    },\n    initialSpacer() {\n      return new FoldMarker(fullConfig, false);\n    },\n    domEventHandlers: {\n      click: (view, line) => {\n        let folded = foldInside(view.state, line.from, line.to);\n        if (folded) {\n          view.dispatch({\n            effects: unfoldEffect.of(folded)\n          });\n          return true;\n        }\n        let range = language_1.foldable(view.state, line.from, line.to);\n        if (range) {\n          view.dispatch({\n            effects: foldEffect.of(range)\n          });\n          return true;\n        }\n        return false;\n      }\n    }\n  }), codeFolding()];\n}\nconst baseTheme = view_1.EditorView.baseTheme({\n  \".cm-foldPlaceholder\": {\n    backgroundColor: \"#eee\",\n    border: \"1px solid #ddd\",\n    color: \"#888\",\n    borderRadius: \".2em\",\n    margin: \"0 1px\",\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  },\n  \".cm-foldGutter .cm-gutterElement\": {\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  }\n});\nexports.codeFolding = codeFolding;\nexports.foldAll = foldAll;\nexports.foldCode = foldCode;\nexports.foldGutter = foldGutter;\nexports.foldKeymap = foldKeymap;\nexports.unfoldAll = unfoldAll;\nexports.unfoldCode = unfoldCode;\n"}