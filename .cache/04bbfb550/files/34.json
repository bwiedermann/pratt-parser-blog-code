{"contents":"exports.__esModule = true;\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nconst CachedNode = new WeakMap();\nclass NodeProp {\n  constructor({deserialize} = {}) {\n    this.id = nextPropID++;\n    this.deserialize = deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\");\n    });\n  }\n  static string() {\n    return new NodeProp({\n      deserialize: str => str\n    });\n  }\n  static number() {\n    return new NodeProp({\n      deserialize: Number\n    });\n  }\n  static flag() {\n    return new NodeProp({\n      deserialize: () => true\n    });\n  }\n  set(propObj, value) {\n    propObj[this.id] = value;\n    return propObj;\n  }\n  add(match) {\n    if (typeof match != \"function\") match = NodeType.match(match);\n    return type => {\n      let result = match(type);\n      return result === undefined ? null : [this, result];\n    };\n  }\n}\nNodeProp.closedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\nNodeProp.openedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\nNodeProp.group = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\nconst noProps = Object.create(null);\nclass NodeType {\n  constructor(name, props, id, flags = 0) {\n    this.name = name;\n    this.props = props;\n    this.id = id;\n    this.flags = flags;\n  }\n  static define(spec) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type);\n      if (src) src[0].set(props, src[1]);\n    }\n    return type;\n  }\n  prop(prop) {\n    return this.props[prop.id];\n  }\n  get isTop() {\n    return (this.flags & 1) > 0;\n  }\n  get isSkipped() {\n    return (this.flags & 2) > 0;\n  }\n  get isError() {\n    return (this.flags & 4) > 0;\n  }\n  get isAnonymous() {\n    return (this.flags & 8) > 0;\n  }\n  is(name) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true;\n      let group = this.prop(NodeProp.group);\n      return group ? group.indexOf(name) > -1 : false;\n    }\n    return this.id == name;\n  }\n  static match(map) {\n    let direct = Object.create(null);\n    for (let prop in map) for (let name of prop.split(\" \")) direct[name] = map[prop];\n    return node => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups[i]];\n        if (found) return found;\n      }\n    };\n  }\n}\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8);\nclass NodeSet {\n  constructor(types) {\n    this.types = types;\n    for (let i = 0; i < types.length; i++) if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n  }\n  extend(...props) {\n    let newTypes = [];\n    for (let type of this.types) {\n      let newProps = null;\n      for (let source of props) {\n        let add = source(type);\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props);\n          add[0].set(newProps, add[1]);\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n    }\n    return new NodeSet(newTypes);\n  }\n}\nclass Tree {\n  constructor(type, children, positions, length) {\n    this.type = type;\n    this.children = children;\n    this.positions = positions;\n    this.length = length;\n  }\n  toString() {\n    let children = this.children.map(c => c.toString()).join();\n    return !this.type.name ? children : ((/\\W/).test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n  }\n  cursor(pos, side = 0) {\n    let scope = pos != null && CachedNode.get(this) || this.topNode;\n    let cursor = new TreeCursor(scope);\n    if (pos != null) {\n      cursor.moveTo(pos, side);\n      CachedNode.set(this, cursor._tree);\n    }\n    return cursor;\n  }\n  fullCursor() {\n    return new TreeCursor(this.topNode, true);\n  }\n  get topNode() {\n    return new TreeNode(this, 0, 0, null);\n  }\n  resolve(pos, side = 0) {\n    return this.cursor(pos, side).node;\n  }\n  iterate(spec) {\n    let {enter, leave, from = 0, to = this.length} = spec;\n    for (let c = this.cursor(); ; ) {\n      let mustLeave = false;\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n        if (c.firstChild()) continue;\n        if (!c.type.isAnonymous) mustLeave = true;\n      }\n      for (; ; ) {\n        if (mustLeave && leave) leave(c.type, c.from, c.to);\n        mustLeave = c.type.isAnonymous;\n        if (c.nextSibling()) break;\n        if (!c.parent()) return;\n        mustLeave = true;\n      }\n    }\n  }\n  balance(maxBufferLength = DefaultBufferLength) {\n    return this.children.length <= BalanceBranchFactor ? this : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length, 0);\n  }\n  static build(data) {\n    return buildTree(data);\n  }\n}\nTree.empty = new Tree(NodeType.none, [], [], 0);\nfunction withHash(tree, hash) {\n  if (hash) tree.contextHash = hash;\n  return tree;\n}\nclass TreeBuffer {\n  constructor(buffer, length, set, type = NodeType.none) {\n    this.buffer = buffer;\n    this.length = length;\n    this.set = set;\n    this.type = type;\n  }\n  toString() {\n    let result = [];\n    for (let index = 0; index < this.buffer.length; ) {\n      result.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n    return result.join(\",\");\n  }\n  childString(index) {\n    let id = this.buffer[index], endIndex = this.buffer[index + 3];\n    let type = this.set.types[id], result = type.name;\n    if ((/\\W/).test(result) && !type.isError) result = JSON.stringify(result);\n    index += 4;\n    if (endIndex == index) return result;\n    let children = [];\n    while (index < endIndex) {\n      children.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n    return result + \"(\" + children.join(\",\") + \")\";\n  }\n  findChild(startIndex, endIndex, dir, after) {\n    let {buffer} = this, pick = -1;\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (after != -100000000) {\n        let start = buffer[i + 1], end = buffer[i + 2];\n        if (dir > 0) {\n          if (end > after) pick = i;\n          if (end > after) break;\n        } else {\n          if (start < after) pick = i;\n          if (end >= after) break;\n        }\n      } else {\n        pick = i;\n        if (dir > 0) break;\n      }\n    }\n    return pick;\n  }\n}\nclass TreeNode {\n  constructor(node, from, index, _parent) {\n    this.node = node;\n    this.from = from;\n    this.index = index;\n    this._parent = _parent;\n  }\n  get type() {\n    return this.node.type;\n  }\n  get name() {\n    return this.node.type.name;\n  }\n  get to() {\n    return this.from + this.node.length;\n  }\n  nextChild(i, dir, after, full = false) {\n    for (let parent = this; ; ) {\n      for (let {children, positions} = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i], start = positions[i] + parent.from;\n        if (after != -100000000 && (dir < 0 ? start >= after : start + next.length <= after)) continue;\n        if (next instanceof TreeBuffer) {\n          let index = next.findChild(0, next.buffer.length, dir, after == -100000000 ? -100000000 : after - start);\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n        } else if (full || (!next.type.isAnonymous || hasChild(next))) {\n          let inner = new TreeNode(next, start, i, parent);\n          return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);\n        }\n      }\n      if (full || !parent.type.isAnonymous) return null;\n      i = parent.index + dir;\n      parent = parent._parent;\n      if (!parent) return null;\n    }\n  }\n  get firstChild() {\n    return this.nextChild(0, 1, -100000000);\n  }\n  get lastChild() {\n    return this.nextChild(this.node.children.length - 1, -1, -100000000);\n  }\n  childAfter(pos) {\n    return this.nextChild(0, 1, pos);\n  }\n  childBefore(pos) {\n    return this.nextChild(this.node.children.length - 1, -1, pos);\n  }\n  nextSignificantParent() {\n    let val = this;\n    while (val.type.isAnonymous && val._parent) val = val._parent;\n    return val;\n  }\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null;\n  }\n  get nextSibling() {\n    return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;\n  }\n  get prevSibling() {\n    return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;\n  }\n  get cursor() {\n    return new TreeCursor(this);\n  }\n  resolve(pos, side = 0) {\n    return this.cursor.moveTo(pos, side).node;\n  }\n  getChild(type, before = null, after = null) {\n    let r = getChildren(this, type, before, after);\n    return r.length ? r[0] : null;\n  }\n  getChildren(type, before = null, after = null) {\n    return getChildren(this, type, before, after);\n  }\n  toString() {\n    return this.node.toString();\n  }\n}\nfunction getChildren(node, type, before, after) {\n  let cur = node.cursor, result = [];\n  if (!cur.firstChild()) return result;\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result;\n  for (; ; ) {\n    if (after != null && cur.type.is(after)) return result;\n    if (cur.type.is(type)) result.push(cur.node);\n    if (!cur.nextSibling()) return after == null ? result : [];\n  }\n}\nclass BufferContext {\n  constructor(parent, buffer, index, start) {\n    this.parent = parent;\n    this.buffer = buffer;\n    this.index = index;\n    this.start = start;\n  }\n}\nclass BufferNode {\n  constructor(context, _parent, index) {\n    this.context = context;\n    this._parent = _parent;\n    this.index = index;\n    this.type = context.buffer.set.types[context.buffer.buffer[index]];\n  }\n  get name() {\n    return this.type.name;\n  }\n  get from() {\n    return this.context.start + this.context.buffer.buffer[this.index + 1];\n  }\n  get to() {\n    return this.context.start + this.context.buffer.buffer[this.index + 2];\n  }\n  child(dir, after) {\n    let {buffer} = this.context;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 ? -100000000 : after - this.context.start);\n    return index < 0 ? null : new BufferNode(this.context, this, index);\n  }\n  get firstChild() {\n    return this.child(1, -100000000);\n  }\n  get lastChild() {\n    return this.child(-1, -100000000);\n  }\n  childAfter(pos) {\n    return this.child(1, pos);\n  }\n  childBefore(pos) {\n    return this.child(-1, pos);\n  }\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent();\n  }\n  externalSibling(dir) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);\n  }\n  get nextSibling() {\n    let {buffer} = this.context;\n    let after = buffer.buffer[this.index + 3];\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n    return this.externalSibling(1);\n  }\n  get prevSibling() {\n    let {buffer} = this.context;\n    let parentStart = this._parent ? this._parent.index + 4 : 0;\n    if (this.index == parentStart) return this.externalSibling(-1);\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000));\n  }\n  get cursor() {\n    return new TreeCursor(this);\n  }\n  resolve(pos, side = 0) {\n    return this.cursor.moveTo(pos, side).node;\n  }\n  toString() {\n    return this.context.buffer.childString(this.index);\n  }\n  getChild(type, before = null, after = null) {\n    let r = getChildren(this, type, before, after);\n    return r.length ? r[0] : null;\n  }\n  getChildren(type, before = null, after = null) {\n    return getChildren(this, type, before, after);\n  }\n}\nclass TreeCursor {\n  constructor(node, full = false) {\n    this.full = full;\n    this.buffer = null;\n    this.stack = [];\n    this.index = 0;\n    this.bufferNode = null;\n    if (node instanceof TreeNode) {\n      this.yieldNode(node);\n    } else {\n      this._tree = node.context.parent;\n      this.buffer = node.context;\n      for (let n = node._parent; n; n = n._parent) this.stack.unshift(n.index);\n      this.bufferNode = node;\n      this.yieldBuf(node.index);\n    }\n  }\n  get name() {\n    return this.type.name;\n  }\n  yieldNode(node) {\n    if (!node) return false;\n    this._tree = node;\n    this.type = node.type;\n    this.from = node.from;\n    this.to = node.to;\n    return true;\n  }\n  yieldBuf(index, type) {\n    this.index = index;\n    let {start, buffer} = this.buffer;\n    this.type = type || buffer.set.types[buffer.buffer[index]];\n    this.from = start + buffer.buffer[index + 1];\n    this.to = start + buffer.buffer[index + 2];\n    return true;\n  }\n  yield(node) {\n    if (!node) return false;\n    if (node instanceof TreeNode) {\n      this.buffer = null;\n      return this.yieldNode(node);\n    }\n    this.buffer = node.context;\n    return this.yieldBuf(node.index, node.type);\n  }\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n  }\n  enter(dir, after) {\n    if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));\n    let {buffer} = this.buffer;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 ? -100000000 : after - this.buffer.start);\n    if (index < 0) return false;\n    this.stack.push(this.index);\n    return this.yieldBuf(index);\n  }\n  firstChild() {\n    return this.enter(1, -100000000);\n  }\n  lastChild() {\n    return this.enter(-1, -100000000);\n  }\n  childAfter(pos) {\n    return this.enter(1, pos);\n  }\n  childBefore(pos) {\n    return this.enter(-1, pos);\n  }\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);\n    if (this.stack.length) return this.yieldBuf(this.stack.pop());\n    let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n    this.buffer = null;\n    return this.yieldNode(parent);\n  }\n  sibling(dir) {\n    if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000, this.full));\n    let {buffer} = this.buffer, d = this.stack.length - 1;\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n      if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000));\n    } else {\n      let after = buffer.buffer[this.index + 3];\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000, this.full)) : false;\n  }\n  nextSibling() {\n    return this.sibling(1);\n  }\n  prevSibling() {\n    return this.sibling(-1);\n  }\n  atLastNode(dir) {\n    let index, parent, {buffer} = this;\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false;\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;\n      }\n      ({index, parent} = buffer);\n    } else {\n      ({index, _parent: parent} = this._tree);\n    }\n    for (; parent; {index, _parent: parent} = parent) {\n      for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n        let child = parent.node.children[i];\n        if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child)) return false;\n      }\n    }\n    return true;\n  }\n  move(dir) {\n    if (this.enter(dir, -100000000)) return true;\n    for (; ; ) {\n      if (this.sibling(dir)) return true;\n      if (this.atLastNode(dir) || !this.parent()) return false;\n    }\n  }\n  next() {\n    return this.move(1);\n  }\n  prev() {\n    return this.move(-1);\n  }\n  moveTo(pos, side = 0) {\n    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;\n    for (; ; ) {\n      if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos)) break;\n      if (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) {\n        this.parent();\n        break;\n      }\n    }\n    return this;\n  }\n  get node() {\n    if (!this.buffer) return this._tree;\n    let cache = this.bufferNode, result = null, depth = 0;\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0; ) {\n        for (let c = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c;\n          result = c;\n          depth = d + 1;\n          break scan;\n        }\n        index = this.stack[--d];\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n  }\n  get tree() {\n    return this.buffer ? null : this._tree.node;\n  }\n}\nfunction hasChild(tree) {\n  return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));\n}\nclass FlatBufferCursor {\n  constructor(buffer, index) {\n    this.buffer = buffer;\n    this.index = index;\n  }\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n  get pos() {\n    return this.index;\n  }\n  next() {\n    this.index -= 4;\n  }\n  fork() {\n    return new FlatBufferCursor(this.buffer, this.index);\n  }\n}\nconst BalanceBranchFactor = 8;\nfunction buildTree(data) {\n  var _a;\n  let {buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length} = data;\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n  let types = nodeSet.types;\n  let contextHash = 0;\n  function takeNode(parentStart, minPos, children, positions, inRepeat) {\n    let {id, start, end, size} = cursor;\n    let startPos = start - parentStart;\n    if (size < 0) {\n      if (size == -1) {\n        children.push(reused[id]);\n        positions.push(startPos);\n      } else {\n        contextHash = id;\n      }\n      cursor.next();\n      return;\n    }\n    let type = types[id], node, buffer;\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      let data = new Uint16Array(buffer.size - buffer.skip);\n      let endPos = cursor.pos - buffer.size, index = data.length;\n      while (cursor.pos > endPos) index = copyToBuffer(buffer.start, data, index, inRepeat);\n      node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);\n      startPos = buffer.start - parentStart;\n    } else {\n      let endPos = cursor.pos - size;\n      cursor.next();\n      let localChildren = [], localPositions = [];\n      let localInRepeat = id >= minRepeatType ? id : -1;\n      while (cursor.pos > endPos) {\n        if (cursor.id == localInRepeat) cursor.next(); else takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n      }\n      localChildren.reverse();\n      localPositions.reverse();\n      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor) node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start, contextHash); else node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash);\n    }\n    children.push(node);\n    positions.push(startPos);\n  }\n  function findBufferSize(maxSize, inRepeat) {\n    let fork = cursor.fork();\n    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n    let result = {\n      size: 0,\n      start: 0,\n      skip: 0\n    };\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {\n      if (fork.id == inRepeat) {\n        result.size = size;\n        result.start = start;\n        result.skip = skip;\n        skip += 4;\n        size += 4;\n        fork.next();\n        continue;\n      }\n      let nodeSize = fork.size, startPos = fork.pos - nodeSize;\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n      let nodeStart = fork.start;\n      fork.next();\n      while (fork.pos > startPos) {\n        if (fork.size < 0) break scan;\n        if (fork.id >= minRepeatType) localSkipped += 4;\n        fork.next();\n      }\n      start = nodeStart;\n      size += nodeSize;\n      skip += localSkipped;\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size;\n      result.start = start;\n      result.skip = skip;\n    }\n    return result.size > 4 ? result : undefined;\n  }\n  function copyToBuffer(bufferStart, buffer, index, inRepeat) {\n    let {id, start, end, size} = cursor;\n    cursor.next();\n    if (id == inRepeat) return index;\n    let startIndex = index;\n    if (size > 4) {\n      let endPos = cursor.pos - (size - 4);\n      while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer, index, inRepeat);\n    }\n    if (id < minRepeatType) {\n      buffer[--index] = startIndex;\n      buffer[--index] = end - bufferStart;\n      buffer[--index] = start - bufferStart;\n      buffer[--index] = id;\n    }\n    return index;\n  }\n  let children = [], positions = [];\n  while (cursor.pos > 0) takeNode(data.start || 0, 0, children, positions, -1);\n  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n  return new Tree(types[topID], children.reverse(), positions.reverse(), length);\n}\nfunction balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length, contextHash) {\n  let localChildren = [], localPositions = [];\n  if (length <= maxBufferLength) {\n    for (let i = from; i < to; i++) {\n      localChildren.push(children[i]);\n      localPositions.push(positions[i] - start);\n    }\n  } else {\n    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));\n    for (let i = from; i < to; ) {\n      let groupFrom = i, groupStart = positions[i];\n      i++;\n      for (; i < to; i++) {\n        let nextEnd = positions[i] + children[i].length;\n        if (nextEnd - groupStart > maxChild) break;\n      }\n      if (i == groupFrom + 1) {\n        let only = children[groupFrom];\n        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) {\n          for (let j = 0; j < only.children.length; j++) {\n            localChildren.push(only.children[j]);\n            localPositions.push(only.positions[j] + groupStart - start);\n          }\n          continue;\n        }\n        localChildren.push(only);\n      } else if (i == groupFrom + 1) {\n        localChildren.push(children[groupFrom]);\n      } else {\n        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash);\n        if (innerType != NodeType.none && !containsType(inner.children, innerType)) inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash);\n        localChildren.push(inner);\n      }\n      localPositions.push(groupStart - start);\n    }\n  }\n  return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash);\n}\nfunction containsType(nodes, type) {\n  for (let elt of nodes) if (elt.type == type) return true;\n  return false;\n}\nclass TreeFragment {\n  constructor(from, to, tree, offset, open) {\n    this.from = from;\n    this.to = to;\n    this.tree = tree;\n    this.offset = offset;\n    this.open = open;\n  }\n  get openStart() {\n    return (this.open & 1) > 0;\n  }\n  get openEnd() {\n    return (this.open & 2) > 0;\n  }\n  static applyChanges(fragments, changes, minGap = 128) {\n    if (!changes.length) return fragments;\n    let result = [];\n    let fI = 1, nextF = fragments.length ? fragments[0] : null;\n    let cI = 0, pos = 0, off = 0;\n    for (; ; ) {\n      let nextC = cI < changes.length ? changes[cI++] : null;\n      let nextPos = nextC ? nextC.fromA : 1e9;\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut = nextF;\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n          cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 : 0) | (nextC ? 2 : 0));\n        }\n        if (cut) result.push(cut);\n        if (nextF.to > nextPos) break;\n        nextF = fI < fragments.length ? fragments[fI++] : null;\n      }\n      if (!nextC) break;\n      pos = nextC.toA;\n      off = nextC.toA - nextC.toB;\n    }\n    return result;\n  }\n  static addTree(tree, fragments = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 : 0)];\n    for (let f of fragments) if (f.to > tree.length) result.push(f);\n    return result;\n  }\n}\nfunction stringInput(input) {\n  return new StringInput(input);\n}\nclass StringInput {\n  constructor(string, length = string.length) {\n    this.string = string;\n    this.length = length;\n  }\n  get(pos) {\n    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);\n  }\n  lineAfter(pos) {\n    if (pos < 0) return \"\";\n    let end = this.string.indexOf(\"\\n\", pos);\n    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));\n  }\n  read(from, to) {\n    return this.string.slice(from, Math.min(this.length, to));\n  }\n  clip(at) {\n    return new StringInput(this.string, at);\n  }\n}\nexports.DefaultBufferLength = DefaultBufferLength;\nexports.NodeProp = NodeProp;\nexports.NodeSet = NodeSet;\nexports.NodeType = NodeType;\nexports.Tree = Tree;\nexports.TreeBuffer = TreeBuffer;\nexports.TreeCursor = TreeCursor;\nexports.TreeFragment = TreeFragment;\nexports.stringInput = stringInput;\n"}