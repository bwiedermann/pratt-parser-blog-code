{"contents":"exports.__esModule = true;\nvar view_1 = __fusereq(18);\nvar state_1 = __fusereq(16);\nvar rangeset_1 = __fusereq(39);\nvar text_1 = __fusereq(35);\nvar language_1 = __fusereq(21);\nconst defaults = {\n  brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n  before: \")]}'\\\":;>\"\n};\nconst closeBracketEffect = state_1.StateEffect.define({\n  map(value, mapping) {\n    let mapped = mapping.mapPos(value, -1, state_1.MapMode.TrackAfter);\n    return mapped == null ? undefined : mapped;\n  }\n});\nconst skipBracketEffect = state_1.StateEffect.define({\n  map(value, mapping) {\n    return mapping.mapPos(value);\n  }\n});\nconst closedBracket = new (class extends rangeset_1.RangeValue {})();\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = state_1.StateField.define({\n  create() {\n    return rangeset_1.RangeSet.empty;\n  },\n  update(value, tr) {\n    if (tr.selection) {\n      let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;\n      let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;\n      if (lineStart != tr.changes.mapPos(prevLineStart, -1)) value = rangeset_1.RangeSet.empty;\n    }\n    value = value.map(tr.changes);\n    for (let effect of tr.effects) {\n      if (effect.is(closeBracketEffect)) value = value.update({\n        add: [closedBracket.range(effect.value, effect.value + 1)]\n      }); else if (effect.is(skipBracketEffect)) value = value.update({\n        filter: from => from != effect.value\n      });\n    }\n    return value;\n  }\n});\nfunction closeBrackets() {\n  return [view_1.EditorView.inputHandler.of(handleInput), bracketState];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n  for (let i = 0; i < definedClosing.length; i += 2) if (definedClosing.charCodeAt(i) == ch) return definedClosing.charAt(i + 1);\n  return text_1.fromCodePoint(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n  return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nfunction handleInput(view, from, to, insert) {\n  if (view.composing) return false;\n  let sel = view.state.selection.main;\n  if (insert.length > 2 || insert.length == 2 && text_1.codePointSize(text_1.codePointAt(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;\n  let tr = insertBracket(view.state, insert);\n  if (!tr) return false;\n  view.dispatch(tr);\n  return true;\n}\nconst deleteBracketPair = ({state, dispatch}) => {\n  let conf = config(state, state.selection.main.head);\n  let tokens = conf.brackets || defaults.brackets;\n  let dont = null, changes = state.changeByRange(range => {\n    if (range.empty) {\n      let before = prevChar(state.doc, range.head);\n      for (let token of tokens) {\n        if (token == before && nextChar(state.doc, range.head) == closing(text_1.codePointAt(token, 0))) return {\n          changes: {\n            from: range.head - token.length,\n            to: range.head + token.length\n          },\n          range: state_1.EditorSelection.cursor(range.head - token.length),\n          annotations: state_1.Transaction.userEvent.of(\"delete\")\n        };\n      }\n    }\n    return {\n      range: dont = range\n    };\n  });\n  if (!dont) dispatch(state.update(changes, {\n    scrollIntoView: true\n  }));\n  return !dont;\n};\nconst closeBracketsKeymap = [{\n  key: \"Backspace\",\n  run: deleteBracketPair\n}];\nfunction insertBracket(state, bracket) {\n  let conf = config(state, state.selection.main.head);\n  let tokens = conf.brackets || defaults.brackets;\n  for (let tok of tokens) {\n    let closed = closing(text_1.codePointAt(tok, 0));\n    if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1) : handleOpen(state, tok, closed, conf.before || defaults.before);\n    if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);\n  }\n  return null;\n}\nfunction closedBracketAt(state, pos) {\n  let found = false;\n  state.field(bracketState).between(0, state.doc.length, from => {\n    if (from == pos) found = true;\n  });\n  return found;\n}\nfunction nextChar(doc, pos) {\n  let next = doc.sliceString(pos, pos + 2);\n  return next.slice(0, text_1.codePointSize(text_1.codePointAt(next, 0)));\n}\nfunction prevChar(doc, pos) {\n  let prev = doc.sliceString(pos - 2, pos);\n  return text_1.codePointSize(text_1.codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n  let dont = null, changes = state.changeByRange(range => {\n    if (!range.empty) return {\n      changes: [{\n        insert: open,\n        from: range.from\n      }, {\n        insert: close,\n        from: range.to\n      }],\n      effects: closeBracketEffect.of(range.to + open.length),\n      range: state_1.EditorSelection.range(range.anchor + open.length, range.head + open.length)\n    };\n    let next = nextChar(state.doc, range.head);\n    if (!next || (/\\s/).test(next) || closeBefore.indexOf(next) > -1) return {\n      changes: {\n        insert: open + close,\n        from: range.head\n      },\n      effects: closeBracketEffect.of(range.head + open.length),\n      range: state_1.EditorSelection.cursor(range.head + open.length)\n    };\n    return {\n      range: dont = range\n    };\n  });\n  return dont ? null : state.update(changes, {\n    scrollIntoView: true,\n    annotations: state_1.Transaction.userEvent.of(\"input\")\n  });\n}\nfunction handleClose(state, _open, close) {\n  let dont = null, moved = state.selection.ranges.map(range => {\n    if (range.empty && nextChar(state.doc, range.head) == close) return state_1.EditorSelection.cursor(range.head + close.length);\n    return dont = range;\n  });\n  return dont ? null : state.update({\n    selection: state_1.EditorSelection.create(moved, state.selection.mainIndex),\n    scrollIntoView: true,\n    effects: state.selection.ranges.map(({from}) => skipBracketEffect.of(from))\n  });\n}\nfunction handleSame(state, token, allowTriple) {\n  let dont = null, changes = state.changeByRange(range => {\n    if (!range.empty) return {\n      changes: [{\n        insert: token,\n        from: range.from\n      }, {\n        insert: token,\n        from: range.to\n      }],\n      effects: closeBracketEffect.of(range.to + token.length),\n      range: state_1.EditorSelection.range(range.anchor + token.length, range.head + token.length)\n    };\n    let pos = range.head, next = nextChar(state.doc, pos);\n    if (next == token) {\n      if (nodeStart(state, pos)) {\n        return {\n          changes: {\n            insert: token + token,\n            from: pos\n          },\n          effects: closeBracketEffect.of(pos + token.length),\n          range: state_1.EditorSelection.cursor(pos + token.length)\n        };\n      } else if (closedBracketAt(state, pos)) {\n        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n        return {\n          range: state_1.EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),\n          effects: skipBracketEffect.of(pos)\n        };\n      }\n    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && nodeStart(state, pos - 2 * token.length)) {\n      return {\n        changes: {\n          insert: token + token + token + token,\n          from: pos\n        },\n        effects: closeBracketEffect.of(pos + token.length),\n        range: state_1.EditorSelection.cursor(pos + token.length)\n      };\n    } else if (state.charCategorizer(pos)(next) != state_1.CharCategory.Word) {\n      let prev = state.sliceDoc(pos - 1, pos);\n      if (prev != token && state.charCategorizer(pos)(prev) != state_1.CharCategory.Word) return {\n        changes: {\n          insert: token + token,\n          from: pos\n        },\n        effects: closeBracketEffect.of(pos + token.length),\n        range: state_1.EditorSelection.cursor(pos + token.length)\n      };\n    }\n    return {\n      range: dont = range\n    };\n  });\n  return dont ? null : state.update(changes, {\n    scrollIntoView: true,\n    annotations: state_1.Transaction.userEvent.of(\"input\")\n  });\n}\nfunction nodeStart(state, pos) {\n  let tree = language_1.syntaxTree(state).resolve(pos + 1);\n  return tree.parent && tree.from == pos;\n}\nexports.closeBrackets = closeBrackets;\nexports.closeBracketsKeymap = closeBracketsKeymap;\nexports.deleteBracketPair = deleteBracketPair;\nexports.insertBracket = insertBracket;\n"}