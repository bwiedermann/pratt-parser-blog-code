{"contents":"exports.__esModule = true;\nvar state_1 = __fusereq(16);\nvar parser_1 = __fusereq(17);\nexports.parseResults = state_1.StateField.define({\n  create() {\n    return emptyParseResults;\n  },\n  update(value, tr) {\n    return tr.docChanged ? parseProgram(tr) : value;\n  }\n});\nfunction parseProgram(tr) {\n  const contents = tr.state.doc.toString();\n  let varMap = {};\n  let registeredNodes = {};\n  const ast = parser_1.parse(contents, varMap, registeredNodes);\n  return {\n    nodes: ast.nodes,\n    parseErrors: ast.errors,\n    varMap: varMap,\n    registeredNodes: registeredNodes\n  };\n}\nconst emptyParseResults = {\n  nodes: [],\n  parseErrors: [],\n  varMap: {},\n  registeredNodes: {}\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/parseResults.ts\"],\"names\":[\"state_1\",\"define\",\"create\",\"emptyParseResults\",\"update\",\"value\",\"tr\",\"docChanged\",\"parseProgram\",\"contents\",\"state\",\"doc\",\"toString\",\"varMap\",\"registeredNodes\",\"ast\",\"parser_1\",\"nodes\",\"parseErrors\",\"errors\"],\"mappings\":\";;;uBASsDA,mBAAWC;EAC/DC;WAAkBC;;EAClBC,OAAOC,OAAOC;WAAaA,GAAGC,aAAaC,aAAaF,MAAMD;;;AAMhE,sBAAsBC;QACdG,WAAWH,GAAGI,MAAMC,IAAIC;MAE1BC;MACAC;QACEC,MAAMC,eAAMP,UAAUI,QAAQC;;IAGlCG,OAAOF,IAAIE;IACXC,aAAaH,IAAII;IACjBN,QAAQA;IACRC,iBAAiBA;;;MAiBfX;EACJc;EACAC;EACAL;EACAC\",\"sourcesContent\":[\"import {StateField} from \\\"@codemirror/state\\\"\\nimport {Transaction} from \\\"@codemirror/state\\\"\\nimport * as AST from './ast';\\nimport {parse} from './parser';\\nimport {ParseError} from './position';\\n\\n/**\\n * A State field that holds the results of parsing\\n */\\nexport const parseResults: StateField<ParseResults> = StateField.define({\\n  create() { return emptyParseResults },\\n  update(value, tr) { return tr.docChanged ? parseProgram(tr) : value }\\n})\\n\\n/**\\n * Parse the program created from a transaction, returning a ParseResults object\\n */\\nfunction parseProgram(tr: Transaction) : ParseResults {\\n  const contents = tr.state.doc.toString()\\n\\n  let varMap: {[key: string]: string} = {}\\n  let registeredNodes: {[key: string]: AST.Node} = {}\\n  const ast = parse(contents, varMap, registeredNodes)\\n\\n  return {\\n    nodes: ast.nodes,\\n    parseErrors: ast.errors,\\n    varMap: varMap,\\n    registeredNodes: registeredNodes\\n  }\\n}\\n\\n/**\\n * Type that describes the results of parsing\\n */\\nexport type ParseResults = {\\n  nodes: AST.Node[];\\n  parseErrors: ParseError[];\\n  varMap: {[key: string]: string};\\n  registeredNodes: {[key: string]: AST.Node};\\n}\\n\\n/**\\n * Can be used as the initial results of parsing\\n */\\nconst emptyParseResults: ParseResults = {\\n  nodes: [],\\n  parseErrors: [],\\n  varMap: {},\\n  registeredNodes: {}\\n}\\n\"]}"}