{"contents":"exports.__esModule = true;\nvar constantChecker_1 = __fusereq(190);\nfunction typecheck(nodes, registeredNodes) {\n  const aNodes = [];\n  let totalErrors = [];\n  nodes.forEach(node => {\n    let {errors, aNode} = typecheckNode(node, registeredNodes);\n    if (errors.length == 0) {\n      constantChecker_1.constCheckNode(aNode, registeredNodes);\n    }\n    aNodes.push(aNode);\n    totalErrors = totalErrors.concat(errors);\n  });\n  return {\n    errors: totalErrors,\n    aTree: aNodes\n  };\n}\nexports.typecheck = typecheck;\nfunction typecheckNode(node, registeredNodes) {\n  return checkerMap[node.nodeType].check(node, registeredNodes);\n}\nclass TypeError {\n  constructor(message, position) {\n    this.message = message;\n    this.position = position;\n  }\n}\nexports.TypeError = TypeError;\nclass CheckNumber {\n  check(node, registeredNodes) {\n    let newNode = {\n      nodeType: node.nodeType,\n      value: node.value,\n      outputType: {\n        status: 'Definitely',\n        valueType: node.valueType,\n        asserts: [],\n        constType: 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId\n    };\n    registeredNodes[newNode.nodeId] = newNode;\n    return {\n      errors: [],\n      aNode: newNode\n    };\n  }\n}\nclass CheckBoolean {\n  check(node, registeredNodes) {\n    let newNode = {\n      nodeType: node.nodeType,\n      value: node.value,\n      outputType: {\n        status: 'Definitely',\n        valueType: node.valueType,\n        asserts: [],\n        constType: 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId\n    };\n    registeredNodes[newNode.nodeId] = newNode;\n    return {\n      errors: [],\n      aNode: newNode\n    };\n  }\n}\nclass CheckBinary {\n  check(node, registeredNodes) {\n    const {errors: lErrors, aNode: lANode} = typecheckNode(node.left, registeredNodes);\n    const {errors: rErrors, aNode: rANode} = typecheckNode(node.right, registeredNodes);\n    const totalErrors = lErrors.concat(rErrors);\n    if (lANode.outputType.valueType != rANode.outputType.valueType) {\n      totalErrors.push(new TypeError(\"incompatible types for binary operator\", node.pos));\n    } else if (rANode.outputType.valueType == 'boolean' && (node.operator != \"|\" && node.operator != '&')) {\n      totalErrors.push(new TypeError(\"incompatible operation for boolean operands\", node.pos));\n    } else if (rANode.outputType.valueType == 'number' && (node.operator == \"|\" || node.operator == '&')) {\n      totalErrors.push(new TypeError(\"incompatible operation for number operands\", node.pos));\n    }\n    let newNode = {\n      nodeType: node.nodeType,\n      operator: node.operator,\n      left: lANode,\n      right: rANode,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: lANode.outputType.valueType,\n        asserts: [],\n        constType: 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId,\n      value: undefined\n    };\n    registeredNodes[newNode.nodeId] = newNode;\n    return {\n      errors: [],\n      aNode: newNode\n    };\n  }\n}\nclass CheckFunction {\n  check(node, registeredNodes) {\n    let totalErrors = [];\n    let aArgs = [];\n    const {errors: arg1Errors, aNode: arg1Node} = typecheckNode(node.args[0], registeredNodes);\n    totalErrors = totalErrors.concat(arg1Errors);\n    aArgs.push(arg1Node);\n    if (node.args.length > 1) {\n      const {errors: arg2Errors, aNode: arg2Node} = typecheckNode(node.args[1], registeredNodes);\n      totalErrors = totalErrors.concat(arg2Errors);\n      aArgs.push(arg2Node);\n      if (aArgs[0].outputType.valueType != aArgs[1].outputType.valueType) {\n        totalErrors.push(new TypeError(\"arguments must have same type\", node.args[0].pos));\n      }\n    }\n    const functionName = node.name;\n    const argType = exports.builtins[functionName].inputType;\n    let newNode = {\n      nodeType: 'Function',\n      name: functionName,\n      args: aArgs,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: exports.builtins[functionName].resultType,\n        asserts: [],\n        constType: 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId,\n      value: undefined\n    };\n    if (argType) {\n      if (argType != 'any' && newNode.args[0].outputType.valueType != argType) {\n        totalErrors.push(new TypeError(\"incompatible argument type for \" + functionName, node.pos));\n      }\n    } else {\n      totalErrors.push(new TypeError(\"unknown function\", node.pos));\n    }\n    registeredNodes[newNode.nodeId] = newNode;\n    return {\n      errors: totalErrors,\n      aNode: newNode\n    };\n  }\n}\nclass CheckChoose {\n  check(node, registeredNodes) {\n    let totalErrors = [];\n    const predicate = node.case.predicate;\n    const consequent = node.case.consequent;\n    const otherwise = node.otherwise;\n    const {errors: predErrors, aNode: predNode} = typecheckNode(predicate, registeredNodes);\n    const {errors: consErrors, aNode: consNode} = typecheckNode(consequent, registeredNodes);\n    const {errors: otherErrors, aNode: otherNode} = typecheckNode(otherwise, registeredNodes);\n    totalErrors = totalErrors.concat(predErrors).concat(consErrors).concat(otherErrors);\n    if (consNode.outputType.valueType != otherNode.outputType.valueType) {\n      totalErrors.push(new TypeError(\"Return types are not the same for both cases\", consequent.pos));\n      totalErrors.push(new TypeError(\"Return types are not the same for both cases\", otherwise.pos));\n    }\n    if (predNode.outputType.valueType != 'boolean') {\n      totalErrors.push(new TypeError(\"Predicate must return a boolean\", predicate.pos));\n    }\n    let newNode = {\n      nodeType: 'Choose',\n      case: {\n        predicate: predNode,\n        consequent: consNode\n      },\n      otherwise: otherNode,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: consNode.outputType.valueType,\n        asserts: [],\n        constType: 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId,\n      value: undefined\n    };\n    registeredNodes[newNode.nodeId] = newNode;\n    return {\n      errors: totalErrors,\n      aNode: newNode\n    };\n  }\n}\nclass CheckVariable {\n  check(node, registeredNodes) {\n    let totalErrors = [];\n    const {errors: assignmentErrors, aNode: assignmentNode} = typecheckNode(node.assignment, registeredNodes);\n    totalErrors = totalErrors.concat(assignmentErrors);\n    let newNode = {\n      nodeType: 'VariableAssignment',\n      name: node.name,\n      assignment: assignmentNode,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: assignmentNode.outputType.valueType,\n        asserts: [],\n        constType: 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId,\n      value: undefined\n    };\n    registeredNodes[newNode.nodeId] = newNode;\n    return {\n      errors: totalErrors,\n      aNode: newNode\n    };\n  }\n}\nclass CheckIdentifier {\n  check(node, registeredNodes) {\n    let totalErrors = [];\n    let valueNode = registeredNodes[node.assignmentId].assignment;\n    if (valueNode == undefined) {\n      totalErrors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\n    }\n    let newNode = {\n      nodeType: 'Identifier',\n      name: node.name,\n      assignmentId: node.assignmentId,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: valueNode.outputType.valueType,\n        asserts: [],\n        constType: 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId,\n      value: undefined\n    };\n    registeredNodes[newNode.nodeId] = newNode;\n    return {\n      errors: totalErrors,\n      aNode: newNode\n    };\n  }\n}\nexports.builtins = {\n  \"IsDefined\": {\n    inputType: 'any',\n    resultType: 'boolean',\n    status: \"Definitely\",\n    constType: \"Constant\"\n  },\n  \"Inverse\": {\n    inputType: 'number',\n    resultType: 'number',\n    status: \"Variable\",\n    constType: \"Constant\"\n  },\n  \"InputN\": {\n    inputType: 'number',\n    resultType: 'number',\n    status: \"Maybe-Undefined\",\n    constType: \"Non-Constant\"\n  },\n  \"Sink\": {\n    inputType: 'any',\n    resultType: 'any',\n    status: \"Maybe-Undefined\",\n    constType: \"Constant\"\n  },\n  \"ParseOrderedPair\": {\n    inputType: 'number',\n    resultType: 'pair',\n    status: \"Variable\",\n    constType: \"Constant\"\n  },\n  \"X\": {\n    inputType: 'pair',\n    resultType: 'number',\n    status: \"Variable\",\n    constType: \"Constant\"\n  },\n  \"Y\": {\n    inputType: 'pair',\n    resultType: 'number',\n    status: \"Variable\",\n    constType: \"Constant\"\n  },\n  \"Not\": {\n    inputType: 'boolean',\n    resultType: 'boolean',\n    status: \"Definitely\",\n    constType: \"Constant\"\n  },\n  \"InputB\": {\n    inputType: 'boolean',\n    resultType: 'boolean',\n    status: \"Maybe-Undefined\",\n    constType: \"Non-Constant\"\n  },\n  \"Sqrt\": {\n    inputType: 'number',\n    resultType: 'number',\n    status: \"Variable\",\n    constType: \"Constant\"\n  }\n};\nconst checkerMap = {\n  'Number': new CheckNumber(),\n  'Boolean': new CheckBoolean(),\n  'BinaryOperation': new CheckBinary(),\n  'Function': new CheckFunction(),\n  'Choose': new CheckChoose(),\n  'VariableAssignment': new CheckVariable(),\n  'Identifier': new CheckIdentifier()\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/typechecker.ts\"],\"names\":[\"nodes\",\"registeredNodes\",\"aNodes\",\"totalErrors\",\"forEach\",\"node\",\"errors\",\"aNode\",\"typecheckNode\",\"length\",\"constantChecker_1\",\"push\",\"concat\",\"aTree\",\"checkerMap\",\"nodeType\",\"check\",\"constructor\",\"message\",\"position\",\"newNode\",\"value\",\"outputType\",\"status\",\"valueType\",\"asserts\",\"constType\",\"pos\",\"nodeId\",\"lErrors\",\"lANode\",\"left\",\"rErrors\",\"rANode\",\"right\",\"TypeError\",\"operator\",\"undefined\",\"aArgs\",\"arg1Errors\",\"arg1Node\",\"args\",\"arg2Errors\",\"arg2Node\",\"functionName\",\"name\",\"argType\",\"exports\",\"inputType\",\"resultType\",\"predicate\",\"case\",\"consequent\",\"otherwise\",\"predErrors\",\"predNode\",\"consErrors\",\"consNode\",\"otherErrors\",\"otherNode\",\"assignmentErrors\",\"assignmentNode\",\"assignment\",\"valueNode\",\"assignmentId\",\"CheckNumber\",\"CheckBoolean\",\"CheckBinary\",\"CheckFunction\",\"CheckChoose\",\"CheckVariable\",\"CheckIdentifier\"],\"mappings\":\"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\",\"sourcesContent\":[\"import {Position} from './position';\\nimport * as AST from './ast';\\nimport * as AnalyzedTree from './analyzedTree';\\nimport {constCheckNode} from './constantChecker';\\n\\nexport function typecheck(nodes: AST.Node[], registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\\n                          {errors: TypeError[], aTree: AnalyzedTree.AnalyzedNode[]} {\\n  const aNodes: AnalyzedTree.AnalyzedNode[] = [];\\n  let totalErrors: TypeError[] = [];\\n\\n  nodes.forEach(node => {\\n    let {errors, aNode} = typecheckNode(node, registeredNodes);\\n    if (errors.length == 0) {\\n      constCheckNode(aNode, registeredNodes);\\n    }\\n    aNodes.push(aNode);\\n    totalErrors = totalErrors.concat(errors);\\n  });\\n\\n  return {errors: totalErrors, aTree: aNodes};\\n}\\n\\nfunction typecheckNode(node: AST.Node, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\\n                        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\\n  return checkerMap[node.nodeType].check(node, registeredNodes);\\n}\\n\\nexport class TypeError {\\n  constructor(public message: string, public position: Position) {}\\n}\\n\\nexport interface TypeChecker {\\n  check(node: AST.Node, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode};\\n}\\n\\n// A number requires no type checking\\nclass CheckNumber implements TypeChecker {\\n  check(node: AST.NumberNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\\n    let newNode = {\\n      nodeType: node.nodeType,\\n      value: node.value,\\n      outputType: {\\n        status: 'Definitely' as 'Definitely',\\n        valueType: node.valueType,\\n        asserts: [],\\n        constType: 'Constant' as 'Constant'\\n      },\\n      pos: node.pos,\\n      nodeId: node.nodeId\\n    };\\n\\n    registeredNodes[newNode.nodeId] = newNode;\\n\\n    return {errors: [], aNode: newNode};\\n  }\\n}\\n\\n// A boolean requires no type checking\\nclass CheckBoolean implements TypeChecker {\\n  check(node: AST.BooleanNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\\n    let newNode = {\\n      nodeType: node.nodeType,\\n      value: node.value,\\n      outputType: {\\n        status: 'Definitely' as 'Definitely',\\n        valueType: node.valueType,\\n        asserts: [],\\n        constType: 'Constant' as 'Constant'\\n      },\\n      pos: node.pos,\\n      nodeId: node.nodeId\\n    };\\n\\n    registeredNodes[newNode.nodeId] = newNode;\\n\\n    return {errors: [], aNode: newNode};\\n  }\\n}\\n\\nclass CheckBinary implements TypeChecker {\\n  check(node: AST.BinaryOperationNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\\n    const { errors: lErrors, aNode: lANode } = typecheckNode(node.left, registeredNodes);\\n    const { errors: rErrors, aNode: rANode } = typecheckNode(node.right, registeredNodes);\\n    const totalErrors = lErrors.concat(rErrors);\\n    \\n    // Check if left and right are the same type (both numbers or both booleans)\\n    if (lANode.outputType.valueType != rANode.outputType.valueType) {\\n      totalErrors.push(new TypeError(\\\"incompatible types for binary operator\\\", node.pos));\\n    }\\n    // Check if incorrect combination of operator and operands\\n    else if (rANode.outputType.valueType == 'boolean' && (node.operator != \\\"|\\\" && node.operator != '&')) {\\n      totalErrors.push(new TypeError(\\\"incompatible operation for boolean operands\\\", node.pos));\\n    }\\n    else if (rANode.outputType.valueType == 'number' && (node.operator == \\\"|\\\" || node.operator == '&')) {\\n      totalErrors.push(new TypeError(\\\"incompatible operation for number operands\\\", node.pos));\\n    }\\n\\n\\n    let newNode = {\\n      nodeType: node.nodeType,\\n      operator: node.operator,\\n      left: lANode,\\n      right: rANode,\\n      outputType: {\\n        status: 'Maybe-Undefined' as 'Maybe-Undefined',\\n        // Since we've already checked the left and right are the same type\\n        // we can set the overall value type to the left\\n        valueType: lANode.outputType.valueType,\\n        asserts: [],\\n        constType: 'Constant' as 'Constant'\\n      },\\n      pos: node.pos,\\n      nodeId: node.nodeId,\\n      value: undefined\\n    };\\n\\n    registeredNodes[newNode.nodeId] = newNode;\\n\\n\\n    return {errors: [], aNode: newNode};\\n  }\\n}\\n\\nclass CheckFunction implements TypeChecker {\\n  check(node: AST.FunctionNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\\n    let totalErrors: TypeError[] = [];\\n    let aArgs: AnalyzedTree.AnalyzedNode[] = [];\\n\\n    // First typecheck the argument(s)\\n    const { errors: arg1Errors, aNode: arg1Node } = typecheckNode(node.args[0], registeredNodes);\\n    totalErrors = totalErrors.concat(arg1Errors);\\n    aArgs.push(arg1Node);\\n    if (node.args.length > 1) {\\n      const { errors: arg2Errors, aNode: arg2Node } = typecheckNode(node.args[1], registeredNodes);\\n      totalErrors = totalErrors.concat(arg2Errors);\\n      aArgs.push(arg2Node);\\n      // Both arguments must have the same type\\n      if (aArgs[0].outputType.valueType != aArgs[1].outputType.valueType) {\\n        totalErrors.push(new TypeError(\\\"arguments must have same type\\\", node.args[0].pos));\\n      }\\n    }\\n\\n    const functionName = node.name\\n    const argType = builtins[functionName].inputType;\\n\\n    let newNode = {\\n      nodeType: 'Function' as 'Function',\\n      name: functionName,\\n      args: aArgs,\\n      outputType: {\\n        status: 'Maybe-Undefined' as 'Maybe-Undefined',\\n        valueType: builtins[functionName].resultType, // Refer to the builtins dictionary below\\n        asserts: [],\\n        constType: 'Constant' as 'Constant'\\n      },\\n      pos: node.pos,\\n      nodeId: node.nodeId,\\n      value: undefined\\n    };\\n\\n    // If this is a builtin function, check it has the correct argument types\\n    // otherwise throw an error (we don't know what this function is)\\n    if (argType) {\\n      // Assume both arguments are the same type (see error produced above)\\n      if (argType != 'any' && newNode.args[0].outputType.valueType != argType) {\\n        totalErrors.push(new TypeError(\\\"incompatible argument type for \\\" + functionName, node.pos));\\n      }\\n      \\n    } else {\\n      totalErrors.push(new TypeError(\\\"unknown function\\\", node.pos));\\n    }\\n\\n    registeredNodes[newNode.nodeId] = newNode;\\n\\n    return {errors: totalErrors, aNode: newNode};\\n  }\\n}\\n\\nclass CheckChoose implements TypeChecker {\\n  check(node: AST.ChooseNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\\n    let totalErrors: TypeError[] = [];\\n\\n    const predicate = node.case.predicate;\\n    const consequent = node.case.consequent;\\n    const otherwise = node.otherwise;\\n\\n    // First typecheck the inner nodes\\n    const { errors: predErrors, aNode: predNode } = typecheckNode(predicate, registeredNodes);\\n    const { errors: consErrors, aNode: consNode } = typecheckNode(consequent, registeredNodes);\\n    const { errors: otherErrors, aNode: otherNode } = typecheckNode(otherwise, registeredNodes);\\n    totalErrors = totalErrors.concat(predErrors).concat(consErrors).concat(otherErrors);\\n\\n    // Check that the return types are the same for both consequent and otherwise\\n    if (consNode.outputType.valueType != otherNode.outputType.valueType) {\\n      totalErrors.push(new TypeError(\\\"Return types are not the same for both cases\\\", consequent.pos));\\n      totalErrors.push(new TypeError(\\\"Return types are not the same for both cases\\\", otherwise.pos));\\n    }\\n\\n    // Check that the predicate returns a boolean\\n    if (predNode.outputType.valueType != 'boolean') {\\n      totalErrors.push(new TypeError(\\\"Predicate must return a boolean\\\", predicate.pos));\\n    }\\n\\n    let newNode = {\\n      nodeType: 'Choose' as 'Choose',\\n      case: { predicate: predNode, consequent: consNode },\\n      otherwise: otherNode,\\n      outputType: {\\n        status: 'Maybe-Undefined' as 'Maybe-Undefined',\\n        // Since we've already checked the consequent and otherwise statements are the same type\\n        // we can set the overall value type to the consequent\\n        valueType: consNode.outputType.valueType,\\n        asserts: [],\\n        constType: 'Constant' as 'Constant'\\n      },\\n      pos: node.pos,\\n      nodeId: node.nodeId,\\n      value: undefined\\n    };\\n\\n    registeredNodes[newNode.nodeId] = newNode;\\n\\n    return {errors: totalErrors, aNode: newNode};\\n  }\\n}\\n\\nclass CheckVariable implements TypeChecker {\\n  check(node: AST.VariableAssignmentNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\\n    let totalErrors: TypeError[] = [];\\n\\n    // First typecheck the assignment node\\n    const { errors: assignmentErrors, aNode: assignmentNode } = typecheckNode(node.assignment, registeredNodes);\\n    totalErrors = totalErrors.concat(assignmentErrors);\\n\\n    let newNode = {\\n      nodeType: 'VariableAssignment' as 'VariableAssignment',\\n      name: node.name,\\n      assignment: assignmentNode,\\n      outputType: {\\n        status: 'Maybe-Undefined' as 'Maybe-Undefined',\\n        valueType: assignmentNode.outputType.valueType,\\n        asserts: [],\\n        constType: 'Constant' as 'Constant'\\n      },\\n      pos: node.pos,\\n      nodeId: node.nodeId,\\n      value: undefined\\n    };\\n\\n    registeredNodes[newNode.nodeId] = newNode;\\n\\n    return {errors: totalErrors, aNode: newNode};\\n  }\\n}\\n\\nclass CheckIdentifier implements TypeChecker {\\n  check(node: AST.IdentifierNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\\n    let totalErrors: TypeError[] = [];\\n\\n    // Grab the node the identifier was previously assigned to\\n    let valueNode = registeredNodes[node.assignmentId].assignment;\\n\\n    // If this assignmentId is not found in the AST, throw an error\\n    if (valueNode == undefined) {\\n      totalErrors.push(new TypeError(\\\"This variable doesn't have a value\\\", node.pos));\\n    }\\n\\n    let newNode = {\\n      nodeType: 'Identifier' as 'Identifier',\\n      name: node.name,\\n      assignmentId: node.assignmentId,\\n      outputType: {\\n        status: 'Maybe-Undefined' as 'Maybe-Undefined',\\n        valueType: valueNode.outputType.valueType, // Shouldn't be problem anymore\\n        asserts: [],\\n        constType: 'Constant' as 'Constant'\\n      },\\n      pos: node.pos,\\n      nodeId: node.nodeId,\\n      value: undefined\\n    };\\n\\n    registeredNodes[newNode.nodeId] = newNode;\\n\\n    return {errors: totalErrors, aNode: newNode};\\n  }\\n}\\n\\n// Dictionary of builtin functions that gives the necessary information for a given function name \\nexport const builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType, status: string, constType: string} } = {\\n  \\\"IsDefined\\\": {inputType: 'any', resultType: 'boolean', status: \\\"Definitely\\\", constType: \\\"Constant\\\"},\\n  \\\"Inverse\\\": {inputType: 'number', resultType: 'number', status: \\\"Variable\\\", constType: \\\"Constant\\\"},\\n  \\\"InputN\\\": {inputType: 'number', resultType: 'number', status: \\\"Maybe-Undefined\\\", constType: \\\"Non-Constant\\\"},\\n  \\\"Sink\\\": {inputType: 'any', resultType: 'any', status: \\\"Maybe-Undefined\\\", constType: \\\"Constant\\\"},\\n  \\\"ParseOrderedPair\\\": {inputType: 'number', resultType: 'pair', status: \\\"Variable\\\", constType: \\\"Constant\\\"},\\n  \\\"X\\\": {inputType: 'pair', resultType: 'number', status: \\\"Variable\\\", constType: \\\"Constant\\\"},\\n  \\\"Y\\\": {inputType: 'pair', resultType: 'number', status: \\\"Variable\\\", constType: \\\"Constant\\\"},\\n  \\\"Not\\\": {inputType: 'boolean', resultType: 'boolean', status: \\\"Definitely\\\", constType: \\\"Constant\\\"},\\n  \\\"InputB\\\": {inputType: 'boolean', resultType: 'boolean', status: \\\"Maybe-Undefined\\\", constType: \\\"Non-Constant\\\"},\\n  \\\"Sqrt\\\": {inputType: 'number', resultType: 'number', status: \\\"Variable\\\", constType: \\\"Constant\\\"}\\n}\\n\\nconst checkerMap: Partial<{[K in AST.NodeType]: TypeChecker}> = {\\n  'Number' : new CheckNumber(),\\n  'Boolean' : new CheckBoolean(),\\n  'BinaryOperation' : new CheckBinary(),\\n  'Function' : new CheckFunction(),\\n  'Choose': new CheckChoose(),\\n  'VariableAssignment': new CheckVariable(),\\n  'Identifier': new CheckIdentifier()\\n}\"]}"}