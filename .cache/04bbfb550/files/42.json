{"contents":"exports.__esModule = true;\nvar typechecker_1 = __fusereq(14);\nfunction findBases(node, dependsMap) {\n  return baseMap[node.nodeType].findBase(node, dependsMap);\n}\nexports.findBases = findBases;\nclass BaseNumber {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseBoolean {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseBinary {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    let leftList = findBases(node.left, dependsMap);\n    baseList = baseList.concat(leftList);\n    let rightList = findBases(node.right, dependsMap);\n    baseList = baseList.concat(rightList);\n    return baseList;\n  }\n}\nclass BaseFunction {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    if (node.outputType.status == 'Def-Undefined') {\n      baseList.push(node.nodeId);\n    } else if (typechecker_1.builtins[node.name].status == 'Variable') {\n      for (let i = 0; i < node.args.length; i++) {\n        baseList = baseList.concat(findBases(node.args[i], dependsMap));\n      }\n    } else if (typechecker_1.builtins[node.name].constType == 'Non-Constant') {\n      baseList.push(node.nodeId);\n    }\n    return baseList;\n  }\n}\nclass BaseChoose {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    let consBases = findBases(node.case.consequent, dependsMap);\n    baseList = baseList.concat(consBases);\n    let otherBases = findBases(node.otherwise, dependsMap);\n    baseList = baseList.concat(otherBases);\n    return baseList;\n  }\n}\nclass BaseVariableAssignment {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseIdentifier {\n  findBase(node, dependsMap) {\n    return dependsMap[node.assignmentId];\n  }\n}\nconst baseMap = {\n  'Number': new BaseNumber(),\n  'Boolean': new BaseBoolean(),\n  'BinaryOperation': new BaseBinary(),\n  'Function': new BaseFunction(),\n  'Choose': new BaseChoose(),\n  'VariableAssignment': new BaseVariableAssignment(),\n  'Identifier': new BaseIdentifier()\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/findBase.ts\"],\"names\":[\"node\",\"dependsMap\",\"baseMap\",\"nodeType\",\"findBase\",\"baseList\",\"leftList\",\"findBases\",\"left\",\"concat\",\"rightList\",\"right\",\"outputType\",\"status\",\"push\",\"nodeId\",\"typechecker_1\",\"name\",\"i\",\"args\",\"length\",\"constType\",\"consBases\",\"case\",\"consequent\",\"otherBases\",\"otherwise\",\"assignmentId\",\"BaseNumber\",\"BaseBoolean\",\"BaseBinary\",\"BaseFunction\",\"BaseChoose\",\"BaseVariableAssignment\",\"BaseIdentifier\"],\"mappings\":\";;AAGO,mBAAmBA,MAAgBC;SAC/BC,QAAQF,KAAKG,UAAUC,SAASJ,MAAMC;;;AAOjD;EACEG,SAASJ;;;;AAKX;EACII,SAASJ;;;;AAKb;EACII,SAASJ,MAA+BC;QAChCI;QAEAC,WAAWC,UAAUP,KAAKQ,MAAMP;IACpCI,WAAWA,SAASI,OAAOH;QACvBI,YAAYH,UAAUP,KAAKW,OAAOV;IACtCI,WAAWA,SAASI,OAAOC;WACpBL;;;AAMf;EACID,SAASJ,MAAwBC;QACzBI;QAKAL,KAAKY,WAAWC,UAAU;MAC1BR,SAASS,KAAKd,KAAKe;eACZC,uBAAShB,KAAKiB,MAAMJ,UAAU;eAE5BK,IAAI,GAAGA,IAAIlB,KAAKmB,KAAKC,QAAQF;QAClCb,WAAWA,SAASI,OAAOF,UAAUP,KAAKmB,KAAKD,IAAIjB;;eAEhDe,uBAAShB,KAAKiB,MAAMI,aAAa;MAExChB,SAASS,KAAKd,KAAKe;;WAGhBV;;;AAMf;EACID,SAASJ,MAAsBC;QACvBI;QAEAiB,YAAYf,UAAUP,KAAKuB,KAAKC,YAAYvB;IAChDI,WAAWA,SAASI,OAAOa;QACvBG,aAAalB,UAAUP,KAAK0B,WAAWzB;IAC3CI,WAAWA,SAASI,OAAOgB;WACpBpB;;;AAIf;EACID,SAASJ;;;;AAKb;EACII,SAASJ,MAA0BC;WAExBA,WAAWD,KAAK2B;;;MAKzBzB;EACJ,cAAe0B;EACf,eAAgBC;EAChB,uBAAwBC;EACxB,gBAAiBC;EACjB,cAAcC;EACd,0BAA0BC;EAC1B,kBAAkBC\",\"sourcesContent\":[\"import * as AST from './ast';\\nimport {builtins} from './typechecker';\\n\\nexport function findBases(node: AST.Node, dependsMap: {[key: string]: string[]}): string[] {\\n    return baseMap[node.nodeType].findBase(node, dependsMap); \\n}\\n\\nexport interface BaseFinder {\\n  findBase(node: AST.Node, dependsMap: {[key: string]: string[]}): string[];\\n}\\n\\nclass BaseNumber implements BaseFinder {\\n  findBase(node: AST.NumberNode): string[] {\\n    return []\\n  }\\n}\\n\\nclass BaseBoolean implements BaseFinder {\\n    findBase(node: AST.BooleanNode): string[] {\\n        return []\\n    }\\n}\\n\\nclass BaseBinary implements BaseFinder {\\n    findBase(node: AST.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n        // recursively call findBases on left and right\\n        let leftList = findBases(node.left, dependsMap);\\n        baseList = baseList.concat(leftList);\\n        let rightList = findBases(node.right, dependsMap)\\n        baseList = baseList.concat(rightList);\\n        return baseList;\\n    }\\n}\\n\\n// examples: x = Input(3); x = IsDefined(Input(3)); z = Inverse(x)\\n// need dependsMap for the third example\\nclass BaseFunction implements BaseFinder {\\n    findBase(node: AST.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n        \\n        // If the builtin status IS a variable, then it does depend on its arguments\\n        // Unlike for Definitely and Maybe-Undefined functions, which status is the same always\\n\\n        if (node.outputType.status == 'Def-Undefined') {\\n            baseList.push(node.nodeId);\\n        } else if (builtins[node.name].status == 'Variable') {\\n            // recursively call findBases on argument(s)\\n            for (let i = 0; i < node.args.length; i++) {\\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\\n            }\\n        } else if (builtins[node.name].constType == 'Non-Constant') {\\n            // If Maybe-Undefined funtion, it IS a base (the root of a maybe-undefined status)\\n            baseList.push(node.nodeId);\\n        }\\n\\n        return baseList;\\n    }\\n}\\n\\n// assume that choose nodes will never create their own bases\\n// they can still error check previously defined bases\\nclass BaseChoose implements BaseFinder {\\n    findBase(node: AST.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n        // the bases of the cons and the otherwise\\n        letÂ consBases = findBases(node.case.consequent, dependsMap);\\n        baseList = baseList.concat(consBases);\\n        let otherBases = findBases(node.otherwise, dependsMap);\\n        baseList = baseList.concat(otherBases);\\n        return baseList;\\n    }\\n}\\n\\nclass BaseVariableAssignment implements BaseFinder {\\n    findBase(node: AST.VariableAssignmentNode): string[] {\\n        return []\\n    }\\n}\\n\\nclass BaseIdentifier implements BaseFinder {\\n    findBase(node: AST.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\\n        // follow the chain in the dependsMap\\n        return dependsMap[node.assignmentId];\\n    }\\n}\\n\\n\\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\\n  'Number' : new BaseNumber(),\\n  'Boolean' : new BaseBoolean(),\\n  'BinaryOperation' : new BaseBinary(),\\n  'Function' : new BaseFunction(),\\n  'Choose': new BaseChoose(),\\n  'VariableAssignment': new BaseVariableAssignment(),\\n  'Identifier': new BaseIdentifier()\\n}\"]}"}