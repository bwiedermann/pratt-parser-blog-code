{"contents":"exports.__esModule = true;\nvar typechecker_1 = __fusereq(14);\nfunction findBases(node, dependsMap) {\n  return baseMap[node.nodeType].findBase(node, dependsMap);\n}\nexports.findBases = findBases;\nclass BaseNumber {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseBoolean {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseBinary {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    let leftList = findBases(node.left, dependsMap);\n    baseList = baseList.concat(leftList);\n    let rightList = findBases(node.right, dependsMap);\n    baseList = baseList.concat(rightList);\n    return baseList;\n  }\n}\nclass BaseFunction {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    if (node.outputType.status == 'Def-Undefined') {\n      baseList.push(node.nodeId);\n    } else if (typechecker_1.builtins[node.name].status == 'Variable') {\n      for (let i = 0; i < node.args.length; i++) {\n        baseList = baseList.concat(findBases(node.args[i], dependsMap));\n      }\n    } else if (typechecker_1.builtins[node.name].constType == 'Non-Constant') {\n      baseList.push(node.nodeId);\n    }\n    return baseList;\n  }\n}\nclass BaseChoose {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    let consBases = findBases(node.case.consequent, dependsMap);\n    baseList = baseList.concat(consBases);\n    let otherBases = findBases(node.otherwise, dependsMap);\n    baseList = baseList.concat(otherBases);\n    return baseList;\n  }\n}\nclass BaseVariableAssignment {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseIdentifier {\n  findBase(node, dependsMap) {\n    return dependsMap[node.assignmentId];\n  }\n}\nconst baseMap = {\n  'Number': new BaseNumber(),\n  'Boolean': new BaseBoolean(),\n  'BinaryOperation': new BaseBinary(),\n  'Function': new BaseFunction(),\n  'Choose': new BaseChoose(),\n  'VariableAssignment': new BaseVariableAssignment(),\n  'Identifier': new BaseIdentifier()\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/findBase.ts\"],\"names\":[\"node\",\"dependsMap\",\"baseMap\",\"nodeType\",\"findBase\",\"baseList\",\"leftList\",\"findBases\",\"left\",\"concat\",\"rightList\",\"right\",\"outputType\",\"status\",\"push\",\"nodeId\",\"typechecker_1\",\"name\",\"i\",\"args\",\"length\",\"constType\",\"consBases\",\"case\",\"consequent\",\"otherBases\",\"otherwise\",\"assignmentId\",\"BaseNumber\",\"BaseBoolean\",\"BaseBinary\",\"BaseFunction\",\"BaseChoose\",\"BaseVariableAssignment\",\"BaseIdentifier\"],\"mappings\":\";;AAYO,mBAAmBA,MAAgBC;SAC/BC,QAAQF,KAAKG,UAAUC,SAASJ,MAAMC;;;AAQjD;EACEG,SAASJ;;;;AAMX;EACII,SAASJ;;;;AAMb;EACII,SAASJ,MAA+BC;QAChCI;QAEAC,WAAWC,UAAUP,KAAKQ,MAAMP;IACpCI,WAAWA,SAASI,OAAOH;QACvBI,YAAYH,UAAUP,KAAKW,OAAOV;IAEtCI,WAAWA,SAASI,OAAOC;WACpBL;;;AAQf;EACID,SAASJ,MAAwBC;QACzBI;QAEAL,KAAKY,WAAWC,UAAU;MAE1BR,SAASS,KAAKd,KAAKe;eACZC,uBAAShB,KAAKiB,MAAMJ,UAAU;eAE5BK,IAAI,GAAGA,IAAIlB,KAAKmB,KAAKC,QAAQF;QAClCb,WAAWA,SAASI,OAAOF,UAAUP,KAAKmB,KAAKD,IAAIjB;;eAEhDe,uBAAShB,KAAKiB,MAAMI,aAAa;MAExChB,SAASS,KAAKd,KAAKe;;WAGhBV;;;AAKf;EACID,SAASJ,MAAsBC;QACvBI;QAEAiB,YAAYf,UAAUP,KAAKuB,KAAKC,YAAYvB;IAChDI,WAAWA,SAASI,OAAOa;QAEvBG,aAAalB,UAAUP,KAAK0B,WAAWzB;IAC3CI,WAAWA,SAASI,OAAOgB;WAEpBpB;;;AAKf;EACID,SAASJ;;;;AAOb;EACII,SAASJ,MAA0BC;WAExBA,WAAWD,KAAK2B;;;MAIzBzB;EACJ,cAAe0B;EACf,eAAgBC;EAChB,uBAAwBC;EACxB,gBAAiBC;EACjB,cAAcC;EACd,0BAA0BC;EAC1B,kBAAkBC\",\"sourcesContent\":[\"import * as AST from './ast';\\nimport {builtins} from './typechecker';\\n\\n/*\\n    The findBases function, given an AST node and the current dependsMap, determines\\n    the \\\"bases\\\" of that node and returns them in a list of nodeIds.\\n\\n    Bases are nodes that introduce the possibility of being undefined.\\n    For example, the InputN() function represents student input, and therefore\\n    introduces the possibility to be undefined.\\n*/\\n\\nexport function findBases(node: AST.Node, dependsMap: {[key: string]: string[]}): string[] {\\n    return baseMap[node.nodeType].findBase(node, dependsMap); \\n}\\n\\nexport interface BaseFinder {\\n  findBase(node: AST.Node, dependsMap: {[key: string]: string[]}): string[];\\n}\\n\\n// Numbers are constant, and therefore cannot have bases\\nclass BaseNumber implements BaseFinder {\\n  findBase(node: AST.NumberNode): string[] {\\n    return []\\n  }\\n}\\n\\n// Booleans are constant, and therefore cannot have bases\\nclass BaseBoolean implements BaseFinder {\\n    findBase(node: AST.BooleanNode): string[] {\\n        return []\\n    }\\n}\\n\\n// Binary operations could have bases on either side of their operator\\nclass BaseBinary implements BaseFinder {\\n    findBase(node: AST.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n        // recursively call findBases on left and right\\n        let leftList = findBases(node.left, dependsMap);\\n        baseList = baseList.concat(leftList);\\n        let rightList = findBases(node.right, dependsMap)\\n        // combine bases from left and right\\n        baseList = baseList.concat(rightList);\\n        return baseList;\\n    }\\n}\\n\\n// In this proof of concept, functions are the only bases\\n// They can produce an undefined value (e.g. Inverse(0)) or are inherently non-constant (e.g. InputN)\\n// Otherwise, the base of the function is determined by its argument(s)\\n// This means that the base is the id of the function node itself\\nclass BaseFunction implements BaseFinder {\\n    findBase(node: AST.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n\\n        if (node.outputType.status == 'Def-Undefined') {\\n            // e.g. with Inverse(0)\\n            baseList.push(node.nodeId);\\n        } else if (builtins[node.name].status == 'Variable') {\\n            // recursively call findBases on argument(s)\\n            for (let i = 0; i < node.args.length; i++) {\\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\\n            }\\n        } else if (builtins[node.name].constType == 'Non-Constant') {\\n            // e.g. with InputN(2)\\n            baseList.push(node.nodeId);\\n        }\\n\\n        return baseList;\\n    }\\n}\\n\\n// The bases of choose nodes are determined by the bases of their consequent and their otherwise\\nclass BaseChoose implements BaseFinder {\\n    findBase(node: AST.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n \\n        letÂ consBases = findBases(node.case.consequent, dependsMap);\\n        baseList = baseList.concat(consBases);\\n\\n        let otherBases = findBases(node.otherwise, dependsMap);\\n        baseList = baseList.concat(otherBases);\\n\\n        return baseList;\\n    }\\n}\\n\\n// Variable assignments are constant, and therefore cannot have bases\\nclass BaseVariableAssignment implements BaseFinder {\\n    findBase(node: AST.VariableAssignmentNode): string[] {\\n        return []\\n    }\\n}\\n\\n// The bases of an identifier are stored in the dependsMap, which has a reference\\n// to its assignment.\\nclass BaseIdentifier implements BaseFinder {\\n    findBase(node: AST.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\\n        // follow the chain in the dependsMap\\n        return dependsMap[node.assignmentId];\\n    }\\n}\\n\\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\\n  'Number' : new BaseNumber(),\\n  'Boolean' : new BaseBoolean(),\\n  'BinaryOperation' : new BaseBinary(),\\n  'Function' : new BaseFunction(),\\n  'Choose': new BaseChoose(),\\n  'VariableAssignment': new BaseVariableAssignment(),\\n  'Identifier': new BaseIdentifier()\\n}\"]}"}