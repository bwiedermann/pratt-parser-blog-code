{"contents":"function findBases(node, dependsMap) {\n  return baseMap[node.nodeType].findBase(node, dependsMap);\n}\nexports.findBases = findBases;\nclass BaseNumber {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseBoolean {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseBinary {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    let leftList = findBases(node.left, dependsMap);\n    baseList = baseList.concat(leftList);\n    let rightList = findBases(node.right, dependsMap);\n    baseList = baseList.concat(rightList);\n    return baseList;\n  }\n}\nclass BaseFunction {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    if (node.outputType.status == 'Def-Undefined') {\n      baseList.push(node.nodeId);\n    } else if (builtins[node.name].status == 'Variable') {\n      for (let i = 0; i < node.args.length; i++) {\n        baseList = baseList.concat(findBases(node.args[i], dependsMap));\n      }\n    } else if (builtins[node.name].constType == 'Non-Constant') {\n      baseList.push(node.nodeId);\n    }\n    return baseList;\n  }\n}\nclass BaseChoose {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    let consBases = findBases(node.case.consequent, dependsMap);\n    baseList = baseList.concat(consBases);\n    let otherBases = findBases(node.otherwise, dependsMap);\n    baseList = baseList.concat(otherBases);\n    return baseList;\n  }\n}\nclass BaseVariableAssignment {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseIdentifier {\n  findBase(node, dependsMap) {\n    return dependsMap[node.assignmentId];\n  }\n}\nconst baseMap = {\n  'Number': new BaseNumber(),\n  'Boolean': new BaseBoolean(),\n  'BinaryOperation': new BaseBinary(),\n  'Function': new BaseFunction(),\n  'Choose': new BaseChoose(),\n  'VariableAssignment': new BaseVariableAssignment(),\n  'Identifier': new BaseIdentifier()\n};\nconst builtins = {\n  \"IsDefined\": {\n    inputType: 'any',\n    resultType: 'boolean',\n    status: \"Definitely\",\n    constType: \"Constant\"\n  },\n  \"Inverse\": {\n    inputType: 'number',\n    resultType: 'number',\n    status: \"Variable\",\n    constType: \"Constant\"\n  },\n  \"InputN\": {\n    inputType: 'number',\n    resultType: 'number',\n    status: \"Maybe-Undefined\",\n    constType: \"Non-Constant\"\n  },\n  \"Sink\": {\n    inputType: 'any',\n    resultType: 'any',\n    status: \"Variable\",\n    constType: \"Constant\"\n  },\n  \"ParseOrderedPair\": {\n    inputType: 'number',\n    resultType: 'pair',\n    status: \"Variable\",\n    constType: \"Constant\"\n  },\n  \"X\": {\n    inputType: 'pair',\n    resultType: 'number',\n    status: \"Variable\",\n    constType: \"Constant\"\n  },\n  \"Y\": {\n    inputType: 'pair',\n    resultType: 'number',\n    status: \"Variable\",\n    constType: \"Constant\"\n  },\n  \"Not\": {\n    inputType: 'boolean',\n    resultType: 'boolean',\n    status: \"Definitely\",\n    constType: \"Constant\"\n  },\n  \"InputB\": {\n    inputType: 'boolean',\n    resultType: 'boolean',\n    status: \"Maybe-Undefined\",\n    constType: \"Non-Constant\"\n  },\n  \"Sqrt\": {\n    inputType: 'number',\n    resultType: 'number',\n    status: \"Variable\",\n    constType: \"Constant\"\n  }\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/findBase.ts\"],\"names\":[\"node\",\"dependsMap\",\"baseMap\",\"nodeType\",\"findBase\",\"baseList\",\"leftList\",\"findBases\",\"left\",\"concat\",\"rightList\",\"right\",\"outputType\",\"status\",\"push\",\"nodeId\",\"builtins\",\"name\",\"i\",\"args\",\"length\",\"constType\",\"consBases\",\"case\",\"consequent\",\"otherBases\",\"otherwise\",\"assignmentId\",\"BaseNumber\",\"BaseBoolean\",\"BaseBinary\",\"BaseFunction\",\"BaseChoose\",\"BaseVariableAssignment\",\"BaseIdentifier\",\"inputType\",\"resultType\"],\"mappings\":\"AAEO,mBAAmBA,MAAgBC;SAC/BC,QAAQF,KAAKG,UAAUC,SAASJ,MAAMC;;;AAOjD;EACEG,SAASJ;;;;AAKX;EACII,SAASJ;;;;AAKb;EACII,SAASJ,MAA+BC;QAChCI;QAEAC,WAAWC,UAAUP,KAAKQ,MAAMP;IACpCI,WAAWA,SAASI,OAAOH;QACvBI,YAAYH,UAAUP,KAAKW,OAAOV;IACtCI,WAAWA,SAASI,OAAOC;WACpBL;;;AAMf;EACID,SAASJ,MAAwBC;QACzBI;QAKAL,KAAKY,WAAWC,UAAU;MAC1BR,SAASS,KAAKd,KAAKe;eACZC,SAAShB,KAAKiB,MAAMJ,UAAU;eAE5BK,IAAI,GAAGA,IAAIlB,KAAKmB,KAAKC,QAAQF;QAClCb,WAAWA,SAASI,OAAOF,UAAUP,KAAKmB,KAAKD,IAAIjB;;eAEhDe,SAAShB,KAAKiB,MAAMI,aAAa;MAExChB,SAASS,KAAKd,KAAKe;;WAGhBV;;;AAMf;EACID,SAASJ,MAAsBC;QACvBI;QAEAiB,YAAYf,UAAUP,KAAKuB,KAAKC,YAAYvB;IAChDI,WAAWA,SAASI,OAAOa;QACvBG,aAAalB,UAAUP,KAAK0B,WAAWzB;IAC3CI,WAAWA,SAASI,OAAOgB;WACpBpB;;;AAIf;EACID,SAASJ;;;;AAKb;EACII,SAASJ,MAA0BC;WAExBA,WAAWD,KAAK2B;;;MAKzBzB;EACJ,cAAe0B;EACf,eAAgBC;EAChB,uBAAwBC;EACxB,gBAAiBC;EACjB,cAAcC;EACd,0BAA0BC;EAC1B,kBAAkBC;;MAGdlB;EACF;IAAcmB,WAAW;IAAOC,YAAY;IAAWvB,QAAQ;IAAcQ,WAAW;;EACxF;IAAYc,WAAW;IAAUC,YAAY;IAAUvB,QAAQ;IAAYQ,WAAW;;EACtF;IAAWc,WAAW;IAAUC,YAAY;IAAUvB,QAAQ;IAAmBQ,WAAW;;EAC5F;IAASc,WAAW;IAAOC,YAAY;IAAOvB,QAAQ;IAAYQ,WAAW;;EAE7E;IAAqBc,WAAW;IAAUC,YAAY;IAAQvB,QAAQ;IAAYQ,WAAW;;EAC7F;IAAMc,WAAW;IAAQC,YAAY;IAAUvB,QAAQ;IAAYQ,WAAW;;EAC9E;IAAMc,WAAW;IAAQC,YAAY;IAAUvB,QAAQ;IAAYQ,WAAW;;EAC9E;IAAQc,WAAW;IAAWC,YAAY;IAAWvB,QAAQ;IAAcQ,WAAW;;EACtF;IAAWc,WAAW;IAAWC,YAAY;IAAWvB,QAAQ;IAAmBQ,WAAW;;EAC9F;IAASc,WAAW;IAAUC,YAAY;IAAUvB,QAAQ;IAAYQ,WAAW\",\"sourcesContent\":[\"import * as AST from './ast';\\n\\nexport function findBases(node: AST.Node, dependsMap: {[key: string]: string[]}): string[] {\\n    return baseMap[node.nodeType].findBase(node, dependsMap); \\n}\\n\\nexport interface BaseFinder {\\n  findBase(node: AST.Node, dependsMap: {[key: string]: string[]}): string[];\\n}\\n\\nclass BaseNumber implements BaseFinder {\\n  findBase(node: AST.NumberNode): string[] {\\n    return []\\n  }\\n}\\n\\nclass BaseBoolean implements BaseFinder {\\n    findBase(node: AST.BooleanNode): string[] {\\n        return []\\n    }\\n}\\n\\nclass BaseBinary implements BaseFinder {\\n    findBase(node: AST.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n        // recursively call findBases on left and right\\n        let leftList = findBases(node.left, dependsMap);\\n        baseList = baseList.concat(leftList);\\n        let rightList = findBases(node.right, dependsMap)\\n        baseList = baseList.concat(rightList);\\n        return baseList;\\n    }\\n}\\n\\n// examples: x = Input(3); x = IsDefined(Input(3)); z = Inverse(x)\\n// need dependsMap for the third example\\nclass BaseFunction implements BaseFinder {\\n    findBase(node: AST.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n        \\n        // If the builtin status IS a variable, then it does depend on its arguments\\n        // Unlike for Definitely and Maybe-Undefined functions, which status is the same always\\n\\n        if (node.outputType.status == 'Def-Undefined') {\\n            baseList.push(node.nodeId);\\n        } else if (builtins[node.name].status == 'Variable') {\\n            // recursively call findBases on argument(s)\\n            for (let i = 0; i < node.args.length; i++) {\\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\\n            }\\n        } else if (builtins[node.name].constType == 'Non-Constant') {\\n            // If Maybe-Undefined funtion, it IS a base (the root of a maybe-undefined status)\\n            baseList.push(node.nodeId);\\n        }\\n\\n        return baseList;\\n    }\\n}\\n\\n// assume that choose nodes will never create their own bases\\n// they can still error check previously defined bases\\nclass BaseChoose implements BaseFinder {\\n    findBase(node: AST.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n        // the bases of the cons and the otherwise\\n        letÂ consBases = findBases(node.case.consequent, dependsMap);\\n        baseList = baseList.concat(consBases);\\n        let otherBases = findBases(node.otherwise, dependsMap);\\n        baseList = baseList.concat(otherBases);\\n        return baseList;\\n    }\\n}\\n\\nclass BaseVariableAssignment implements BaseFinder {\\n    findBase(node: AST.VariableAssignmentNode): string[] {\\n        return []\\n    }\\n}\\n\\nclass BaseIdentifier implements BaseFinder {\\n    findBase(node: AST.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\\n        // follow the chain in the dependsMap\\n        return dependsMap[node.assignmentId];\\n    }\\n}\\n\\n\\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\\n  'Number' : new BaseNumber(),\\n  'Boolean' : new BaseBoolean(),\\n  'BinaryOperation' : new BaseBinary(),\\n  'Function' : new BaseFunction(),\\n  'Choose': new BaseChoose(),\\n  'VariableAssignment': new BaseVariableAssignment(),\\n  'Identifier': new BaseIdentifier()\\n}\\n\\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType, status: string, constType: string} } = {\\n    \\\"IsDefined\\\": {inputType: 'any', resultType: 'boolean', status: \\\"Definitely\\\", constType: \\\"Constant\\\"},\\n    \\\"Inverse\\\": {inputType: 'number', resultType: 'number', status: \\\"Variable\\\", constType: \\\"Constant\\\"},\\n    \\\"InputN\\\": {inputType: 'number', resultType: 'number', status: \\\"Maybe-Undefined\\\", constType: \\\"Non-Constant\\\"},\\n    \\\"Sink\\\": {inputType: 'any', resultType: 'any', status: \\\"Variable\\\", constType: \\\"Constant\\\"},\\n    // change ParseOrderedPair to be Variable to show constant type stuff\\n    \\\"ParseOrderedPair\\\": {inputType: 'number', resultType: 'pair', status: \\\"Variable\\\", constType: \\\"Constant\\\"},\\n    \\\"X\\\": {inputType: 'pair', resultType: 'number', status: \\\"Variable\\\", constType: \\\"Constant\\\"},\\n    \\\"Y\\\": {inputType: 'pair', resultType: 'number', status: \\\"Variable\\\", constType: \\\"Constant\\\"},\\n    \\\"Not\\\": {inputType: 'boolean', resultType: 'boolean', status: \\\"Definitely\\\", constType: \\\"Constant\\\"},\\n    \\\"InputB\\\": {inputType: 'boolean', resultType: 'boolean', status: \\\"Maybe-Undefined\\\", constType: \\\"Non-Constant\\\"},\\n    \\\"Sqrt\\\": {inputType: 'number', resultType: 'number', status: \\\"Variable\\\", constType: \\\"Constant\\\"}\\n  }\\n\"]}"}