{"contents":"function findBases(node, dependsMap) {\n  return baseMap[node.nodeType].findBase(node, dependsMap);\n}\nexports.findBases = findBases;\nclass BaseNumber {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseBoolean {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseBinary {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    let leftList = findBases(node.left, dependsMap);\n    baseList = baseList.concat(leftList);\n    let rightList = findBases(node.right, dependsMap);\n    baseList = baseList.concat(rightList);\n    return baseList;\n  }\n}\nclass BaseFunction {\n  findBase(node, dependsMap) {\n    console.log(\"in base function\");\n    let baseList = [];\n    if (node.name == \"Input\") {\n      baseList.push(node.nodeId);\n    } else {\n      for (let i = 0; i < node.args.length; i++) {\n        baseList = baseList.concat(findBases(node.args[i], dependsMap));\n      }\n    }\n    return baseList;\n  }\n}\nclass BaseChoose {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    let consBases = findBases(node.case.consequent, dependsMap);\n    baseList = baseList.concat(consBases);\n    let otherBases = findBases(node.otherwise, dependsMap);\n    baseList = baseList.concat(otherBases);\n    return baseList;\n  }\n}\nclass BaseVariableAssignment {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseIdentifier {\n  findBase(node, dependsMap) {\n    return dependsMap[node.assignmentId];\n  }\n}\nconst baseMap = {\n  'Number': new BaseNumber(),\n  'Boolean': new BaseBoolean(),\n  'BinaryOperation': new BaseBinary(),\n  'Function': new BaseFunction(),\n  'Choose': new BaseChoose(),\n  'VariableAssignment': new BaseVariableAssignment(),\n  'Identifier': new BaseIdentifier()\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/findBase.ts\"],\"names\":[\"node\",\"dependsMap\",\"baseMap\",\"nodeType\",\"findBase\",\"baseList\",\"leftList\",\"findBases\",\"left\",\"concat\",\"rightList\",\"right\",\"console\",\"log\",\"name\",\"push\",\"nodeId\",\"i\",\"args\",\"length\",\"consBases\",\"case\",\"consequent\",\"otherBases\",\"otherwise\",\"assignmentId\",\"BaseNumber\",\"BaseBoolean\",\"BaseBinary\",\"BaseFunction\",\"BaseChoose\",\"BaseVariableAssignment\",\"BaseIdentifier\"],\"mappings\":\"AAEO,mBAAmBA,MAAgBC;SAC/BC,QAAQF,KAAKG,UAAUC,SAASJ,MAAMC;;;AAOjD;EACEG,SAASJ;;;;AAKX;EACII,SAASJ;;;;AAKb;EACII,SAASJ,MAA+BC;QAChCI;QAEAC,WAAWC,UAAUP,KAAKQ,MAAMP;IACpCI,WAAWA,SAASI,OAAOH;QACvBI,YAAYH,UAAUP,KAAKW,OAAOV;IACtCI,WAAWA,SAASI,OAAOC;WACpBL;;;AAMf;EACID,SAASJ,MAAwBC;IAC7BW,QAAQC,IAAI;QACRR;QACAL,KAAKc,QAAQ;MAEbT,SAASU,KAAKf,KAAKgB;;eAIVC,IAAI,GAAGA,IAAIjB,KAAKkB,KAAKC,QAAQF;QAClCZ,WAAWA,SAASI,OAAOF,UAAUP,KAAKkB,KAAKD,IAAIhB;;;WAGpDI;;;AAMf;EACID,SAASJ,MAAsBC;QACvBI;QAEAe,YAAYb,UAAUP,KAAKqB,KAAKC,YAAYrB;IAChDI,WAAWA,SAASI,OAAOW;QACvBG,aAAahB,UAAUP,KAAKwB,WAAWvB;IAC3CI,WAAWA,SAASI,OAAOc;WACpBlB;;;AAIf;EACID,SAASJ;;;;AAKb;EACII,SAASJ,MAA0BC;WAExBA,WAAWD,KAAKyB;;;MAKzBvB;EACJ,cAAewB;EACf,eAAgBC;EAChB,uBAAwBC;EACxB,gBAAiBC;EACjB,cAAcC;EACd,0BAA0BC;EAC1B,kBAAkBC\",\"sourcesContent\":[\"import * as AST from './ast';\\n\\nexport function findBases(node: AST.Node, dependsMap: {[key: string]: string[]}): string[] {\\n    return baseMap[node.nodeType].findBase(node, dependsMap); \\n}\\n\\nexport interface BaseFinder {\\n  findBase(node: AST.Node, dependsMap: {[key: string]: string[]}): string[];\\n}\\n\\nclass BaseNumber implements BaseFinder {\\n  findBase(node: AST.NumberNode): string[] {\\n    return []\\n  }\\n}\\n\\nclass BaseBoolean implements BaseFinder {\\n    findBase(node: AST.BooleanNode): string[] {\\n        return []\\n    }\\n}\\n\\nclass BaseBinary implements BaseFinder {\\n    findBase(node: AST.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n        // recursively call findBases on left and right\\n        let leftList = findBases(node.left, dependsMap);\\n        baseList = baseList.concat(leftList);\\n        let rightList = findBases(node.right, dependsMap)\\n        baseList = baseList.concat(rightList);\\n        return baseList;\\n    }\\n}\\n\\n// examples: x = Input(3); x = IsDefined(Input(3)); z = Inverse(x)\\n// need dependsMap for the third example\\nclass BaseFunction implements BaseFinder {\\n    findBase(node: AST.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\\n        console.log(\\\"in base function\\\");\\n        let baseList: string[] = [];\\n        if (node.name == \\\"Input\\\") {\\n            // this is a base\\n            baseList.push(node.nodeId);\\n        }\\n        else {\\n            // recursively call findBases on argument(s)\\n            for (let i = 0; i < node.args.length; i++) {\\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\\n            }\\n        }\\n        return baseList;\\n    }\\n}\\n\\n// assume that choose nodes will never create their own bases\\n// they can still error check previously defined bases\\nclass BaseChoose implements BaseFinder {\\n    findBase(node: AST.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\\n        let baseList: string[] = [];\\n        // the bases of the cons and the otherwise\\n        letÂ consBases = findBases(node.case.consequent, dependsMap);\\n        baseList = baseList.concat(consBases);\\n        let otherBases = findBases(node.otherwise, dependsMap);\\n        baseList = baseList.concat(otherBases);\\n        return baseList;\\n    }\\n}\\n\\nclass BaseVariableAssignment implements BaseFinder {\\n    findBase(node: AST.VariableAssignmentNode): string[] {\\n        return []\\n    }\\n}\\n\\nclass BaseIdentifier implements BaseFinder {\\n    findBase(node: AST.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\\n        // follow the chain in the dependsMap\\n        return dependsMap[node.assignmentId];\\n    }\\n}\\n\\n\\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\\n  'Number' : new BaseNumber(),\\n  'Boolean' : new BaseBoolean(),\\n  'BinaryOperation' : new BaseBinary(),\\n  'Function' : new BaseFunction(),\\n  'Choose': new BaseChoose(),\\n  'VariableAssignment': new BaseVariableAssignment(),\\n  'Identifier': new BaseIdentifier()\\n}\\n\"]}"}