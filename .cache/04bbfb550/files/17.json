{"contents":"exports.__esModule = true;\nvar parselet_1 = __fusereq(47);\nvar tokenstream_1 = __fusereq(48);\nvar position_1 = __fusereq(49);\nfunction parse(text, varMap) {\n  const nodes = [];\n  const tokens = new tokenstream_1.TokenStream(text);\n  const parser = new Parser();\n  while (tokens.peek()) {\n    try {\n      nodes.push(parser.parse(tokens, 0, varMap));\n    } catch (e) {\n      return {\n        nodes,\n        errors: [e]\n      };\n    }\n  }\n  return {\n    nodes,\n    errors: []\n  };\n}\nexports.parse = parse;\nclass AbstractParser {\n  constructor() {\n    this.bindingPowers = {};\n    const bindingClasses = this.bindingClasses();\n    for (let i = 0; i < bindingClasses.length; i++) {\n      for (const tokenType of bindingClasses[i]) {\n        this.bindingPowers[tokenType] = 10 * i + 9;\n      }\n    }\n    for (const tokenType of Object.keys(this.consequentMap)) {\n      if (this.bindingPowers[tokenType] == undefined) {\n        throw new Error(`Token ${tokenType} defined in consequentMap has no associated binding power.\n          Make sure it is also listed in bindingClasses.`);\n      }\n    }\n  }\n  bindingPower(token) {\n    if (this.bindingPowers[token.type] != undefined) {\n      return this.bindingPowers[token.type];\n    } else {\n      throw new position_1.ParseError(`Unexpected token type ${token.type}.`, position_1.token2pos(token));\n    }\n  }\n  parse(tokens, currentBindingPower, varMap) {\n    const token = tokens.consume();\n    if (!token) {\n      throw new position_1.ParseError(`Unexpected end of tokens.`, position_1.token2pos(tokens.last()));\n    }\n    const initialParselet = this.initialMap()[token.type];\n    if (!initialParselet) {\n      throw new position_1.ParseError(`Unexpected token type ${token.type}`, position_1.token2pos(token));\n    }\n    let left = initialParselet.parse(this, tokens, token, varMap);\n    while (true) {\n      const next = tokens.peek();\n      if (!next) {\n        break;\n      }\n      const consequentParselet = this.consequentMap()[next.type];\n      if (!consequentParselet) {\n        break;\n      }\n      if (currentBindingPower >= this.bindingPower(next)) {\n        break;\n      }\n      tokens.consume();\n      left = consequentParselet.parse(this, tokens, left, next, varMap);\n    }\n    return left;\n  }\n}\nexports.AbstractParser = AbstractParser;\nclass Parser extends AbstractParser {\n  initialMap() {\n    return {\n      NUMBER: new parselet_1.NumberParselet(),\n      TRUE: new parselet_1.BooleanParselet(true),\n      FALSE: new parselet_1.BooleanParselet(false),\n      '(': new parselet_1.ParenParselet(),\n      FUNCTION: new parselet_1.FunctionParselet(),\n      CHOOSE1: new parselet_1.ChooseParselet(),\n      IDENTIFIER: new parselet_1.IdentifierParselet()\n    };\n  }\n  consequentMap() {\n    return {\n      '+': new parselet_1.BinaryOperatorParselet('+', 'left'),\n      '-': new parselet_1.BinaryOperatorParselet('-', 'left'),\n      '*': new parselet_1.BinaryOperatorParselet('*', 'left'),\n      '/': new parselet_1.BinaryOperatorParselet('/', 'left'),\n      '|': new parselet_1.BinaryOperatorParselet('|', 'right'),\n      '&': new parselet_1.BinaryOperatorParselet('&', 'right')\n    };\n  }\n  bindingClasses() {\n    const classes = [['+', '-'], ['*', '/'], ['|', '&']];\n    return classes;\n  }\n}\nexports.Parser = Parser;\n","sourceMap":"{\"version\":3,\"sources\":[\"src/parser.ts\"],\"names\":[\"text\",\"varMap\",\"nodes\",\"tokens\",\"tokenstream_1\",\"parser\",\"Parser\",\"peek\",\"push\",\"parse\",\"e\",\"errors\",\"constructor\",\"bindingPowers\",\"bindingClasses\",\"i\",\"length\",\"tokenType\",\"Object\",\"keys\",\"consequentMap\",\"undefined\",\"Error\",\"bindingPower\",\"token\",\"type\",\"position_1\",\"currentBindingPower\",\"consume\",\"last\",\"initialParselet\",\"initialMap\",\"left\",\"next\",\"consequentParselet\",\"AbstractParser\",\"NUMBER\",\"NumberParselet\",\"TRUE\",\"BooleanParselet\",\"FALSE\",\"ParenParselet\",\"FUNCTION\",\"FunctionParselet\",\"CHOOSE1\",\"ChooseParselet\",\"IDENTIFIER\",\"IdentifierParselet\",\"BinaryOperatorParselet\",\"classes\"],\"mappings\":\";;;;AAMO,eAAeA,MACAC;QAEdC;QAEAC,aAAaC,0BAAYJ;QACzBK,aAAaC;SACZH,OAAOI;;MAEVL,MAAMM,KAAKH,OAAOI,MAAMN,QAAQ,GAAGF;aAC5BS;;QAELR;QACAS,SAASD;;;;;IAKPR;IAAOS;;;;AAGV;EAWLC;IACE,KAAKC;UAECC,iBAAiB,KAAKA;aACnBC,IAAI,GAAGA,IAAID,eAAeE,QAAQD;iBAC9BE,aAAaH,eAAeC;QACrC,KAAKF,cAAcI,aAAa,KAAKF,IAAI;;;eAIlCE,aAAaC,OAAOC,KAAK,KAAKC;UACnC,KAAKP,cAAcI,cAAcI;kBACzBC,eACCL;;;;;EAOjBM,aAAaC;QACP,KAAKX,cAAcW,MAAMC,SAASJ;aAC7B,KAAKR,cAAcW,MAAMC;;gBAEtBC,+CACiBF,MAAMC,SAC/BC,qBAAUF;;;EAKhBf,MAAMN,QACAwB,qBACA1B;UACEuB,QAAQrB,OAAOyB;SAChBJ;gBACOE,mDAERA,qBAAUvB,OAAO0B;;UAIfC,kBAAkB,KAAKC,aAAaP,MAAMC;SAE3CK;gBACOJ,+CACiBF,MAAMC,QAC/BC,qBAAUF;;QAIVQ,OAAOF,gBAAgBrB,MAAM,MAAMN,QAAQqB,OAAOvB;WAE/C;YACCgC,OAAO9B,OAAOI;WACf0B;;;YAICC,qBAAqB,KAAKd,gBAAgBa,KAAKR;WAEhDS;;;UAIDP,uBAAuB,KAAKJ,aAAaU;;;MAI7C9B,OAAOyB;MACPI,OAAOE,mBAAmBzB,MAAM,MAAMN,QAAQ6B,MAAMC,MAAMhC;;WAGrD+B;;;;AAIJ,qBAAqBG;EAC1BJ;;MAEIK,uBAAqBC;MACrBC,qBAAmBC,gBAAgB;MACnCC,sBAAoBD,gBAAgB;MACpC,oBAAkBE;MAClBC,yBAAuBC;MACvBC,wBAAsBC;MACtBC,2BAAyBC;;;EAI7B3B;;MAEI,oBAAkB4B,uBAAuB,KAAK;MAC9C,oBAAkBA,uBAAuB,KAAK;MAC9C,oBAAkBA,uBAAuB,KAAK;MAC9C,oBAAkBA,uBAAuB,KAAK;MAC9C,oBAAkBA,uBAAuB,KAAK;MAC9C,oBAAkBA,uBAAuB,KAAK;;;EAIlDlC;UACQmC,YAA2B,KAAK,OAAO,KAAK,OAAO,KAAK;WACvDA\",\"sourcesContent\":[\"import * as Parselet from './parselet';\\nimport {Token, TokenType} from './lexer';\\nimport {TokenStream} from './tokenstream';\\nimport {ParseError, token2pos} from './position';\\nimport * as AST from './ast';\\n\\nexport function parse(text: string,\\n                      varMap: {[key: string]: string}): \\n                      {nodes: AST.Node[]; errors: ParseError[]} {\\n  const nodes: AST.Node[] = [];\\n\\n  const tokens = new TokenStream(text);\\n  const parser = new Parser();\\n  while (tokens.peek()) {\\n    try {\\n      nodes.push(parser.parse(tokens, 0, varMap));\\n    } catch (e) {\\n      return {\\n        nodes,\\n        errors: [e],\\n      };\\n    }\\n  }\\n\\n  return {nodes, errors: []};\\n}\\n\\nexport abstract class AbstractParser {\\n  public bindingPowers: {[tokenType in TokenType]: number};\\n\\n  protected abstract initialMap(): Partial<\\n    {[K in TokenType]: Parselet.InitialParselet}\\n  >;\\n  protected abstract consequentMap(): Partial<\\n    {[K in TokenType]: Parselet.ConsequentParselet}\\n  >;\\n  protected abstract bindingClasses(): TokenType[][];\\n\\n  constructor() {\\n    this.bindingPowers = {} as any;\\n\\n    const bindingClasses = this.bindingClasses();\\n    for (let i = 0; i < bindingClasses.length; i++) {\\n      for (const tokenType of bindingClasses[i]) {\\n        this.bindingPowers[tokenType] = 10 * i + 9;\\n      }\\n    }\\n\\n    for (const tokenType of Object.keys(this.consequentMap) as TokenType[]) {\\n      if (this.bindingPowers[tokenType] == undefined) {\\n        throw new Error(\\n          `Token ${tokenType} defined in consequentMap has no associated binding power.\\n          Make sure it is also listed in bindingClasses.`,\\n        );\\n      }\\n    }\\n  }\\n\\n  bindingPower(token: Token): number {\\n    if (this.bindingPowers[token.type] != undefined) {\\n      return this.bindingPowers[token.type];\\n    } else {\\n      throw new ParseError(\\n        `Unexpected token type ${token.type}.`,\\n        token2pos(token),\\n      );\\n    }\\n  }\\n\\n  parse(tokens: TokenStream,\\n        currentBindingPower: number,\\n        varMap: {[key: string]: string}): AST.Node {\\n    const token = tokens.consume();\\n    if (!token) {\\n      throw new ParseError(\\n        `Unexpected end of tokens.`,\\n        token2pos(tokens.last()),\\n      );\\n    }\\n\\n    const initialParselet = this.initialMap()[token.type];\\n\\n    if (!initialParselet) {\\n      throw new ParseError(\\n        `Unexpected token type ${token.type}`,\\n        token2pos(token),\\n      );\\n    }\\n\\n    let left = initialParselet.parse(this, tokens, token, varMap);\\n\\n    while (true) {\\n      const next = tokens.peek();\\n      if (!next) {\\n        break;\\n      }\\n\\n      const consequentParselet = this.consequentMap()[next.type];\\n\\n      if (!consequentParselet) {\\n        break;\\n      }\\n\\n      if (currentBindingPower >= this.bindingPower(next)) {\\n        break;\\n      }\\n\\n      tokens.consume();\\n      left = consequentParselet.parse(this, tokens, left, next, varMap);\\n    }\\n\\n    return left;\\n  }\\n}\\n\\nexport class Parser extends AbstractParser {\\n  initialMap() {\\n    return {\\n      NUMBER: new Parselet.NumberParselet(),\\n      TRUE: new Parselet.BooleanParselet(true),\\n      FALSE: new Parselet.BooleanParselet(false),\\n      '(': new Parselet.ParenParselet(),\\n      FUNCTION: new Parselet.FunctionParselet(),\\n      CHOOSE1: new Parselet.ChooseParselet(),\\n      IDENTIFIER: new Parselet.IdentifierParselet()\\n    };\\n  }\\n\\n  consequentMap() {\\n    return {\\n      '+': new Parselet.BinaryOperatorParselet('+', 'left'),\\n      '-': new Parselet.BinaryOperatorParselet('-', 'left'),\\n      '*': new Parselet.BinaryOperatorParselet('*', 'left'),\\n      '/': new Parselet.BinaryOperatorParselet('/', 'left'),\\n      '|': new Parselet.BinaryOperatorParselet('|', 'right'),\\n      '&': new Parselet.BinaryOperatorParselet('&', 'right')\\n    };\\n  }\\n\\n  bindingClasses() {\\n    const classes: TokenType[][] = [['+', '-'], ['*', '/'], ['|', '&']];\\n    return classes;\\n  }\\n}\\n\"]}"}