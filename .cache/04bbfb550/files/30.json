{"contents":"exports.__esModule = true;\nvar lezer_tree_1 = __fusereq(34);\nvar style_mod_1 = __fusereq(40);\nvar view_1 = __fusereq(18);\nvar state_1 = __fusereq(16);\nvar language_1 = __fusereq(21);\nvar rangeset_1 = __fusereq(39);\nlet nextTagID = 0;\nclass Tag {\n  constructor(set, base, modified) {\n    this.set = set;\n    this.base = base;\n    this.modified = modified;\n    this.id = nextTagID++;\n  }\n  static define(parent) {\n    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n    let tag = new Tag([], null, []);\n    tag.set.push(tag);\n    if (parent) for (let t of parent.set) tag.set.push(t);\n    return tag;\n  }\n  static defineModifier() {\n    let mod = new Modifier();\n    return tag => {\n      if (tag.modified.indexOf(mod) > -1) return tag;\n      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n    };\n  }\n}\nlet nextModifierID = 0;\nclass Modifier {\n  constructor() {\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n  static get(base, mods) {\n    if (!mods.length) return base;\n    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n    if (exists) return exists;\n    let set = [], tag = new Tag(set, base, mods);\n    for (let m of mods) m.instances.push(tag);\n    let configs = permute(mods);\n    for (let parent of base.set) for (let config of configs) set.push(Modifier.get(parent, config));\n    return tag;\n  }\n}\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction permute(array) {\n  let result = [array];\n  for (let i = 0; i < array.length; i++) {\n    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1)))) result.push(a);\n  }\n  return result;\n}\nfunction styleTags(spec) {\n  let byName = Object.create(null);\n  for (let prop in spec) {\n    let tags = spec[prop];\n    if (!Array.isArray(tags)) tags = [tags];\n    for (let part of prop.split(\" \")) if (part) {\n      let pieces = [], mode = 2, rest = part;\n      for (let pos = 0; ; ) {\n        if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n          mode = 1;\n          break;\n        }\n        let m = (/^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/).exec(rest);\n        if (!m) throw new RangeError(\"Invalid path: \" + part);\n        pieces.push(m[0] == \"*\" ? null : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n        pos += m[0].length;\n        if (pos == part.length) break;\n        let next = part[pos++];\n        if (pos == part.length && next == \"!\") {\n          mode = 0;\n          break;\n        }\n        if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n        rest = part.slice(pos);\n      }\n      let last = pieces.length - 1, inner = pieces[last];\n      if (!inner) throw new RangeError(\"Invalid path: \" + part);\n      let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n      byName[inner] = rule.sort(byName[inner]);\n    }\n  }\n  return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new lezer_tree_1.NodeProp();\nconst highlightStyle = state_1.Facet.define({\n  combine(stylings) {\n    return stylings.length ? HighlightStyle.combinedMatch(stylings) : null;\n  }\n});\nconst fallbackHighlightStyle = state_1.Facet.define({\n  combine(values) {\n    return values.length ? values[0].match : null;\n  }\n});\nfunction noHighlight() {\n  return null;\n}\nfunction getHighlightStyle(state) {\n  return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle) || noHighlight;\n}\nclass Rule {\n  constructor(tags, mode, context, next) {\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n  sort(other) {\n    if (!other || other.depth < this.depth) {\n      this.next = other;\n      return this;\n    }\n    other.next = this.sort(other.next);\n    return other;\n  }\n  get depth() {\n    return this.context ? this.context.length : 0;\n  }\n}\nclass HighlightStyle {\n  constructor(spec, options) {\n    this.map = Object.create(null);\n    let modSpec;\n    function def(spec) {\n      let cls = style_mod_1.StyleModule.newName();\n      (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n      return cls;\n    }\n    this.all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : null;\n    for (let style of spec) {\n      let cls = (style.class || def(Object.assign({}, style, {\n        tag: null\n      }))) + (this.all ? \" \" + this.all : \"\");\n      let tags = style.tag;\n      if (!Array.isArray(tags)) this.map[tags.id] = cls; else for (let tag of tags) this.map[tag.id] = cls;\n    }\n    this.module = modSpec ? new style_mod_1.StyleModule(modSpec) : null;\n    this.scope = options.scope || null;\n    this.match = this.match.bind(this);\n    let ext = [treeHighlighter];\n    if (this.module) ext.push(view_1.EditorView.styleModule.of(this.module));\n    this.extension = ext.concat(highlightStyle.of(this));\n    this.fallback = ext.concat(fallbackHighlightStyle.of(this));\n  }\n  match(tag, scope) {\n    if (this.scope && scope != this.scope) return null;\n    for (let t of tag.set) {\n      let match = this.map[t.id];\n      if (match !== undefined) {\n        if (t != tag) this.map[tag.id] = match;\n        return match;\n      }\n    }\n    return this.map[tag.id] = this.all;\n  }\n  static combinedMatch(styles) {\n    if (styles.length == 1) return styles[0].match;\n    let cache = styles.some(s => s.scope) ? undefined : Object.create(null);\n    return (tag, scope) => {\n      let cached = cache && cache[tag.id];\n      if (cached !== undefined) return cached;\n      let result = null;\n      for (let style of styles) {\n        let value = style.match(tag, scope);\n        if (value) result = result ? result + \" \" + value : value;\n      }\n      if (cache) cache[tag.id] = result;\n      return result;\n    };\n  }\n  static define(specs, options) {\n    return new HighlightStyle(specs, options || ({}));\n  }\n  static get(state, tag, scope) {\n    return getHighlightStyle(state)(tag, scope || lezer_tree_1.NodeType.none);\n  }\n}\nfunction highlightTree(tree, getStyle, putStyle) {\n  highlightTreeRange(tree, 0, tree.length, getStyle, putStyle);\n}\nclass TreeHighlighter {\n  constructor(view) {\n    this.markCache = Object.create(null);\n    this.tree = language_1.syntaxTree(view.state);\n    this.decorations = this.buildDeco(view, getHighlightStyle(view.state));\n  }\n  update(update) {\n    let tree = language_1.syntaxTree(update.state), style = getHighlightStyle(update.state);\n    let styleChange = style != update.startState.facet(highlightStyle);\n    if (tree.length < update.view.viewport.to && !styleChange) {\n      this.decorations = this.decorations.map(update.changes);\n    } else if (tree != this.tree || update.viewportChanged || styleChange) {\n      this.tree = tree;\n      this.decorations = this.buildDeco(update.view, style);\n    }\n  }\n  buildDeco(view, match) {\n    if (match == noHighlight || !this.tree.length) return view_1.Decoration.none;\n    let builder = new rangeset_1.RangeSetBuilder();\n    for (let {from, to} of view.visibleRanges) {\n      highlightTreeRange(this.tree, from, to, match, (from, to, style) => {\n        builder.add(from, to, this.markCache[style] || (this.markCache[style] = view_1.Decoration.mark({\n          class: style\n        })));\n      });\n    }\n    return builder.finish();\n  }\n}\nconst treeHighlighter = state_1.Prec.fallback(view_1.ViewPlugin.fromClass(TreeHighlighter, {\n  decorations: v => v.decorations\n}));\nconst nodeStack = [\"\"];\nfunction highlightTreeRange(tree, from, to, style, span) {\n  let spanStart = from, spanClass = \"\";\n  let cursor = tree.topNode.cursor;\n  function node(inheritedClass, depth, scope) {\n    let {type, from: start, to: end} = cursor;\n    if (start >= to || end <= from) return;\n    nodeStack[depth] = type.name;\n    if (type.isTop) scope = type;\n    let cls = inheritedClass;\n    let rule = type.prop(ruleNodeProp), opaque = false;\n    while (rule) {\n      if (!rule.context || matchContext(rule.context, nodeStack, depth)) {\n        for (let tag of rule.tags) {\n          let st = style(tag, scope);\n          if (st) {\n            if (cls) cls += \" \";\n            cls += st;\n            if (rule.mode == 1) inheritedClass += (inheritedClass ? \" \" : \"\") + st; else if (rule.mode == 0) opaque = true;\n          }\n        }\n        break;\n      }\n      rule = rule.next;\n    }\n    if (cls != spanClass) {\n      if (start > spanStart && spanClass) span(spanStart, cursor.from, spanClass);\n      spanStart = start;\n      spanClass = cls;\n    }\n    if (!opaque && cursor.firstChild()) {\n      do {\n        let end = cursor.to;\n        node(inheritedClass, depth + 1, scope);\n        if (spanClass != cls) {\n          let pos = Math.min(to, end);\n          if (pos > spanStart && spanClass) span(spanStart, pos, spanClass);\n          spanStart = pos;\n          spanClass = cls;\n        }\n      } while (cursor.nextSibling());\n      cursor.parent();\n    }\n  }\n  node(\"\", 0, tree.type);\n}\nfunction matchContext(context, stack, depth) {\n  if (context.length > depth - 1) return false;\n  for (let d = depth - 1, i = context.length - 1; i >= 0; (i--, d--)) {\n    let check = context[i];\n    if (check && check != stack[d]) return false;\n  }\n  return true;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\nconst tags = {\n  comment,\n  lineComment: t(comment),\n  blockComment: t(comment),\n  docComment: t(comment),\n  name,\n  variableName: t(name),\n  typeName: typeName,\n  tagName: t(typeName),\n  propertyName: t(name),\n  className: t(name),\n  labelName: t(name),\n  namespace: t(name),\n  macroName: t(name),\n  literal,\n  string,\n  docString: t(string),\n  character: t(string),\n  number,\n  integer: t(number),\n  float: t(number),\n  bool: t(literal),\n  regexp: t(literal),\n  escape: t(literal),\n  color: t(literal),\n  url: t(literal),\n  keyword,\n  self: t(keyword),\n  null: t(keyword),\n  atom: t(keyword),\n  unit: t(keyword),\n  modifier: t(keyword),\n  operatorKeyword: t(keyword),\n  controlKeyword: t(keyword),\n  definitionKeyword: t(keyword),\n  operator,\n  derefOperator: t(operator),\n  arithmeticOperator: t(operator),\n  logicOperator: t(operator),\n  bitwiseOperator: t(operator),\n  compareOperator: t(operator),\n  updateOperator: t(operator),\n  definitionOperator: t(operator),\n  typeOperator: t(operator),\n  controlOperator: t(operator),\n  punctuation,\n  separator: t(punctuation),\n  bracket,\n  angleBracket: t(bracket),\n  squareBracket: t(bracket),\n  paren: t(bracket),\n  brace: t(bracket),\n  content,\n  heading,\n  heading1: t(heading),\n  heading2: t(heading),\n  heading3: t(heading),\n  heading4: t(heading),\n  heading5: t(heading),\n  heading6: t(heading),\n  contentSeparator: t(content),\n  list: t(content),\n  quote: t(content),\n  emphasis: t(content),\n  strong: t(content),\n  link: t(content),\n  monospace: t(content),\n  inserted: t(),\n  deleted: t(),\n  changed: t(),\n  invalid: t(),\n  meta,\n  documentMeta: t(meta),\n  annotation: t(meta),\n  processingInstruction: t(meta),\n  definition: Tag.defineModifier(),\n  constant: Tag.defineModifier(),\n  function: Tag.defineModifier(),\n  standard: Tag.defineModifier(),\n  local: Tag.defineModifier(),\n  special: Tag.defineModifier()\n};\nconst defaultHighlightStyle = HighlightStyle.define([{\n  tag: tags.link,\n  textDecoration: \"underline\"\n}, {\n  tag: tags.heading,\n  textDecoration: \"underline\",\n  fontWeight: \"bold\"\n}, {\n  tag: tags.emphasis,\n  fontStyle: \"italic\"\n}, {\n  tag: tags.strong,\n  fontWeight: \"bold\"\n}, {\n  tag: tags.keyword,\n  color: \"#708\"\n}, {\n  tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],\n  color: \"#219\"\n}, {\n  tag: [tags.literal, tags.inserted],\n  color: \"#164\"\n}, {\n  tag: [tags.string, tags.deleted],\n  color: \"#a11\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  color: \"#e40\"\n}, {\n  tag: tags.definition(tags.variableName),\n  color: \"#00f\"\n}, {\n  tag: tags.local(tags.variableName),\n  color: \"#30a\"\n}, {\n  tag: [tags.typeName, tags.namespace],\n  color: \"#085\"\n}, {\n  tag: tags.className,\n  color: \"#167\"\n}, {\n  tag: [tags.special(tags.variableName), tags.macroName],\n  color: \"#256\"\n}, {\n  tag: tags.definition(tags.propertyName),\n  color: \"#00c\"\n}, {\n  tag: tags.comment,\n  color: \"#940\"\n}, {\n  tag: tags.meta,\n  color: \"#7a757a\"\n}, {\n  tag: tags.invalid,\n  color: \"#f00\"\n}]);\nconst classHighlightStyle = HighlightStyle.define([{\n  tag: tags.link,\n  class: \"cmt-link\"\n}, {\n  tag: tags.heading,\n  class: \"cmt-heading\"\n}, {\n  tag: tags.emphasis,\n  class: \"cmt-emphasis\"\n}, {\n  tag: tags.strong,\n  class: \"cmt-strong\"\n}, {\n  tag: tags.keyword,\n  class: \"cmt-keyword\"\n}, {\n  tag: tags.atom,\n  class: \"cmt-atom\"\n}, {\n  tag: tags.bool,\n  class: \"cmt-bool\"\n}, {\n  tag: tags.url,\n  class: \"cmt-url\"\n}, {\n  tag: tags.labelName,\n  class: \"cmt-labelName\"\n}, {\n  tag: tags.inserted,\n  class: \"cmt-inserted\"\n}, {\n  tag: tags.deleted,\n  class: \"cmt-deleted\"\n}, {\n  tag: tags.literal,\n  class: \"cmt-literal\"\n}, {\n  tag: tags.string,\n  class: \"cmt-string\"\n}, {\n  tag: tags.number,\n  class: \"cmt-number\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  class: \"cmt-string2\"\n}, {\n  tag: tags.variableName,\n  class: \"cmt-variableName\"\n}, {\n  tag: tags.local(tags.variableName),\n  class: \"cmt-variableName cmt-local\"\n}, {\n  tag: tags.definition(tags.variableName),\n  class: \"cmt-variableName cmt-definition\"\n}, {\n  tag: tags.special(tags.variableName),\n  class: \"cmt-variableName2\"\n}, {\n  tag: tags.typeName,\n  class: \"cmt-typeName\"\n}, {\n  tag: tags.namespace,\n  class: \"cmt-namespace\"\n}, {\n  tag: tags.macroName,\n  class: \"cmt-macroName\"\n}, {\n  tag: tags.propertyName,\n  class: \"cmt-propertyName\"\n}, {\n  tag: tags.operator,\n  class: \"cmt-operator\"\n}, {\n  tag: tags.comment,\n  class: \"cmt-comment\"\n}, {\n  tag: tags.meta,\n  class: \"cmt-meta\"\n}, {\n  tag: tags.invalid,\n  class: \"cmt-invalid\"\n}, {\n  tag: tags.punctuation,\n  class: \"cmt-punctuation\"\n}]);\nexports.HighlightStyle = HighlightStyle;\nexports.Tag = Tag;\nexports.classHighlightStyle = classHighlightStyle;\nexports.defaultHighlightStyle = defaultHighlightStyle;\nexports.highlightTree = highlightTree;\nexports.styleTags = styleTags;\nexports.tags = tags;\n"}