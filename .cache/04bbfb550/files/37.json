{"contents":"var _1_;\nexports.__esModule = true;\nvar d3_hierarchy_1 = __fusereq(44);\nvar d3_selection_1 = __fusereq(45);\nvar d3_shape_1 = __fusereq(46);\nfunction visualize(nodes) {\n  const margin = {\n    top: 20,\n    right: 90,\n    bottom: 20,\n    left: 90\n  };\n  const height = 300 - margin.top - margin.bottom;\n  const width = 500 - margin.left - margin.right;\n  d3_selection_1.select('#viz').selectAll('svg').remove();\n  const viz = d3_selection_1.select('#viz').append('svg');\n  viz.selectAll('*').remove();\n  viz.attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom);\n  const root = {\n    nodeType: 'Program',\n    children: nodes\n  };\n  const treemap = d3_hierarchy_1.tree().size([height, width]).separation(() => 1);\n  const treelayout = d3_hierarchy_1.hierarchy(root, getChildren);\n  const tree = treemap(treelayout);\n  const g = viz.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`).attr(\"font-family\", \"sans-serif\").attr(\"font-size\", 12);\n  const link = g.selectAll('path.link').data(tree.links());\n  const linkEnter = link.enter().append('path', 'g');\n  linkEnter.attr('class', 'link').attr('fill', 'none').attr(\"stroke-opacity\", 0.4).attr('stroke', '#555').attr(\"stroke-width\", 1.5).attr('d', connection);\n  const node = g.selectAll('g.node').data(tree.descendants());\n  const nodeEnter = node.enter().append('g');\n  nodeEnter.attr('class', 'node').attr('transform', d => `translate(${d.y}, ${d.x})`);\n  nodeEnter.append('circle').attr(\"fill\", getFill).attr('r', '2.5').attr('stroke-width', 10);\n  nodeEnter.append('text').attr(\"dy\", \"0.31em\").attr(\"x\", d => d.children ? -8 : 8).attr(\"text-anchor\", d => d.children ? \"end\" : \"start\").attr('fill', d => isUndefined(d) ? '#fc6666' : 'black').style(\"fill-opacity\", 1).call(getTextBox).datum(d => d.data).text(getText).clone(true).lower().attr(\"stroke\", \"white\");\n  nodeEnter.filter((d, i) => isUndefined(d)).call(yep).insert('rect', 'text').attr(\"x\", function (d) {\n    return d.bbox.x;\n  }).attr(\"y\", function (d) {\n    return d.bbox.y;\n  }).attr(\"width\", function (d) {\n    return d.bbox.width;\n  }).attr(\"height\", function (d) {\n    return d.bbox.height;\n  }).attr('fill', 'black');\n}\nexports.visualize = visualize;\nfunction getTextBox(selection) {\n  selection.each(function (d) {\n    d.bbox = this.getBBox();\n  });\n}\nfunction yep(selection) {}\nconst connection = d3_shape_1.linkHorizontal().x(d => d.y).y(d => d.x);\nfunction getChildren(node) {\n  var children = [];\n  switch (node.nodeType) {\n    case 'Program':\n      children = node.children;\n      break;\n    case 'Function':\n      children = node.args;\n      break;\n    case 'Choose':\n      children = [node.case.predicate, node.case.consequent, node.otherwise];\n      break;\n    case 'BinaryOperation':\n      children = [node.left, node.right];\n      break;\n    case 'VariableAssignment':\n      children = [node.assignment];\n      break;\n    default:\n      children = [];\n  }\n  return children;\n}\nfunction getText(node) {\n  var text = \"\";\n  switch (node.nodeType) {\n    case 'Program':\n      text = '';\n      break;\n    case 'Function':\n      text = node.name;\n      break;\n    case 'Choose':\n      text = \"choose\";\n      break;\n    case 'BinaryOperation':\n      text = node.operator;\n      break;\n    case 'VariableAssignment':\n      text = node.name;\n      break;\n    case 'Identifier':\n      text = node.name;\n      break;\n    case 'Number':\n      text = node.value.toString();\n      break;\n    case 'Boolean':\n      text = node.value.toString();\n      break;\n    default:\n      text = \"\";\n  }\n  return text;\n}\nfunction getFill(node) {\n  if (isUndefined(node)) {\n    return '#fc6666';\n  }\n  if (node.children) {\n    return '#555';\n  } else {\n    return '#999';\n  }\n}\nfunction isUndefined(d) {\n  return ((_1_ = d.data.outputType) === null || _1_ === void 0 ? void 0 : _1_.status) === 'Maybe-Undefined';\n}\n","sourceMap":"{\"version\":3,\"sources\":[\"src/visualization.ts\"],\"names\":[\"nodes\",\"margin\",\"top\",\"right\",\"bottom\",\"left\",\"height\",\"width\",\"select\",\"selectAll\",\"remove\",\"viz\",\"append\",\"attr\",\"root\",\"nodeType\",\"children\",\"treemap\",\"tree\",\"size\",\"separation\",\"treelayout\",\"hierarchy\",\"getChildren\",\"g\",\"link\",\"data\",\"links\",\"linkEnter\",\"enter\",\"connection\",\"node\",\"descendants\",\"nodeEnter\",\"d\",\"y\",\"x\",\"getFill\",\"isUndefined\",\"style\",\"call\",\"getTextBox\",\"datum\",\"text\",\"getText\",\"clone\",\"lower\",\"filter\",\"i\",\"yep\",\"insert\",\"bbox\",\"selection\",\"each\",\"getBBox\",\"linkHorizontal\",\"args\",\"case\",\"predicate\",\"consequent\",\"otherwise\",\"assignment\",\"name\",\"operator\",\"value\",\"toString\",\"outputType\",\"status\"],\"mappings\":\";;;;;AAKO,mBAAmBA;QAGhBC;IAAUC,KAAK;IAAIC,OAAO;IAAIC,QAAQ;IAAIC,MAAM;;QAChDC,SAAS,MAAML,OAAOC,MAAMD,OAAOG;QACnCG,QAAS,MAAMN,OAAOI,OAAOJ,OAAOE;iBAGjCK,OAAO,QAAQC,UAAU,OAAOC;QACnCC,qBAAeH,OAAO,QAAQI,OAAO;EAG3CD,IAAIF,UAAU,KAAKC;EAGnBC,IAAIE,KAAK,SAASN,QAAQN,OAAOI,OAAOJ,OAAOE,OAC3CU,KAAK,UAAUP,SAASL,OAAOC,MAAMD,OAAOG;QAE1CU;IAAcC,UAAU;IAAWC,UAAUhB;;QAM3CiB,yBAAsBC,OACzBC,MAAMb,QAAQC,QACda,WAAW,MAAM;QACdC,4BAAyBC,UAAUR,MAAMS;QACzCL,OAAOD,QAAQI;QAGfG,IAAIb,IAAIC,OAAO,KAEPC,KAAK,0BAA0BZ,OAAOI,SAASJ,OAAOC,QACtDW,KAAK,eAAe,cACpBA,KAAK,aAAa;QAG1BY,OAAOD,EAAEf,UAAU,aAAaiB,KAAKR,KAAKS;QAG1CC,YAAYH,KAAKI,QAAQjB,OAAO,QAAQ;EAG9CgB,UAAUf,KAAK,SAAS,QACdA,KAAK,QAAQ,QACbA,KAAK,kBAAkB,KACvBA,KAAK,UAAU,QACfA,KAAK,gBAAgB,KACrBA,KAAK,KAAKiB;QAIdC,OAAOP,EAAEf,UAAU,UAAUiB,KAAKR,KAAKc;QAGvCC,YAAYF,KAAKF,QAAQjB,OAAO;EAGtCqB,UAAUpB,KAAK,SAAS,QACdA,KAAK,aAAa,AAAAqB,kBAAkBA,EAAEC,MAAMD,EAAEE;EAExDH,UAAUrB,OAAO,UACPC,KAAK,QAAQwB,SACbxB,KAAK,KAAK,OACVA,KAAK,gBAAgB;EAG/BoB,UAAUrB,OAAO,QAENC,KAAK,MAAM,UACXA,KAAK,KAAK,AAAAqB,KAAKA,EAAElB,YAAY,IAAI,GACjCH,KAAK,eAAe,AAAAqB,KAAKA,EAAElB,WAAW,QAAQ,SAC9CH,KAAK,QAAQ,AAAAqB,KAAKI,YAAYJ,KAAK,YAAY,SAC/CK,MAAM,gBAAgB,GACtBC,KAAKC,YACLC,MAAM,AAAAR,KAAKA,EAAER,MACbiB,KAAKC,SACXC,MAAM,MAAMC,QACVjC,KAAK,UAAU;EAItBoB,UAAUc,OAAO,CAACb,GAAEc,MAAMV,YAAYJ,IACnCM,KAAKS,KACLC,OAAO,QAAQ,QACfrC,KAAK,KAAK,UAASqB;WAAUA,EAAEiB,KAAKf;KACpCvB,KAAK,KAAK,UAASqB;WAAUA,EAAEiB,KAAKhB;KACpCtB,KAAK,SAAS,UAASqB;WAAUA,EAAEiB,KAAK5C;KACxCM,KAAK,UAAU,UAASqB;WAAUA,EAAEiB,KAAK7C;KACzCO,KAAK,QAAQ;;;AAKtB,oBAAoBuC;EAClBA,UAAUC,KAAK,UAASnB;IAAGA,EAAEiB,OAAO,KAAKG;;;AAG3C,aAAaF;MAKPtB,wBAAqByB,iBAAiBnB,EAAE,AAAAF,KAAKA,EAAEC,GAAGA,EAAE,AAAAD,KAAKA,EAAEE;AAEjE,qBAAqBL;MACff;UACIe,KAAKhB;SACN;MACHC,WAAWe,KAAKf;;SAEb;MACHA,WAAWe,KAAKyB;;SAEb;MACHxC,YAAYe,KAAK0B,KAAKC,WAAW3B,KAAK0B,KAAKE,YAAY5B,KAAK6B;;SAEzD;MACH5C,YAAYe,KAAK1B,MAAM0B,KAAK5B;;SAEzB;MACHa,YAAYe,KAAK8B;;;MAGjB7C;;SAGGA;;AAGT,iBAAiBe;MACXY,OAAO;UACHZ,KAAKhB;SACN;MACH4B,OAAO;;SAEJ;MACHA,OAAOZ,KAAK+B;;SAET;MACHnB,OAAO;;SAEJ;MACHA,OAAOZ,KAAKgC;;SAET;MACHpB,OAAOZ,KAAK+B;;SAET;MACHnB,OAAOZ,KAAK+B;;SAET;MACHnB,OAAOZ,KAAKiC,MAAMC;;SAEf;MACHtB,OAAOZ,KAAKiC,MAAMC;;;MAGlBtB,OAAO;;SAGJA;;AAGT,iBAAiBZ;MACXO,YAAYP;WACP;;MAELA,KAAKf;WACA;;WAEA;;;AAIX,qBAAqBkB;iBACZA,EAAER,KAAKwC,sDAAYC,YAAW\",\"sourcesContent\":[\"import * as d3Hierarchy from 'd3-hierarchy';\\nimport * as d3Select from 'd3-selection';\\nimport * as d3shape from 'd3-shape';\\nimport * as AST from './ast';\\n\\nexport function visualize(nodes: AST.Node[]): void {\\n\\n    // Placement and size of tree\\n    const margin = {top: 20, right: 90, bottom: 20, left: 90};\\n    const height = 300 - margin.top - margin.bottom;\\n    const width  = 500 - margin.left - margin.right;\\n  \\n    // Make the svg\\n    d3Select.select('#viz').selectAll('svg').remove();\\n    const viz = d3Select.select('#viz').append('svg');\\n  \\n    // Remove existing visualizations\\n    viz.selectAll('*').remove();\\n  \\n    // Add a new visualization\\n    viz.attr('width', width + margin.left + margin.right)\\n       .attr('height', height + margin.top + margin.bottom);\\n\\n    const root: Node = {nodeType: 'Program', children: nodes}\\n\\n    // Visualize all the statements\\n    // for (var statement of nodes) {\\n\\n      // Create the tree and layout\\n      const treemap = d3Hierarchy.tree()\\n        .size([height, width])\\n        .separation(() => 1);\\n      const treelayout = d3Hierarchy.hierarchy(root, getChildren);\\n      const tree = treemap(treelayout);\\n  \\n      // Add a new graph element for this statement\\n      const g = viz.append('g')\\n                  //  .attr(\\\"transform\\\", `translate(${root.dy / 3},${root.dx - x0})`);\\n                   .attr('transform', `translate(${margin.left}, ${margin.top})`)\\n                   .attr(\\\"font-family\\\", \\\"sans-serif\\\")\\n                   .attr(\\\"font-size\\\", 12)\\n               \\n      // Edge updates\\n      const link = g.selectAll('path.link').data(tree.links());\\n\\n      // Edge entry\\n      const linkEnter = link.enter().append('path', 'g');\\n        \\n      // general edge attributes\\n      linkEnter.attr('class', 'link')\\n               .attr('fill', 'none')\\n               .attr(\\\"stroke-opacity\\\", 0.4)\\n               .attr('stroke', '#555')\\n               .attr(\\\"stroke-width\\\", 1.5)\\n               .attr('d', connection);\\n\\n        \\n      // Node updates\\n      const node = g.selectAll('g.node').data(tree.descendants());\\n\\n      // Node entry\\n      const nodeEnter = node.enter().append('g');\\n\\n      // general node attributes\\n      nodeEnter.attr('class', 'node')\\n               .attr('transform', d => `translate(${d.y}, ${d.x})`);\\n\\n      nodeEnter.append('circle')\\n               .attr(\\\"fill\\\", getFill)\\n               .attr('r', '2.5')\\n               .attr('stroke-width', 10);\\n\\n      // add text\\n      nodeEnter.append('text')\\n                // .attr('dy', '-10px')\\n                .attr(\\\"dy\\\", \\\"0.31em\\\")\\n                .attr(\\\"x\\\", d => d.children ? -8 : 8)\\n                .attr(\\\"text-anchor\\\", d => d.children ? \\\"end\\\" : \\\"start\\\")\\n                .attr('fill', d => isUndefined(d) ? '#fc6666' : 'black')\\n                .style(\\\"fill-opacity\\\", 1)\\n                .call(getTextBox)\\n                .datum(d => d.data)\\n                .text(getText)\\n          .clone(true).lower()\\n            .attr(\\\"stroke\\\", \\\"white\\\");\\n    \\n      // Highlight undefined -- not working\\n      // Inspired in part by https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\\n      nodeEnter.filter((d,i) => isUndefined(d))\\n        .call(yep)\\n        .insert('rect', 'text')\\n        .attr(\\\"x\\\", function(d){return d.bbox.x})\\n        .attr(\\\"y\\\", function(d){return d.bbox.y})\\n        .attr(\\\"width\\\", function(d){return d.bbox.width})\\n        .attr(\\\"height\\\", function(d){return d.bbox.height}) \\n        .attr('fill', 'black')             \\n    // }\\n}\\n\\n// From https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\\nfunction getTextBox(selection) {\\n  selection.each(function(d){d.bbox = this.getBBox();})\\n}\\n\\nfunction yep(selection) {\\n  // console.log(selection.nodes().map((d)=>d.bbox));\\n}\\n\\n\\nconst connection = d3shape.linkHorizontal().x(d => d.y).y(d => d.x)\\n\\nfunction getChildren(node: AST.Node): AST.Node[] {\\n  var children: AST.Node[] = [];\\n  switch (node.nodeType) {\\n    case 'Program':\\n      children = node.children;\\n      break;\\n    case 'Function':\\n      children = node.args;\\n      break;\\n    case 'Choose':\\n      children = [node.case.predicate, node.case.consequent, node.otherwise];\\n      break;\\n    case 'BinaryOperation':\\n      children = [node.left, node.right];\\n      break;\\n    case 'VariableAssignment':\\n      children = [node.assignment];\\n      break;\\n    default:\\n      children = [];\\n    }\\n\\n  return children;\\n}\\n\\nfunction getText(node) {\\n  var text = \\\"\\\";\\n  switch (node.nodeType) {\\n    case 'Program':\\n      text = '';\\n      break;\\n    case 'Function':\\n      text = node.name;\\n      break;\\n    case 'Choose':\\n      text = \\\"choose\\\";\\n      break;\\n    case 'BinaryOperation':\\n      text = node.operator;\\n      break;\\n    case 'VariableAssignment':\\n      text = node.name;\\n      break;\\n    case 'Identifier':\\n      text = node.name;\\n      break;\\n    case 'Number':  \\n      text = node.value.toString();\\n      break;\\n    case 'Boolean':\\n      text = node.value.toString();\\n      break;\\n    default:\\n      text = \\\"\\\";\\n  }\\n\\n  return text;\\n}\\n\\nfunction getFill(node): string {\\n  if (isUndefined(node)) {\\n    return '#fc6666'\\n  }\\n  if (node.children) {\\n    return '#555'\\n  } else {\\n    return '#999'\\n  }\\n}\\n\\nfunction isUndefined(d) {\\n  return d.data.outputType?.status === 'Maybe-Undefined'\\n}\"]}"}