{"contents":"exports.__esModule = true;\nvar lexer_1 = __fusereq(13);\nvar typechecker_1 = __fusereq(14);\nvar mudChecker_1 = __fusereq(15);\nvar parseResults_1 = __fusereq(7);\nexports.miniCL = {\n  startState: function () {\n    return {\n      line: 1,\n      stack: ['default']\n    };\n  },\n  token: function (stream, state) {\n    if (stream.eatSpace()) return null;\n    return token2tag(lexer_1.getDefaultToken(stream, state));\n  }\n};\nexports.miniCLLinter = () => view => {\n  const results = view.state.field(parseResults_1.parseResults);\n  let dependsMap = {};\n  let registeredNodes = {};\n  const {errors: typeErrors, aTree: analyzedNodes} = typechecker_1.typecheck(results.nodes, registeredNodes);\n  const mudErrors = mudChecker_1.mudCheck(analyzedNodes, registeredNodes, dependsMap);\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\n  const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\n  return parseDiagnostics.concat(typeDiagnostics).concat(mudDiagnostics).sort((a, b) => {\n    if (a.from < b.from) {\n      return -1;\n    } else if (a.from > b.from) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n};\nconst makeDiagnostic = (view, severity = 'error') => error => {\n  return {\n    from: firstLine(view, error) + error.position.first_column,\n    to: lastLine(view, error) + error.position.last_column,\n    message: error.message,\n    severity: severity\n  };\n};\nfunction firstLine(view, error) {\n  return view.state.doc.line(error.position.first_line).from;\n}\nfunction lastLine(view, error) {\n  return view.state.doc.line(error.position.last_line).from;\n}\nfunction token2tag(token) {\n  switch (token) {\n    case 'NUMBER':\n      return 'number';\n    case 'TRUE':\n      return 'boolean';\n    case 'FALSE':\n      return 'boolean';\n    case '(':\n    case ')':\n      return 'bracket';\n    case '+':\n    case '-':\n    case '*':\n    case '/':\n    case '|':\n    case '&':\n    case '=':\n      return 'operator';\n    case 'COMMENT':\n      return 'comment';\n    case 'CHOOSE1':\n    case 'CHOOSE2':\n      return 'choose';\n    case 'FUNCTION':\n      return 'function';\n    case 'IDENTIFIER':\n      return 'variable';\n    case 'ERROR':\n      return 'error';\n    default:\n      return undefined;\n  }\n}\n","sourceMap":"{\"version\":3,\"sources\":[\"src/miniCL.ts\"],\"names\":[\"startState\",\"line\",\"stack\",\"token\",\"stream\",\"state\",\"eatSpace\",\"token2tag\",\"lexer_1\",\"view\",\"results\",\"field\",\"parseResults_1\",\"dependsMap\",\"registeredNodes\",\"errors\",\"typeErrors\",\"aTree\",\"analyzedNodes\",\"typechecker_1\",\"nodes\",\"mudErrors\",\"mudChecker_1\",\"parseDiagnostics\",\"parseErrors\",\"map\",\"makeDiagnostic\",\"typeDiagnostics\",\"mudDiagnostics\",\"concat\",\"sort\",\"a\",\"b\",\"from\",\"severity\",\"error\",\"firstLine\",\"position\",\"first_column\",\"to\",\"lastLine\",\"last_column\",\"message\",\"doc\",\"first_line\",\"last_line\",\"undefined\"],\"mappings\":\";;;;;;EAcEA,YAAY;;MACFC,MAAM;MAAGC,QAAQ;;;EAE3BC,OAAO,UAAUC,QAAsBC;QACjCD,OAAOE,mBAAmB;WACvBC,UAAUC,wBAAgBJ,QAAQC;;;uBAOhB,MAAM,AAACI;QAG5BC,UAAUD,KAAKJ,MAAMM,MAAMC;MAE7BC;MACAC;SAEGC,QAAQC,YAAYC,OAAOC,iBAAiBC,wBAAUT,QAAQU,OAAON;QACtEO,YAAYC,sBAASJ,eAAeJ,iBAAiBD;QAGrDU,mBAAmBb,QAAQc,YAAYC,IAAIC,eAAejB;QAC1DkB,kBAAkBX,WAAWS,IAAIC,eAAejB;QAChDmB,iBAAiBP,UAAUI,IAAIC,eAAejB,MAAM;SAGnDc,iBACEM,OAAOF,iBACPE,OAAOD,gBACPE,KAAK,CAACC,GAAGC;QACJD,EAAEE,OAAOD,EAAEC;cACL;eACCF,EAAEE,OAAOD,EAAEC;aACb;;aAEA;;;;MAQfP,iBAAiB,CAACjB,MAAkByB,WAAyC,YACjF,AAACC;;IAEGF,MAAMG,UAAU3B,MAAM0B,SAASA,MAAME,SAASC;IAC9CC,IAAIC,SAAS/B,MAAM0B,SAASA,MAAME,SAASI;IAC3CC,SAASP,MAAMO;IACfR,UAAUA;;;AAOhB,mBAAmBzB,MAAkB0B;SAC5B1B,KAAKJ,MAAMsC,IAAI1C,KAAKkC,MAAME,SAASO,YAAYX;;AAMxD,kBAAmBxB,MAAkB0B;SAC5B1B,KAAKJ,MAAMsC,IAAI1C,KAAKkC,MAAME,SAASQ,WAAWZ;;AAMvD,mBAAmB9B;UACTA;SACD;aACI;SAEJ;aACI;SAEJ;aACI;SAEJ;SACA;aACI;SAEJ;SACA;SACA;SACA;SACA;SACA;SACA;aACI;SAEJ;aACI;SAEJ;SACA;aACI;SAEJ;aACI;SAEJ;aACI;SAEJ;aACI;;aAGA2C\",\"sourcesContent\":[\"import {StreamParser, StringStream} from \\\"@codemirror/stream-parser\\\"\\nimport {Diagnostic} from \\\"@codemirror/lint\\\"\\nimport {EditorView} from \\\"@codemirror/view\\\"\\nimport {State, getDefaultToken} from './lexer'\\nimport {ParseError} from './position'\\nimport {typecheck} from './typechecker';\\nimport {mudCheck} from './mudChecker';\\nimport {parseResults} from './parseResults';\\nimport * as AnalyzedTree from './analyzedTree';\\n\\n/**\\n * The extension for our language\\n */\\nexport const miniCL: StreamParser<State> = {\\n  startState: function (): State {\\n    return {line: 1, stack: ['default']};\\n  },\\n  token: function (stream: StringStream, state: State): string | undefined {\\n    if (stream.eatSpace()) return null;\\n    return token2tag(getDefaultToken(stream, state));\\n  }\\n};\\n\\n/**\\n * The linter for our language\\n */\\n export const miniCLLinter = () => (view: EditorView): Diagnostic[] => {\\n\\n  // Get the result types\\n  const results = view.state.field(parseResults);\\n\\n  let dependsMap: {[key: string]: string[]} = {};\\n  let registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode} = {}\\n  // Error checking\\n  const {errors: typeErrors, aTree: analyzedNodes} = typecheck(results.nodes, registeredNodes);\\n  const mudErrors = mudCheck(analyzedNodes, registeredNodes, dependsMap);\\n\\n  // Create a diagnostic for each kind of error\\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\\n  const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\\n\\n  // CodeMirror requires diagnostics to be sorted by the `from` attribute.\\n  return parseDiagnostics\\n          .concat(typeDiagnostics)\\n          .concat(mudDiagnostics)\\n          .sort((a, b) => {\\n            if (a.from < b.from) {\\n              return -1;\\n            } else if (a.from > b.from) {\\n              return 1;\\n            } else {\\n              return 0;\\n            }\\n          }); \\n}\\n\\n/**\\n * Create a diagnostic from an error\\n */\\nconst makeDiagnostic = (view: EditorView, severity: 'error' | 'info' | 'warning' = 'error') => \\n  (error): Diagnostic => {\\n    return {\\n      from: firstLine(view, error) + error.position.first_column,\\n      to: lastLine(view, error) + error.position.last_column,\\n      message: error.message,\\n      severity: severity\\n    }\\n}\\n\\n/**\\n * @returns the line number for the start of the error\\n */\\nfunction firstLine(view: EditorView, error: ParseError) {\\n  return view.state.doc.line(error.position.first_line).from;\\n}\\n\\n/**\\n * @returns the line number for the end of the error\\n */\\nfunction lastLine (view: EditorView, error: ParseError) {\\n  return view.state.doc.line(error.position.last_line).from;    \\n}\\n\\n/**\\n * Convert our bespoke parser Token type to a token type that is recognized by CodeMirror\\n */\\nfunction token2tag(token: string): string | undefined {\\n  switch (token) {\\n    case 'NUMBER':\\n      return 'number';\\n\\n    case 'TRUE':\\n      return 'boolean';\\n\\n    case 'FALSE':\\n      return 'boolean';\\n\\n    case '(':\\n    case ')':\\n      return 'bracket';\\n\\n    case '+':\\n    case '-':\\n    case '*':\\n    case '/':\\n    case '|':\\n    case '&':\\n    case '=':\\n      return 'operator';\\n\\n    case 'COMMENT':\\n      return 'comment';\\n\\n    case 'CHOOSE1':\\n    case 'CHOOSE2':\\n      return 'choose';\\n\\n    case 'FUNCTION':\\n      return 'function';\\n\\n    case 'IDENTIFIER':\\n      return 'variable';\\n\\n    case 'ERROR':\\n      return 'error';\\n\\n    default:\\n      return undefined;\\n  }\\n}\\n\"]}"}