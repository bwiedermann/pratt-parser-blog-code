{"contents":"exports.__esModule = true;\nvar lexer_1 = __fusereq(13);\nvar typechecker_1 = __fusereq(14);\nvar mudChecker_1 = __fusereq(15);\nvar parseResults_1 = __fusereq(7);\nexports.miniCL = {\n  startState: function () {\n    return {\n      line: 1,\n      stack: ['default']\n    };\n  },\n  token: function (stream, state) {\n    if (stream.eatSpace()) return null;\n    return token2tag(lexer_1.getDefaultToken(stream, state));\n  }\n};\nexports.miniCLLinter = () => view => {\n  const results = view.state.field(parseResults_1.parseResults);\n  const mudErrors = mudChecker_1.mudCheck(results.nodes, results.registeredNodes, results.dependsMap);\n  const typeErrors = typechecker_1.typecheck(results.nodes, results.registeredNodes);\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\n  const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\n  return parseDiagnostics.concat(typeDiagnostics).concat(mudDiagnostics);\n};\nconst makeDiagnostic = (view, severity = 'error') => error => {\n  return {\n    from: firstLine(view, error) + error.position.first_column,\n    to: lastLine(view, error) + error.position.last_column,\n    message: error.message,\n    severity: severity\n  };\n};\nfunction firstLine(view, error) {\n  return view.state.doc.line(error.position.first_line).from;\n}\nfunction lastLine(view, error) {\n  return view.state.doc.line(error.position.last_line).from;\n}\nfunction token2tag(token) {\n  switch (token) {\n    case 'NUMBER':\n      return 'number';\n    case 'TRUE':\n      return 'boolean';\n    case 'FALSE':\n      return 'boolean';\n    case '(':\n    case ')':\n      return 'bracket';\n    case '+':\n    case '-':\n    case '*':\n    case '/':\n    case '|':\n    case '&':\n    case '=':\n      return 'operator';\n    case 'COMMENT':\n      return 'comment';\n    case 'CHOOSE1':\n    case 'CHOOSE2':\n      return 'choose';\n    case 'FUNCTION':\n      return 'function';\n    case 'IDENTIFIER':\n      return 'variable';\n    case 'ERROR':\n      return 'error';\n    default:\n      return undefined;\n  }\n}\n","sourceMap":"{\"version\":3,\"sources\":[\"src/miniCL.ts\"],\"names\":[\"startState\",\"line\",\"stack\",\"token\",\"stream\",\"state\",\"eatSpace\",\"token2tag\",\"lexer_1\",\"view\",\"results\",\"field\",\"parseResults_1\",\"mudErrors\",\"mudChecker_1\",\"nodes\",\"registeredNodes\",\"dependsMap\",\"typeErrors\",\"typechecker_1\",\"parseDiagnostics\",\"parseErrors\",\"map\",\"makeDiagnostic\",\"typeDiagnostics\",\"mudDiagnostics\",\"concat\",\"severity\",\"error\",\"from\",\"firstLine\",\"position\",\"first_column\",\"to\",\"lastLine\",\"last_column\",\"message\",\"doc\",\"first_line\",\"last_line\",\"undefined\"],\"mappings\":\";;;;;;EAaEA,YAAY;;MACFC,MAAM;MAAGC,QAAQ;;;EAE3BC,OAAO,UAAUC,QAAsBC;QACjCD,OAAOE,mBAAmB;WACvBC,UAAUC,wBAAgBJ,QAAQC;;;uBAOhB,MAAM,AAACI;QAG5BC,UAAUD,KAAKJ,MAAMM,MAAMC;QAG3BC,YAAYC,sBAASJ,QAAQK,OAAOL,QAAQM,iBAAiBN,QAAQO;QACrEC,aAAaC,wBAAUT,QAAQK,OAAOL,QAAQM;QAG9CI,mBAAmBV,QAAQW,YAAYC,IAAIC,eAAed;QAC1De,kBAAkBN,WAAWI,IAAIC,eAAed;QAChDgB,iBAAiBZ,UAAUS,IAAIC,eAAed,MAAM;SAEnDW,iBAAiBM,OAAOF,iBAAiBE,OAAOD;;MAMnDF,iBAAiB,CAACd,MAAkBkB,WAAyC,YACjF,AAACC;;IAEGC,MAAMC,UAAUrB,MAAMmB,SAASA,MAAMG,SAASC;IAC9CC,IAAIC,SAASzB,MAAMmB,SAASA,MAAMG,SAASI;IAC3CC,SAASR,MAAMQ;IACfT,UAAUA;;;AAOhB,mBAAmBlB,MAAkBmB;SAC5BnB,KAAKJ,MAAMgC,IAAIpC,KAAK2B,MAAMG,SAASO,YAAYT;;AAMxD,kBAAmBpB,MAAkBmB;SAC5BnB,KAAKJ,MAAMgC,IAAIpC,KAAK2B,MAAMG,SAASQ,WAAWV;;AAMvD,mBAAmB1B;UACTA;SACD;aACI;SAEJ;aACI;SAEJ;aACI;SAEJ;SACA;aACI;SAEJ;SACA;SACA;SACA;SACA;SACA;SACA;aACI;SAEJ;aACI;SAEJ;SACA;aACI;SAEJ;aACI;SAEJ;aACI;SAEJ;aACI;;aAGAqC\",\"sourcesContent\":[\"import {StreamParser, StringStream} from \\\"@codemirror/stream-parser\\\"\\nimport {Diagnostic} from \\\"@codemirror/lint\\\"\\nimport {EditorView} from \\\"@codemirror/view\\\"\\nimport {State, getDefaultToken} from './lexer'\\nimport {ParseError} from './position'\\nimport {typecheck} from './typechecker';\\nimport {mudCheck} from './mudChecker';\\nimport {parseResults} from './parseResults';\\n\\n/**\\n * The extension for our language\\n */\\nexport const miniCL: StreamParser<State> = {\\n  startState: function (): State {\\n    return {line: 1, stack: ['default']};\\n  },\\n  token: function (stream: StringStream, state: State): string | undefined {\\n    if (stream.eatSpace()) return null;\\n    return token2tag(getDefaultToken(stream, state));\\n  }\\n};\\n\\n/**\\n * The linter for our language\\n */\\n export const miniCLLinter = () => (view: EditorView): Diagnostic[] => {\\n\\n  // Get the result types\\n  const results = view.state.field(parseResults);\\n\\n  // Error checking\\n  const mudErrors = mudCheck(results.nodes, results.registeredNodes, results.dependsMap);\\n  const typeErrors = typecheck(results.nodes, results.registeredNodes);\\n\\n  // Create a diagnostic for each kind of error\\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\\n  const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\\n\\n  return parseDiagnostics.concat(typeDiagnostics).concat(mudDiagnostics);\\n}\\n\\n/**\\n * Create a diagnostic from an error\\n */\\nconst makeDiagnostic = (view: EditorView, severity: 'error' | 'info' | 'warning' = 'error') => \\n  (error): Diagnostic => {\\n    return {\\n      from: firstLine(view, error) + error.position.first_column,\\n      to: lastLine(view, error) + error.position.last_column,\\n      message: error.message,\\n      severity: severity\\n    }\\n}\\n\\n/**\\n * @returns the line number for the start of the error\\n */\\nfunction firstLine(view: EditorView, error: ParseError) {\\n  return view.state.doc.line(error.position.first_line).from;\\n}\\n\\n/**\\n * @returns the line number for the end of the error\\n */\\nfunction lastLine (view: EditorView, error: ParseError) {\\n  return view.state.doc.line(error.position.last_line).from;    \\n}\\n\\n/**\\n * Convert our bespoke parser Token type to a token type that is recognized by CodeMirror\\n */\\nfunction token2tag(token: string): string | undefined {\\n  switch (token) {\\n    case 'NUMBER':\\n      return 'number';\\n\\n    case 'TRUE':\\n      return 'boolean';\\n\\n    case 'FALSE':\\n      return 'boolean';\\n\\n    case '(':\\n    case ')':\\n      return 'bracket';\\n\\n    case '+':\\n    case '-':\\n    case '*':\\n    case '/':\\n    case '|':\\n    case '&':\\n    case '=':\\n      return 'operator';\\n\\n    case 'COMMENT':\\n      return 'comment';\\n\\n    case 'CHOOSE1':\\n    case 'CHOOSE2':\\n      return 'choose';\\n\\n    case 'FUNCTION':\\n      return 'function';\\n\\n    case 'IDENTIFIER':\\n      return 'variable';\\n\\n    case 'ERROR':\\n      return 'error';\\n\\n    default:\\n      return undefined;\\n  }\\n}\\n\"]}"}