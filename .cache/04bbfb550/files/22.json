{"contents":"exports.__esModule = true;\nvar view_1 = __fusereq(18);\nvar rangeset_1 = __fusereq(39);\nvar state_1 = __fusereq(16);\nclass GutterMarker extends rangeset_1.RangeValue {\n  compare(other) {\n    return this == other || this.constructor == other.constructor && this.eq(other);\n  }\n  toDOM(_view) {\n    return null;\n  }\n  at(pos) {\n    return this.range(pos);\n  }\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.mapMode = state_1.MapMode.TrackBefore;\nconst defaults = {\n  class: \"\",\n  renderEmptyElements: false,\n  elementStyle: \"\",\n  markers: () => rangeset_1.RangeSet.empty,\n  lineMarker: () => null,\n  initialSpacer: null,\n  updateSpacer: null,\n  domEventHandlers: {}\n};\nconst activeGutters = state_1.Facet.define();\nfunction gutter(config) {\n  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\nconst baseTheme = view_1.EditorView.baseTheme({\n  \".cm-gutters\": {\n    display: \"flex\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    left: 0\n  },\n  \"&light .cm-gutters\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"#999\",\n    borderRight: \"1px solid #ddd\"\n  },\n  \"&dark .cm-gutters\": {\n    backgroundColor: \"#333338\",\n    color: \"#ccc\"\n  },\n  \".cm-gutter\": {\n    display: \"flex !important\",\n    flexDirection: \"column\",\n    flexShrink: 0,\n    boxSizing: \"border-box\",\n    height: \"100%\",\n    overflow: \"hidden\"\n  },\n  \".cm-gutterElement\": {\n    boxSizing: \"border-box\"\n  },\n  \".cm-lineNumbers .cm-gutterElement\": {\n    padding: \"0 3px 0 5px\",\n    minWidth: \"20px\",\n    textAlign: \"right\",\n    whiteSpace: \"nowrap\"\n  }\n});\nconst unfixGutters = state_1.Facet.define({\n  combine: values => values.some(x => x)\n});\nfunction gutters(config) {\n  let result = [gutterView, baseTheme];\n  if (config && config.fixed === false) result.push(unfixGutters.of(true));\n  return result;\n}\nconst gutterView = view_1.ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutters\";\n    this.dom.setAttribute(\"aria-hidden\", \"true\");\n    this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n    for (let gutter of this.gutters) this.dom.appendChild(gutter.dom);\n    this.fixed = !view.state.facet(unfixGutters);\n    if (this.fixed) {\n      this.dom.style.position = \"sticky\";\n    }\n    view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n  }\n  update(update) {\n    if (!this.updateGutters(update)) return;\n    let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport));\n    this.view.viewportLines(line => {\n      let text;\n      if (Array.isArray(line.type)) {\n        for (let b of line.type) if (b.type == view_1.BlockType.Text) {\n          text = b;\n          break;\n        }\n      } else {\n        text = line.type == view_1.BlockType.Text ? line : undefined;\n      }\n      if (!text) return;\n      for (let cx of contexts) cx.line(this.view, text);\n    }, 0);\n    for (let cx of contexts) cx.finish();\n    this.dom.style.minHeight = this.view.contentHeight + \"px\";\n    if (update.state.facet(unfixGutters) != !this.fixed) {\n      this.fixed = !this.fixed;\n      this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n    }\n  }\n  updateGutters(update) {\n    let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n    let change = update.docChanged || update.heightChanged || update.viewportChanged;\n    if (prev == cur) {\n      for (let gutter of this.gutters) if (gutter.update(update)) change = true;\n    } else {\n      change = true;\n      let gutters = [];\n      for (let conf of cur) {\n        let known = prev.indexOf(conf);\n        if (known < 0) {\n          gutters.push(new SingleGutterView(this.view, conf));\n        } else {\n          this.gutters[known].update(update);\n          gutters.push(this.gutters[known]);\n        }\n      }\n      for (let g of this.gutters) g.dom.remove();\n      for (let g of gutters) this.dom.appendChild(g.dom);\n      this.gutters = gutters;\n    }\n    return change;\n  }\n  destroy() {\n    this.dom.remove();\n  }\n}, {\n  provide: view_1.PluginField.scrollMargins.from(value => {\n    if (value.gutters.length == 0 || !value.fixed) return null;\n    return value.view.textDirection == view_1.Direction.LTR ? {\n      left: value.dom.offsetWidth\n    } : {\n      right: value.dom.offsetWidth\n    };\n  })\n});\nfunction asArray(val) {\n  return Array.isArray(val) ? val : [val];\n}\nclass UpdateContext {\n  constructor(gutter, viewport) {\n    this.gutter = gutter;\n    this.localMarkers = [];\n    this.i = 0;\n    this.height = 0;\n    this.cursor = rangeset_1.RangeSet.iter(gutter.markers, viewport.from);\n  }\n  line(view, line) {\n    if (this.localMarkers.length) this.localMarkers = [];\n    while (this.cursor.value && this.cursor.from <= line.from) {\n      if (this.cursor.from == line.from) this.localMarkers.push(this.cursor.value);\n      this.cursor.next();\n    }\n    let forLine = this.gutter.config.lineMarker(view, line, this.localMarkers);\n    if (forLine) this.localMarkers.unshift(forLine);\n    let gutter = this.gutter;\n    if (this.localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n    let above = line.top - this.height;\n    if (this.i == gutter.elements.length) {\n      let newElt = new GutterElement(view, line.height, above, this.localMarkers);\n      gutter.elements.push(newElt);\n      gutter.dom.appendChild(newElt.dom);\n    } else {\n      let markers = this.localMarkers, elt = gutter.elements[this.i];\n      if (sameMarkers(markers, elt.markers)) {\n        markers = elt.markers;\n        this.localMarkers.length = 0;\n      }\n      elt.update(view, line.height, above, markers);\n    }\n    this.height = line.bottom;\n    this.i++;\n  }\n  finish() {\n    let gutter = this.gutter;\n    while (gutter.elements.length > this.i) gutter.dom.removeChild(gutter.elements.pop().dom);\n  }\n}\nclass SingleGutterView {\n  constructor(view, config) {\n    this.view = view;\n    this.config = config;\n    this.elements = [];\n    this.spacer = null;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n    for (let prop in config.domEventHandlers) {\n      this.dom.addEventListener(prop, event => {\n        let line = view.visualLineAtHeight(event.clientY, view.contentDOM.getBoundingClientRect().top);\n        if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n      });\n    }\n    this.markers = asArray(config.markers(view));\n    if (config.initialSpacer) {\n      this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);\n      this.dom.appendChild(this.spacer.dom);\n      this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n    }\n  }\n  update(update) {\n    let prevMarkers = this.markers;\n    this.markers = asArray(this.config.markers(update.view));\n    if (this.spacer && this.config.updateSpacer) {\n      let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n      if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [updated]);\n    }\n    return this.markers != prevMarkers;\n  }\n}\nclass GutterElement {\n  constructor(view, height, above, markers) {\n    this.height = -1;\n    this.above = 0;\n    this.dom = document.createElement(\"div\");\n    this.update(view, height, above, markers);\n  }\n  update(view, height, above, markers) {\n    if (this.height != height) this.dom.style.height = (this.height = height) + \"px\";\n    if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n    if (this.markers != markers) {\n      this.markers = markers;\n      for (let ch; ch = this.dom.lastChild; ) ch.remove();\n      let cls = \"cm-gutterElement\";\n      for (let m of markers) {\n        let dom = m.toDOM(view);\n        if (dom) this.dom.appendChild(dom);\n        let c = m.elementClass;\n        if (c) cls += \" \" + c;\n      }\n      this.dom.className = cls;\n    }\n  }\n}\nfunction sameMarkers(a, b) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) if (!a[i].compare(b[i])) return false;\n  return true;\n}\nconst lineNumberMarkers = state_1.Facet.define();\nconst lineNumberConfig = state_1.Facet.define({\n  combine(values) {\n    return state_1.combineConfig(values, {\n      formatNumber: String,\n      domEventHandlers: {}\n    }, {\n      domEventHandlers(a, b) {\n        let result = Object.assign({}, a);\n        for (let event in b) {\n          let exists = result[event], add = b[event];\n          result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n        }\n        return result;\n      }\n    });\n  }\n});\nclass NumberMarker extends GutterMarker {\n  constructor(number) {\n    super();\n    this.number = number;\n  }\n  eq(other) {\n    return this.number == other.number;\n  }\n  toDOM() {\n    return document.createTextNode(this.number);\n  }\n}\nfunction formatNumber(view, number) {\n  return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = gutter({\n  class: \"cm-lineNumbers\",\n  markers(view) {\n    return view.state.facet(lineNumberMarkers);\n  },\n  lineMarker(view, line, others) {\n    if (others.length) return null;\n    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n  },\n  initialSpacer(view) {\n    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n  },\n  updateSpacer(spacer, update) {\n    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n    return max == spacer.number ? spacer : new NumberMarker(max);\n  }\n});\nfunction lineNumbers(config = {}) {\n  return [lineNumberConfig.of(config), lineNumberGutter];\n}\nfunction maxLineNumber(lines) {\n  let last = 9;\n  while (last < lines) last = last * 10 + 9;\n  return last;\n}\nexports.GutterMarker = GutterMarker;\nexports.gutter = gutter;\nexports.gutters = gutters;\nexports.lineNumberMarkers = lineNumberMarkers;\nexports.lineNumbers = lineNumbers;\n"}