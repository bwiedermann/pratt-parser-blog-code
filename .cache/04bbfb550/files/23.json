{"contents":"exports.__esModule = true;\nvar state_1 = __fusereq(16);\nvar text_1 = __fusereq(35);\nvar view_1 = __fusereq(18);\nvar matchbrackets_1 = __fusereq(24);\nvar language_1 = __fusereq(21);\nvar lezer_tree_1 = __fusereq(34);\nfunction updateSel(sel, by) {\n  return state_1.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n  return state.update({\n    selection,\n    scrollIntoView: true,\n    annotations: state_1.Transaction.userEvent.of(\"keyboardselection\")\n  });\n}\nfunction moveSel({state, dispatch}, how) {\n  let selection = updateSel(state.selection, how);\n  if (selection.eq(state.selection)) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\nfunction rangeEnd(range, forward) {\n  return state_1.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nconst cursorCharLeft = view => cursorByChar(view, view.textDirection != view_1.Direction.LTR);\nconst cursorCharRight = view => cursorByChar(view, view.textDirection == view_1.Direction.LTR);\nconst cursorCharForward = view => cursorByChar(view, true);\nconst cursorCharBackward = view => cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\nconst cursorGroupLeft = view => cursorByGroup(view, view.textDirection != view_1.Direction.LTR);\nconst cursorGroupRight = view => cursorByGroup(view, view.textDirection == view_1.Direction.LTR);\nconst cursorGroupForward = view => cursorByGroup(view, true);\nconst cursorGroupBackward = view => cursorByGroup(view, false);\nfunction interestingNode(state, node, bracketProp) {\n  if (node.type.prop(bracketProp)) return true;\n  let len = node.to - node.from;\n  return len && (len > 2 || (/[^\\s,.;:]/).test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n  let pos = language_1.syntaxTree(state).resolve(start.head);\n  let bracketProp = forward ? lezer_tree_1.NodeProp.closedBy : lezer_tree_1.NodeProp.openedBy;\n  for (let at = start.head; ; ) {\n    let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n    if (!next) break;\n    if (interestingNode(state, next, bracketProp)) pos = next; else at = forward ? next.to : next.from;\n  }\n  let bracket = pos.type.prop(bracketProp), match, newPos;\n  if (bracket && (match = forward ? matchbrackets_1.matchBrackets(state, pos.from, 1) : matchbrackets_1.matchBrackets(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from; else newPos = forward ? pos.to : pos.from;\n  return state_1.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection != view_1.Direction.LTR));\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection == view_1.Direction.LTR));\nfunction cursorByLine(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveVertically(range, forward) : rangeEnd(range, forward));\n}\nconst cursorLineUp = view => cursorByLine(view, false);\nconst cursorLineDown = view => cursorByLine(view, true);\nfunction cursorByPage(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveVertically(range, forward, view.dom.clientHeight) : rangeEnd(range, forward));\n}\nconst cursorPageUp = view => cursorByPage(view, false);\nconst cursorPageDown = view => cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n  let line = view.visualLineAt(start.head), moved = view.moveToLineBoundary(start, forward);\n  if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n  if (!forward && moved.head == line.from && line.length) {\n    let space = (/^\\s*/).exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n    if (space && start.head != line.from + space) moved = state_1.EditorSelection.cursor(line.from + space);\n  }\n  return moved;\n}\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\nconst cursorLineStart = view => moveSel(view, range => state_1.EditorSelection.cursor(view.visualLineAt(range.head).from, 1));\nconst cursorLineEnd = view => moveSel(view, range => state_1.EditorSelection.cursor(view.visualLineAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n  let found = false, selection = updateSel(state.selection, range => {\n    let matching = matchbrackets_1.matchBrackets(state, range.head, -1) || matchbrackets_1.matchBrackets(state, range.head, 1) || range.head > 0 && matchbrackets_1.matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchbrackets_1.matchBrackets(state, range.head + 1, -1);\n    if (!matching || !matching.end) return range;\n    found = true;\n    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n    return extend ? state_1.EditorSelection.range(range.anchor, head) : state_1.EditorSelection.cursor(head);\n  });\n  if (!found) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\nconst cursorMatchingBracket = ({state, dispatch}) => toMatchingBracket(state, dispatch, false);\nconst selectMatchingBracket = ({state, dispatch}) => toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n  let selection = updateSel(view.state.selection, range => {\n    let head = how(range);\n    return state_1.EditorSelection.range(range.anchor, head.head, head.goalColumn);\n  });\n  if (selection.eq(view.state.selection)) return false;\n  view.dispatch(setSel(view.state, selection));\n  return true;\n}\nfunction selectByChar(view, forward) {\n  return extendSel(view, range => view.moveByChar(range, forward));\n}\nconst selectCharLeft = view => selectByChar(view, view.textDirection != view_1.Direction.LTR);\nconst selectCharRight = view => selectByChar(view, view.textDirection == view_1.Direction.LTR);\nconst selectCharForward = view => selectByChar(view, true);\nconst selectCharBackward = view => selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n  return extendSel(view, range => view.moveByGroup(range, forward));\n}\nconst selectGroupLeft = view => selectByGroup(view, view.textDirection != view_1.Direction.LTR);\nconst selectGroupRight = view => selectByGroup(view, view.textDirection == view_1.Direction.LTR);\nconst selectGroupForward = view => selectByGroup(view, true);\nconst selectGroupBackward = view => selectByGroup(view, false);\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection != view_1.Direction.LTR));\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection == view_1.Direction.LTR));\nfunction selectByLine(view, forward) {\n  return extendSel(view, range => view.moveVertically(range, forward));\n}\nconst selectLineUp = view => selectByLine(view, false);\nconst selectLineDown = view => selectByLine(view, true);\nfunction selectByPage(view, forward) {\n  return extendSel(view, range => view.moveVertically(range, forward, view.dom.clientHeight));\n}\nconst selectPageUp = view => selectByPage(view, false);\nconst selectPageDown = view => selectByPage(view, true);\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\nconst selectLineStart = view => extendSel(view, range => state_1.EditorSelection.cursor(view.visualLineAt(range.head).from));\nconst selectLineEnd = view => extendSel(view, range => state_1.EditorSelection.cursor(view.visualLineAt(range.head).to));\nconst cursorDocStart = ({state, dispatch}) => {\n  dispatch(setSel(state, {\n    anchor: 0\n  }));\n  return true;\n};\nconst cursorDocEnd = ({state, dispatch}) => {\n  dispatch(setSel(state, {\n    anchor: state.doc.length\n  }));\n  return true;\n};\nconst selectDocStart = ({state, dispatch}) => {\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: 0\n  }));\n  return true;\n};\nconst selectDocEnd = ({state, dispatch}) => {\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: state.doc.length\n  }));\n  return true;\n};\nconst selectAll = ({state, dispatch}) => {\n  dispatch(state.update({\n    selection: {\n      anchor: 0,\n      head: state.doc.length\n    },\n    annotations: state_1.Transaction.userEvent.of(\"keyboardselection\")\n  }));\n  return true;\n};\nconst selectLine = ({state, dispatch}) => {\n  let ranges = selectedLineBlocks(state).map(({from, to}) => state_1.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n  dispatch(state.update({\n    selection: state_1.EditorSelection.create(ranges),\n    annotations: state_1.Transaction.userEvent.of(\"keyboardselection\")\n  }));\n  return true;\n};\nconst selectParentSyntax = ({state, dispatch}) => {\n  let selection = updateSel(state.selection, range => {\n    var _a;\n    let context = language_1.syntaxTree(state).resolve(range.head, 1);\n    while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent))) context = context.parent;\n    return state_1.EditorSelection.range(context.to, context.from);\n  });\n  dispatch(setSel(state, selection));\n  return true;\n};\nconst simplifySelection = ({state, dispatch}) => {\n  let cur = state.selection, selection = null;\n  if (cur.ranges.length > 1) selection = state_1.EditorSelection.create([cur.main]); else if (!cur.main.empty) selection = state_1.EditorSelection.create([state_1.EditorSelection.cursor(cur.main.head)]);\n  if (!selection) return false;\n  dispatch(setSel(state, selection));\n  return true;\n};\nfunction deleteBy({state, dispatch}, by) {\n  let changes = state.changeByRange(range => {\n    let {from, to} = range;\n    if (from == to) {\n      let towards = by(from);\n      from = Math.min(from, towards);\n      to = Math.max(to, towards);\n    }\n    return from == to ? {\n      range\n    } : {\n      changes: {\n        from,\n        to\n      },\n      range: state_1.EditorSelection.cursor(from)\n    };\n  });\n  if (changes.changes.empty) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    annotations: state_1.Transaction.userEvent.of(\"delete\")\n  }));\n  return true;\n}\nconst deleteByChar = (target, forward, codePoint) => deleteBy(target, pos => {\n  let {state} = target, line = state.doc.lineAt(pos), before;\n  if (!forward && pos > line.from && pos < line.from + 200 && !(/[^ \\t]/).test(before = line.text.slice(0, pos - line.from))) {\n    if (before[before.length - 1] == \"\\t\") return pos - 1;\n    let col = text_1.countColumn(before, 0, state.tabSize), drop = col % language_1.getIndentUnit(state) || language_1.getIndentUnit(state);\n    for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++) pos--;\n    return pos;\n  }\n  let targetPos;\n  if (codePoint) {\n    let next = line.text.slice(pos - line.from + (forward ? 0 : -2), pos - line.from + (forward ? 2 : 0));\n    let size = next ? text_1.codePointSize(text_1.codePointAt(next, 0)) : 1;\n    targetPos = forward ? Math.min(state.doc.length, pos + size) : Math.max(0, pos - size);\n  } else {\n    targetPos = text_1.findClusterBreak(line.text, pos - line.from, forward) + line.from;\n  }\n  if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;\n  return targetPos;\n});\nconst deleteCodePointBackward = view => deleteByChar(view, false, true);\nconst deleteCodePointForward = view => deleteByChar(view, true, true);\nconst deleteCharBackward = view => deleteByChar(view, false, false);\nconst deleteCharForward = view => deleteByChar(view, true, false);\nconst deleteByGroup = (target, forward) => deleteBy(target, start => {\n  let pos = start, {state} = target, line = state.doc.lineAt(pos);\n  let categorize = state.charCategorizer(pos);\n  for (let cat = null; ; ) {\n    if (pos == (forward ? line.to : line.from)) {\n      if (pos == start && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n      break;\n    }\n    let next = text_1.findClusterBreak(line.text, pos - line.from, forward) + line.from;\n    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n    let nextCat = categorize(nextChar);\n    if (cat != null && nextCat != cat) break;\n    if (nextChar != \" \" || pos != start) cat = nextCat;\n    pos = next;\n  }\n  return pos;\n});\nconst deleteGroupBackward = target => deleteByGroup(target, false);\nconst deleteGroupForward = target => deleteByGroup(target, true);\nconst deleteToLineEnd = view => deleteBy(view, pos => {\n  let lineEnd = view.visualLineAt(pos).to;\n  if (pos < lineEnd) return lineEnd;\n  return Math.min(view.state.doc.length, pos + 1);\n});\nconst deleteTrailingWhitespace = ({state, dispatch}) => {\n  let changes = [];\n  for (let pos = 0, prev = \"\", iter = state.doc.iter(); ; ) {\n    iter.next();\n    if (iter.lineBreak || iter.done) {\n      let trailing = prev.search(/\\s+$/);\n      if (trailing > -1) changes.push({\n        from: pos - (prev.length - trailing),\n        to: pos\n      });\n      if (iter.done) break;\n      prev = \"\";\n    } else {\n      prev = iter.value;\n    }\n    pos += iter.value.length;\n  }\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes\n  }));\n  return true;\n};\nconst splitLine = ({state, dispatch}) => {\n  let changes = state.changeByRange(range => {\n    return {\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: text_1.Text.of([\"\", \"\"])\n      },\n      range: state_1.EditorSelection.cursor(range.from)\n    };\n  });\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    annotations: state_1.Transaction.userEvent.of(\"input\")\n  }));\n  return true;\n};\nconst transposeChars = ({state, dispatch}) => {\n  let changes = state.changeByRange(range => {\n    if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n      range\n    };\n    let pos = range.from, line = state.doc.lineAt(pos);\n    let from = pos == line.from ? pos - 1 : text_1.findClusterBreak(line.text, pos - line.from, false) + line.from;\n    let to = pos == line.to ? pos + 1 : text_1.findClusterBreak(line.text, pos - line.from, true) + line.from;\n    return {\n      changes: {\n        from,\n        to,\n        insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n      },\n      range: state_1.EditorSelection.cursor(to)\n    };\n  });\n  if (changes.changes.empty) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true\n  }));\n  return true;\n};\nfunction selectedLineBlocks(state) {\n  let blocks = [], upto = -1;\n  for (let range of state.selection.ranges) {\n    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n    if (upto == startLine.number) blocks[blocks.length - 1].to = endLine.to; else blocks.push({\n      from: startLine.from,\n      to: endLine.to\n    });\n    upto = endLine.number;\n  }\n  return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n  let changes = [];\n  for (let block of selectedLineBlocks(state)) {\n    if (forward ? block.to == state.doc.length : block.from == 0) continue;\n    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n    if (forward) changes.push({\n      from: block.to,\n      to: nextLine.to\n    }, {\n      from: block.from,\n      insert: nextLine.text + state.lineBreak\n    }); else changes.push({\n      from: nextLine.from,\n      to: block.from\n    }, {\n      from: block.to,\n      insert: state.lineBreak + nextLine.text\n    });\n  }\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes,\n    scrollIntoView: true\n  }));\n  return true;\n}\nconst moveLineUp = ({state, dispatch}) => moveLine(state, dispatch, false);\nconst moveLineDown = ({state, dispatch}) => moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n  let changes = [];\n  for (let block of selectedLineBlocks(state)) {\n    if (forward) changes.push({\n      from: block.from,\n      insert: state.doc.slice(block.from, block.to) + state.lineBreak\n    }); else changes.push({\n      from: block.to,\n      insert: state.lineBreak + state.doc.slice(block.from, block.to)\n    });\n  }\n  dispatch(state.update({\n    changes,\n    scrollIntoView: true\n  }));\n  return true;\n}\nconst copyLineUp = ({state, dispatch}) => copyLine(state, dispatch, false);\nconst copyLineDown = ({state, dispatch}) => copyLine(state, dispatch, true);\nconst deleteLine = view => {\n  let {state} = view, changes = state.changes(selectedLineBlocks(state).map(({from, to}) => {\n    if (from > 0) from--; else if (to < state.doc.length) to++;\n    return {\n      from,\n      to\n    };\n  }));\n  let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);\n  view.dispatch({\n    changes,\n    selection,\n    scrollIntoView: true\n  });\n  return true;\n};\nconst insertNewline = ({state, dispatch}) => {\n  dispatch(state.update(state.replaceSelection(state.lineBreak), {\n    scrollIntoView: true\n  }));\n  return true;\n};\nfunction isBetweenBrackets(state, pos) {\n  if ((/\\(\\)|\\[\\]|\\{\\}/).test(state.sliceDoc(pos - 1, pos + 1))) return {\n    from: pos,\n    to: pos\n  };\n  let context = language_1.syntaxTree(state).resolve(pos);\n  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(lezer_tree_1.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from) return {\n    from: before.to,\n    to: after.from\n  };\n  return null;\n}\nconst insertNewlineAndIndent = ({state, dispatch}) => {\n  let changes = state.changeByRange(({from, to}) => {\n    let explode = from == to && isBetweenBrackets(state, from);\n    let cx = new language_1.IndentContext(state, {\n      simulateBreak: from,\n      simulateDoubleBreak: !!explode\n    });\n    let indent = language_1.getIndentation(cx, from);\n    if (indent == null) indent = (/^\\s*/).exec(state.doc.lineAt(from).text)[0].length;\n    let line = state.doc.lineAt(from);\n    while (to < line.to && (/\\s/).test(line.text.slice(to - line.from, to + 1 - line.from))) to++;\n    if (explode) ({from, to} = explode); else if (from > line.from && from < line.from + 100 && !(/\\S/).test(line.text.slice(0, from))) from = line.from;\n    let insert = [\"\", language_1.indentString(state, indent)];\n    if (explode) insert.push(language_1.indentString(state, cx.lineIndent(line)));\n    return {\n      changes: {\n        from,\n        to,\n        insert: text_1.Text.of(insert)\n      },\n      range: state_1.EditorSelection.cursor(from + 1 + insert[1].length)\n    };\n  });\n  dispatch(state.update(changes, {\n    scrollIntoView: true\n  }));\n  return true;\n};\nfunction changeBySelectedLine(state, f) {\n  let atLine = -1;\n  return state.changeByRange(range => {\n    let changes = [];\n    for (let pos = range.from; pos <= range.to; ) {\n      let line = state.doc.lineAt(pos);\n      if (line.number > atLine && (range.empty || range.to > line.from)) {\n        f(line, changes, range);\n        atLine = line.number;\n      }\n      pos = line.to + 1;\n    }\n    let changeSet = state.changes(changes);\n    return {\n      changes,\n      range: state_1.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n    };\n  });\n}\nconst indentSelection = ({state, dispatch}) => {\n  let updated = Object.create(null);\n  let context = new language_1.IndentContext(state, {\n    overrideIndentation: start => {\n      let found = updated[start];\n      return found == null ? -1 : found;\n    }\n  });\n  let changes = changeBySelectedLine(state, (line, changes, range) => {\n    let indent = language_1.getIndentation(context, line.from);\n    if (indent == null) return;\n    let cur = (/^\\s*/).exec(line.text)[0];\n    let norm = language_1.indentString(state, indent);\n    if (cur != norm || range.from < line.from + cur.length) {\n      updated[line.from] = indent;\n      changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n  });\n  if (!changes.changes.empty) dispatch(state.update(changes));\n  return true;\n};\nconst indentMore = ({state, dispatch}) => {\n  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n    changes.push({\n      from: line.from,\n      insert: state.facet(language_1.indentUnit)\n    });\n  })));\n  return true;\n};\nconst indentLess = ({state, dispatch}) => {\n  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n    let space = (/^\\s*/).exec(line.text)[0];\n    if (!space) return;\n    let col = text_1.countColumn(space, 0, state.tabSize), keep = 0;\n    let insert = language_1.indentString(state, Math.max(0, col - language_1.getIndentUnit(state)));\n    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) keep++;\n    changes.push({\n      from: line.from + keep,\n      to: line.from + space.length,\n      insert: insert.slice(keep)\n    });\n  })));\n  return true;\n};\nconst insertTab = ({state, dispatch}) => {\n  if (state.selection.ranges.some(r => !r.empty)) return indentMore({\n    state,\n    dispatch\n  });\n  dispatch(state.update(state.replaceSelection(\"\\t\"), {\n    scrollIntoView: true,\n    annotations: state_1.Transaction.userEvent.of(\"input\")\n  }));\n  return true;\n};\nconst emacsStyleKeymap = [{\n  key: \"Ctrl-b\",\n  run: cursorCharLeft,\n  shift: selectCharLeft\n}, {\n  key: \"Ctrl-f\",\n  run: cursorCharRight,\n  shift: selectCharRight\n}, {\n  key: \"Ctrl-p\",\n  run: cursorLineUp,\n  shift: selectLineUp\n}, {\n  key: \"Ctrl-n\",\n  run: cursorLineDown,\n  shift: selectLineDown\n}, {\n  key: \"Ctrl-a\",\n  run: cursorLineStart,\n  shift: selectLineStart\n}, {\n  key: \"Ctrl-e\",\n  run: cursorLineEnd,\n  shift: selectLineEnd\n}, {\n  key: \"Ctrl-d\",\n  run: deleteCharForward\n}, {\n  key: \"Ctrl-h\",\n  run: deleteCharBackward\n}, {\n  key: \"Ctrl-k\",\n  run: deleteToLineEnd\n}, {\n  key: \"Alt-d\",\n  run: deleteGroupForward\n}, {\n  key: \"Ctrl-Alt-h\",\n  run: deleteGroupBackward\n}, {\n  key: \"Ctrl-o\",\n  run: splitLine\n}, {\n  key: \"Ctrl-t\",\n  run: transposeChars\n}, {\n  key: \"Alt-f\",\n  run: cursorGroupForward,\n  shift: selectGroupForward\n}, {\n  key: \"Alt-b\",\n  run: cursorGroupBackward,\n  shift: selectGroupBackward\n}, {\n  key: \"Alt-<\",\n  run: cursorDocStart\n}, {\n  key: \"Alt->\",\n  run: cursorDocEnd\n}, {\n  key: \"Ctrl-v\",\n  run: cursorPageDown\n}, {\n  key: \"Alt-v\",\n  run: cursorPageUp\n}];\nconst standardKeymap = [{\n  key: \"ArrowLeft\",\n  run: cursorCharLeft,\n  shift: selectCharLeft\n}, {\n  key: \"Mod-ArrowLeft\",\n  mac: \"Alt-ArrowLeft\",\n  run: cursorGroupLeft,\n  shift: selectGroupLeft\n}, {\n  mac: \"Cmd-ArrowLeft\",\n  run: cursorLineStart,\n  shift: selectLineStart\n}, {\n  key: \"ArrowRight\",\n  run: cursorCharRight,\n  shift: selectCharRight\n}, {\n  key: \"Mod-ArrowRight\",\n  mac: \"Alt-ArrowRight\",\n  run: cursorGroupRight,\n  shift: selectGroupRight\n}, {\n  mac: \"Cmd-ArrowRight\",\n  run: cursorLineEnd,\n  shift: selectLineEnd\n}, {\n  key: \"ArrowUp\",\n  run: cursorLineUp,\n  shift: selectLineUp\n}, {\n  mac: \"Cmd-ArrowUp\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  mac: \"Ctrl-ArrowUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"ArrowDown\",\n  run: cursorLineDown,\n  shift: selectLineDown\n}, {\n  mac: \"Cmd-ArrowDown\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  mac: \"Ctrl-ArrowDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"PageUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"PageDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"Home\",\n  run: cursorLineBoundaryBackward,\n  shift: selectLineBoundaryBackward\n}, {\n  key: \"Mod-Home\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  key: \"End\",\n  run: cursorLineBoundaryForward,\n  shift: selectLineBoundaryForward\n}, {\n  key: \"Mod-End\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  key: \"Enter\",\n  run: insertNewlineAndIndent\n}, {\n  key: \"Mod-a\",\n  run: selectAll\n}, {\n  key: \"Backspace\",\n  run: deleteCodePointBackward\n}, {\n  key: \"Delete\",\n  run: deleteCharForward\n}, {\n  key: \"Mod-Backspace\",\n  mac: \"Alt-Backspace\",\n  run: deleteGroupBackward\n}, {\n  key: \"Mod-Delete\",\n  mac: \"Alt-Delete\",\n  run: deleteGroupForward\n}].concat(emacsStyleKeymap.map(b => ({\n  mac: b.key,\n  run: b.run,\n  shift: b.shift\n})));\nconst defaultKeymap = [{\n  key: \"Alt-ArrowLeft\",\n  mac: \"Ctrl-ArrowLeft\",\n  run: cursorSyntaxLeft,\n  shift: selectSyntaxLeft\n}, {\n  key: \"Alt-ArrowRight\",\n  mac: \"Ctrl-ArrowRight\",\n  run: cursorSyntaxRight,\n  shift: selectSyntaxRight\n}, {\n  key: \"Alt-ArrowUp\",\n  run: moveLineUp\n}, {\n  key: \"Shift-Alt-ArrowUp\",\n  run: copyLineUp\n}, {\n  key: \"Alt-ArrowDown\",\n  run: moveLineDown\n}, {\n  key: \"Shift-Alt-ArrowDown\",\n  run: copyLineDown\n}, {\n  key: \"Escape\",\n  run: simplifySelection\n}, {\n  key: \"Alt-l\",\n  run: selectLine\n}, {\n  key: \"Mod-i\",\n  run: selectParentSyntax\n}, {\n  key: \"Mod-[\",\n  run: indentLess\n}, {\n  key: \"Mod-]\",\n  run: indentMore\n}, {\n  key: \"Mod-Alt-\\\\\",\n  run: indentSelection\n}, {\n  key: \"Shift-Mod-k\",\n  run: deleteLine\n}, {\n  key: \"Shift-Mod-\\\\\",\n  run: cursorMatchingBracket\n}].concat(standardKeymap);\nconst defaultTabBinding = {\n  key: \"Tab\",\n  run: insertTab,\n  shift: indentSelection\n};\nexports.copyLineDown = copyLineDown;\nexports.copyLineUp = copyLineUp;\nexports.cursorCharBackward = cursorCharBackward;\nexports.cursorCharForward = cursorCharForward;\nexports.cursorCharLeft = cursorCharLeft;\nexports.cursorCharRight = cursorCharRight;\nexports.cursorDocEnd = cursorDocEnd;\nexports.cursorDocStart = cursorDocStart;\nexports.cursorGroupBackward = cursorGroupBackward;\nexports.cursorGroupForward = cursorGroupForward;\nexports.cursorGroupLeft = cursorGroupLeft;\nexports.cursorGroupRight = cursorGroupRight;\nexports.cursorLineBoundaryBackward = cursorLineBoundaryBackward;\nexports.cursorLineBoundaryForward = cursorLineBoundaryForward;\nexports.cursorLineDown = cursorLineDown;\nexports.cursorLineEnd = cursorLineEnd;\nexports.cursorLineStart = cursorLineStart;\nexports.cursorLineUp = cursorLineUp;\nexports.cursorMatchingBracket = cursorMatchingBracket;\nexports.cursorPageDown = cursorPageDown;\nexports.cursorPageUp = cursorPageUp;\nexports.cursorSyntaxLeft = cursorSyntaxLeft;\nexports.cursorSyntaxRight = cursorSyntaxRight;\nexports.defaultKeymap = defaultKeymap;\nexports.defaultTabBinding = defaultTabBinding;\nexports.deleteCharBackward = deleteCharBackward;\nexports.deleteCharForward = deleteCharForward;\nexports.deleteCodePointBackward = deleteCodePointBackward;\nexports.deleteCodePointForward = deleteCodePointForward;\nexports.deleteGroupBackward = deleteGroupBackward;\nexports.deleteGroupForward = deleteGroupForward;\nexports.deleteLine = deleteLine;\nexports.deleteToLineEnd = deleteToLineEnd;\nexports.deleteTrailingWhitespace = deleteTrailingWhitespace;\nexports.emacsStyleKeymap = emacsStyleKeymap;\nexports.indentLess = indentLess;\nexports.indentMore = indentMore;\nexports.indentSelection = indentSelection;\nexports.insertNewline = insertNewline;\nexports.insertNewlineAndIndent = insertNewlineAndIndent;\nexports.insertTab = insertTab;\nexports.moveLineDown = moveLineDown;\nexports.moveLineUp = moveLineUp;\nexports.selectAll = selectAll;\nexports.selectCharBackward = selectCharBackward;\nexports.selectCharForward = selectCharForward;\nexports.selectCharLeft = selectCharLeft;\nexports.selectCharRight = selectCharRight;\nexports.selectDocEnd = selectDocEnd;\nexports.selectDocStart = selectDocStart;\nexports.selectGroupBackward = selectGroupBackward;\nexports.selectGroupForward = selectGroupForward;\nexports.selectGroupLeft = selectGroupLeft;\nexports.selectGroupRight = selectGroupRight;\nexports.selectLine = selectLine;\nexports.selectLineBoundaryBackward = selectLineBoundaryBackward;\nexports.selectLineBoundaryForward = selectLineBoundaryForward;\nexports.selectLineDown = selectLineDown;\nexports.selectLineEnd = selectLineEnd;\nexports.selectLineStart = selectLineStart;\nexports.selectLineUp = selectLineUp;\nexports.selectMatchingBracket = selectMatchingBracket;\nexports.selectPageDown = selectPageDown;\nexports.selectPageUp = selectPageUp;\nexports.selectParentSyntax = selectParentSyntax;\nexports.selectSyntaxLeft = selectSyntaxLeft;\nexports.selectSyntaxRight = selectSyntaxRight;\nexports.simplifySelection = simplifySelection;\nexports.splitLine = splitLine;\nexports.standardKeymap = standardKeymap;\nexports.transposeChars = transposeChars;\n"}