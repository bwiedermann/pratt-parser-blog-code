{"contents":"var _1_, _2_;\nvar _3_;\nvar _4_;\nexports.__esModule = true;\nvar findBase_1 = __fusereq(42);\nvar typechecker_1 = __fusereq(14);\nfunction mudCheck(nodes, registeredNodes, dependsMap) {\n  const errors = nodes.map(n => mudCheckNode(n, nodes, registeredNodes, dependsMap));\n  return [].concat(...errors);\n}\nexports.mudCheck = mudCheck;\nfunction mudCheckNode(node, nodes, registeredNodes, dependsMap) {\n  return mudCheckerMap[node.nodeType].mudCheck(node, nodes, registeredNodes, dependsMap);\n}\nclass TypeError {\n  constructor(message, position) {\n    this.message = message;\n    this.position = position;\n  }\n}\nexports.TypeError = TypeError;\nclass MudCheckNumber {\n  mudCheck(node) {\n    return [];\n  }\n}\nclass MudCheckBoolean {\n  mudCheck(node) {\n    return [];\n  }\n}\nclass MudCheckBinary {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    const errors = mudCheckNode(node.left, nodes, registeredNodes, dependsMap).concat(mudCheckNode(node.right, nodes, registeredNodes, dependsMap));\n    if (node.right.outputType.status == 'Def-Undefined' || node.left.outputType.status == 'Def-Undefined') {\n      node.outputType.status = 'Def-Undefined';\n    } else if (node.right.outputType.status == 'Maybe-Undefined' || node.left.outputType.status == 'Maybe-Undefined') {\n      node.outputType.status = 'Maybe-Undefined';\n    } else {\n      node.outputType.status = 'Definitely';\n    }\n    if (node.operator == '|') {\n      let intersection = [];\n      let leftAsserts = node.left.outputType.asserts;\n      let rightAsserts = node.right.outputType.asserts;\n      for (let i = 0; i < leftAsserts.length; i++) {\n        if (rightAsserts.find(e => e == leftAsserts[i])) {\n          intersection.push(leftAsserts[i]);\n        }\n      }\n      node.outputType.asserts = intersection;\n    } else {\n      let leftAsserts = node.left.outputType.asserts;\n      let rightAsserts = node.right.outputType.asserts;\n      let allAsserts = leftAsserts.concat(rightAsserts);\n      node.outputType.asserts = allAsserts;\n    }\n    return errors;\n  }\n}\nclass MudCheckFunction {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    let errors = [];\n    const arg1Errors = mudCheckNode(node.args[0], nodes, registeredNodes, dependsMap);\n    errors = errors.concat(arg1Errors);\n    if (node.args.length > 1) {\n      const arg2Errors = mudCheckNode(node.args[1], nodes, registeredNodes, dependsMap);\n      errors = errors.concat(arg2Errors);\n    }\n    if (node.name == 'IsDefined') {\n      let bases = findBase_1.findBases(node.args[0], dependsMap);\n      node.outputType.asserts = node.outputType.asserts.concat(bases);\n    }\n    const functionName = node.name;\n    if (functionName == 'Sink') {\n      if (node.args[0].outputType.status != 'Definitely') {\n        errors.push(new TypeError(\"User facing content could be undefined.\", node.args[0].pos));\n      }\n    }\n    node.outputType.constType = typechecker_1.builtins[node.name].constType;\n    if (typechecker_1.builtins[functionName].status == \"Variable\") {\n      if (node.args[0].outputType.constType == 'Constant') {\n        if (node.value != undefined) {\n          node.outputType.status = \"Definitely\";\n        } else {\n          node.outputType.status = \"Def-Undefined\";\n          errors.push(new TypeError(\"The result of this operation is undefined.\", node.pos));\n        }\n      } else {\n        node.outputType.status = (_2_ = (_1_ = node.args[0]) === null || _1_ === void 0 ? void 0 : _1_.outputType) === null || _2_ === void 0 ? void 0 : _2_.status;\n      }\n    } else {\n      node.outputType.status = typechecker_1.builtins[functionName].status;\n    }\n    return errors;\n  }\n}\nclass MudCheckChoose {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    let errors = [];\n    const predicate = node.case.predicate;\n    const consequent = node.case.consequent;\n    const otherwise = node.otherwise;\n    const predErrors = mudCheckNode(predicate, nodes, registeredNodes, dependsMap);\n    const consErrors = mudCheckNode(consequent, nodes, registeredNodes, dependsMap);\n    const otherErrors = mudCheckNode(otherwise, nodes, registeredNodes, dependsMap);\n    errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\n    let consDef = false;\n    let otherDef = false;\n    if (otherwise.outputType.status == 'Definitely') {\n      otherDef = true;\n    }\n    consDef = handleCheck(consequent, dependsMap, predicate.outputType.asserts);\n    if (((_3_ = consequent) === null || _3_ === void 0 ? void 0 : _3_.outputType.status) == 'Definitely') {\n      consDef = true;\n    }\n    if (consDef && otherDef) {\n      node.outputType.status = 'Definitely';\n    }\n    return errors;\n  }\n}\nclass MudCheckVariable {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    let errors = [];\n    const assignmentErrors = mudCheckNode(node.assignment, nodes, registeredNodes, dependsMap);\n    errors = errors.concat(assignmentErrors);\n    node.outputType.status = node.assignment.outputType.status;\n    dependsMap[node.nodeId] = findBase_1.findBases(node.assignment, dependsMap);\n    return errors;\n  }\n}\nclass MudCheckIdentifier {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    let errors = [];\n    let valueNode = registeredNodes[node.assignmentId].assignment;\n    if (valueNode == undefined) {\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\n    } else {\n      node.outputType.status = valueNode.outputType.status;\n    }\n    return errors;\n  }\n}\nconst mudCheckerMap = {\n  'Number': new MudCheckNumber(),\n  'Boolean': new MudCheckBoolean(),\n  'BinaryOperation': new MudCheckBinary(),\n  'Function': new MudCheckFunction(),\n  'Choose': new MudCheckChoose(),\n  'VariableAssignment': new MudCheckVariable(),\n  'Identifier': new MudCheckIdentifier()\n};\nfunction handleCheck(consequent, dependsMap, asserts) {\n  let contained = true;\n  if (((_4_ = consequent) === null || _4_ === void 0 ? void 0 : _4_.nodeType) == 'Choose') {\n    let consAsserts = consequent.case.predicate.outputType.asserts;\n    let consConsContained = handleCheck(consequent.case.consequent, dependsMap, asserts.concat(consAsserts));\n    let consOtherContained = handleCheck(consequent.otherwise, dependsMap, asserts);\n    if (!(consConsContained && consOtherContained)) {\n      contained = false;\n    }\n  } else {\n    let consBases = findBase_1.findBases(consequent, dependsMap);\n    for (let i = 0; i < consBases.length; i++) {\n      if (!asserts.find(e => e == consBases[i])) {\n        contained = false;\n      }\n    }\n  }\n  return contained;\n}\n","sourceMap":"{\"version\":3,\"sources\":[\"src/mudChecker.ts\"],\"names\":[\"nodes\",\"registeredNodes\",\"dependsMap\",\"errors\",\"map\",\"n\",\"mudCheckNode\",\"concat\",\"node\",\"mudCheckerMap\",\"nodeType\",\"mudCheck\",\"constructor\",\"message\",\"position\",\"left\",\"right\",\"outputType\",\"status\",\"operator\",\"intersection\",\"leftAsserts\",\"asserts\",\"rightAsserts\",\"i\",\"length\",\"find\",\"e\",\"push\",\"allAsserts\",\"arg1Errors\",\"args\",\"arg2Errors\",\"name\",\"bases\",\"findBase_1\",\"functionName\",\"TypeError\",\"pos\",\"constType\",\"typechecker_1\",\"value\",\"undefined\",\"predicate\",\"case\",\"consequent\",\"otherwise\",\"predErrors\",\"consErrors\",\"otherErrors\",\"consDef\",\"otherDef\",\"handleCheck\",\"assignmentErrors\",\"assignment\",\"nodeId\",\"valueNode\",\"assignmentId\",\"MudCheckNumber\",\"MudCheckBoolean\",\"MudCheckBinary\",\"MudCheckFunction\",\"MudCheckChoose\",\"MudCheckVariable\",\"MudCheckIdentifier\",\"contained\",\"consAsserts\",\"consConsContained\",\"consOtherContained\",\"consBases\"],\"mappings\":\"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\",\"sourcesContent\":[\"import {Position} from './position';\\nimport * as AST from './ast';\\nimport {findBases} from './findBase';\\nimport {builtins} from './typechecker';\\nimport * as AnalyzedTree from './analyzedTree';\\n\\n/*\\n  The function mudCheck manipulates the status of each node's outputType.\\n  It produces type errors based on that status.\\n  For example, it will produce a warning when the author tries to use \\n  a maybe-undefined node in a Sink function, which is user-facing.\\n  It also produces a warning when the author tries to compute a \\n  definitely undefined operation (e.g. Inverse(0)).\\n*/\\n\\nexport function mudCheck(nodes: AnalyzedTree.AnalyzedNode[], \\n                        registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\\n                        dependsMap: {[key: string]: string[]}): TypeError[] {\\n  const errors = nodes.map(n => mudCheckNode(n, nodes, registeredNodes, dependsMap));\\n  return ([] as TypeError[]).concat(...errors);\\n}\\n\\nfunction mudCheckNode(node: AnalyzedTree.AnalyzedNode, \\n                    nodes: AnalyzedTree.AnalyzedNode[], \\n                    registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\\n                    dependsMap: {[key: string]: string[]}): TypeError[] {\\n  return mudCheckerMap[node.nodeType].mudCheck(node, nodes, registeredNodes, dependsMap);\\n}\\n\\nexport class TypeError {\\n  constructor(public message: string, public position: Position) {}\\n}\\n\\nexport interface MudChecker {\\n  mudCheck(node: AnalyzedTree.AnalyzedNode, \\n          nodes: AnalyzedTree.AnalyzedNode[], \\n          registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\\n          dependsMap: {[key: string]: string[]}): TypeError[];\\n}\\n\\n// Numbers are always defined.\\nclass MudCheckNumber implements MudChecker {\\n  mudCheck(node: AnalyzedTree.NumberNode): TypeError[] {\\n    return [];\\n  }\\n}\\n\\n// Booleans are always defined.\\nclass MudCheckBoolean implements MudChecker {\\n    mudCheck(node: AnalyzedTree.BooleanNode): TypeError[] {\\n    return [];\\n  }\\n}\\n\\n// Binary operations must take into account their operands' statuses when determining their own.\\nclass MudCheckBinary implements MudChecker {\\n    mudCheck(node: AnalyzedTree.BinaryOperationNode, \\n            nodes: AnalyzedTree.AnalyzedNode[], \\n            registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n        \\n        // recursively mud-check the left and right operands\\n        const errors: TypeError[] = mudCheckNode(node.left, nodes, registeredNodes, dependsMap)\\n        .concat(mudCheckNode(node.right, nodes, registeredNodes, dependsMap));\\n\\n        // Update the output type of the node, based on the outputType of its operands\\n        if (node.right.outputType.status == 'Def-Undefined' || node.left.outputType.status == 'Def-Undefined') {\\n            node.outputType.status = 'Def-Undefined';\\n        }\\n        else if (node.right.outputType.status == 'Maybe-Undefined' || node.left.outputType.status == 'Maybe-Undefined') {\\n            node.outputType.status = 'Maybe-Undefined';\\n        } else {\\n            node.outputType.status = 'Definitely'\\n        }\\n\\n        // Each ORed binary operation will assert the intersection of its operands' assertions\\n        if (node.operator == '|') {\\n          let intersection = [];\\n          let leftAsserts = node.left.outputType.asserts;\\n          let rightAsserts = node.right.outputType.asserts;\\n          for (let i = 0; i < leftAsserts.length; i++) {\\n            if (rightAsserts.find(e => e == leftAsserts[i])) {\\n              intersection.push(leftAsserts[i]);\\n            }\\n          }\\n          node.outputType.asserts = intersection;\\n        }\\n        // Each ANDed binary operation will assert the union of its operands' assertions\\n        else {\\n          let leftAsserts = node.left.outputType.asserts;\\n          let rightAsserts = node.right.outputType.asserts;\\n          let allAsserts = leftAsserts.concat(rightAsserts);\\n\\n          node.outputType.asserts = allAsserts;\\n        }\\n\\n        return errors;\\n    }\\n}\\n\\n// The status of a function is determined by its argument and/or its status as defined\\n// in the builtins dictionary.\\nclass MudCheckFunction implements MudChecker {\\n    mudCheck(node: AnalyzedTree.FunctionNode, \\n            nodes: AnalyzedTree.AnalyzedNode[], \\n            registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n        let errors: TypeError[] = [];\\n\\n        // First mud-check the argument(s)\\n        const arg1Errors = mudCheckNode(node.args[0], nodes, registeredNodes, dependsMap);\\n        errors = errors.concat(arg1Errors);\\n        if (node.args.length > 1) {\\n          const arg2Errors = mudCheckNode(node.args[1], nodes, registeredNodes, dependsMap);\\n          errors = errors.concat(arg2Errors);\\n        }\\n\\n        // IsDefined is the only function that asserts anything\\n        // It asserts its argument\\n        if (node.name == 'IsDefined') {\\n          let bases = findBases(node.args[0], dependsMap);\\n          node.outputType.asserts = node.outputType.asserts.concat(bases);\\n        }\\n\\n        const functionName = node.name\\n        \\n        // If sink \\\"node\\\" takes in possibly undefined values, warn the author\\n        if (functionName == 'Sink') {\\n          // a sink has one argument\\n          if (node.args[0].outputType.status != 'Definitely') {\\n              errors.push(new TypeError(\\\"User facing content could be undefined.\\\", node.args[0].pos));\\n          }\\n        }\\n\\n        // The contstant-ness of a function is whatever is defined in builtins\\n        node.outputType.constType = builtins[node.name].constType;\\n        \\n        // If the function is variable, then its status depends on its argument's status\\n        if (builtins[functionName].status == \\\"Variable\\\") {\\n          if (node.args[0].outputType.constType == 'Constant') {\\n            // If the result is undefined, warn the author\\n            if (node.value != undefined) {\\n              node.outputType.status = \\\"Definitely\\\";\\n            } else {\\n              node.outputType.status = \\\"Def-Undefined\\\";\\n              errors.push(new TypeError(\\\"The result of this operation is undefined.\\\", node.pos));\\n            }\\n          } else {\\n            node.outputType.status = node.args[0]?.outputType?.status;\\n          }\\n        }\\n        else {\\n          node.outputType.status = builtins[functionName].status;\\n        }\\n\\n        return errors;\\n    }\\n}\\n\\n// The status of a choose node is determined by the status of the consequent\\n// given what the predicate asserts and the status of the otherwise statement\\nclass MudCheckChoose implements MudChecker {\\n    mudCheck(node: AnalyzedTree.ChooseNode, \\n            nodes: AnalyzedTree.AnalyzedNode[], \\n            registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n        let errors: TypeError[] = [];\\n\\n        const predicate = node.case.predicate;\\n        const consequent = node.case.consequent;\\n        const otherwise = node.otherwise;\\n\\n        // First typecheck the inner nodes\\n        const predErrors = mudCheckNode(predicate, nodes, registeredNodes, dependsMap);\\n        const consErrors = mudCheckNode(consequent, nodes, registeredNodes, dependsMap);\\n        const otherErrors = mudCheckNode(otherwise, nodes, registeredNodes, dependsMap);\\n        errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\\n\\n        // DEFAULT status is maybe-undefined, hence default false values\\n        let consDef = false;\\n        let otherDef = false;\\n\\n        if (otherwise.outputType.status == 'Definitely') {\\n          otherDef = true;\\n        }\\n\\n        // Check the definitive status of the consequent using the predicates asserts\\n        // NOTE: only binary operations and IsDefined functions have non-empty assert fields\\n        consDef = handleCheck(consequent, dependsMap, predicate.outputType.asserts);\\n\\n        if (consequent?.outputType.status == 'Definitely') {\\n          consDef = true;\\n        }\\n\\n        if (consDef && otherDef) {\\n          node.outputType.status = 'Definitely';\\n        }\\n\\n        return errors;\\n    }\\n}\\n\\n// The status of a variable assignment is determined by the status of its assignment\\nclass MudCheckVariable implements MudChecker {\\n    mudCheck(node: AnalyzedTree.VariableAssignmentNode, \\n            nodes: AnalyzedTree.AnalyzedNode[], \\n            registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n    let errors: TypeError[] = [];\\n\\n    // First mud-check the assignment node\\n    const assignmentErrors = mudCheckNode(node.assignment, nodes, registeredNodes, dependsMap);\\n    errors = errors.concat(assignmentErrors);\\n\\n    // Set variable assignment node output type to the same as its assignment\\n    node.outputType.status = node.assignment.outputType.status;\\n\\n    // Update the dependsMap to hold the bases of this new variable\\n    dependsMap[node.nodeId] = findBases(node.assignment, dependsMap);\\n\\n    return errors;\\n  }\\n}\\n\\n// The status of an identifier is determined by the status of its assignment,\\n// given in registered nodes\\nclass MudCheckIdentifier implements MudChecker {\\n    mudCheck(node: AnalyzedTree.IdentifierNode, \\n            nodes: AnalyzedTree.AnalyzedNode[], \\n            registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n    let errors: TypeError[] = [];\\n\\n    // Grab the node the identifier was previously assigned to\\n    let valueNode = registeredNodes[node.assignmentId].assignment;\\n\\n    // If this assignmentId is not found in the AST, throw an error\\n    if (valueNode == undefined) {\\n      errors.push(new TypeError(\\\"This variable doesn't have a value\\\", node.pos));\\n    } else {\\n      // If we found the assignment node, set the output type of the identifier\\n      node.outputType.status = valueNode.outputType.status;\\n    }\\n\\n    return errors;\\n  }\\n}\\n\\n\\nconst mudCheckerMap: Partial<{[K in AST.NodeType]: MudChecker}> = {\\n  'Number' : new MudCheckNumber(),\\n  'Boolean' : new MudCheckBoolean(),\\n  'BinaryOperation' : new MudCheckBinary(),\\n  'Function' : new MudCheckFunction(),\\n  'Choose': new MudCheckChoose(),\\n  'VariableAssignment': new MudCheckVariable(),\\n  'Identifier': new MudCheckIdentifier()\\n}\\n\\n// Given the consequent to a choose node, return true if the given list of asserts\\n// includes all of the bases of that consequent\\nfunction handleCheck(consequent: AnalyzedTree.AnalyzedNode,\\n                    dependsMap: {[key: string]: string[]},\\n                    asserts: string[]): boolean {\\n  let contained = true;\\n\\n  // If the given consequent is a choose node, recursively check the its consequent and otherwise statements\\n  if (consequent?.nodeType == 'Choose') {\\n    // We need to check each statement's bases separately in order to exclude\\n    // the next predicate's asserts in the next otherwise\\n    // while including the current asserts in both\\n    let consAsserts = consequent.case.predicate.outputType.asserts;\\n    let consConsContained = handleCheck(consequent.case.consequent, dependsMap, asserts.concat(consAsserts));\\n    let consOtherContained = handleCheck(consequent.otherwise, dependsMap, asserts);\\n\\n    // If either the next consequent or otherwise statements aren't covered by their asserts,\\n    // the current consequent is also not covered\\n    if (!(consConsContained && consOtherContained)) {\\n      contained = false;\\n    }\\n\\n  } else {\\n    let consBases = findBases(consequent, dependsMap);\\n\\n    // Ensure that every base is in the given asserts list\\n    for (let i = 0; i < consBases.length; i++) {\\n      if (!asserts.find(e => e == consBases[i])) {\\n        contained = false;\\n      }\\n    }\\n  }\\n\\n  return contained;\\n}\\n\\n\\n\"]}"}