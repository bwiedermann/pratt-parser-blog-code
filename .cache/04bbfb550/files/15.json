{"contents":"var _1_, _2_;\nvar _3_, _4_;\nvar _5_, _6_;\nvar _7_, _8_;\nvar _9_, _10_;\nvar _11_, _12_;\nvar _13_;\nexports.__esModule = true;\nvar findBase_1 = __fusereq(42);\nfunction mudCheck(nodes, registeredNodes, dependsMap, assertMap) {\n  const errors = nodes.map(n => mudCheckNode(n, nodes, registeredNodes, dependsMap, assertMap));\n  return [].concat(...errors);\n}\nexports.mudCheck = mudCheck;\nfunction mudCheckNode(node, nodes, registeredNodes, dependsMap, assertMap) {\n  return mudCheckerMap[node.nodeType].mudCheck(node, nodes, registeredNodes, dependsMap, assertMap);\n}\nclass TypeError {\n  constructor(message, position) {\n    this.message = message;\n    this.position = position;\n  }\n}\nexports.TypeError = TypeError;\nclass MudCheckNumber {\n  mudCheck(node) {\n    return [];\n  }\n}\nclass MudCheckBoolean {\n  mudCheck(node) {\n    return [];\n  }\n}\nclass MudCheckBinary {\n  mudCheck(node, nodes, registeredNodes, dependsMap, assertMap) {\n    const errors = mudCheckNode(node.left, nodes, registeredNodes, dependsMap, assertMap).concat(mudCheckNode(node.right, nodes, registeredNodes, dependsMap, assertMap));\n    if (((_2_ = (_1_ = node.right) === null || _1_ === void 0 ? void 0 : _1_.outputType) === null || _2_ === void 0 ? void 0 : _2_.status) == 'Maybe-Undefined' || ((_4_ = (_3_ = node.left) === null || _3_ === void 0 ? void 0 : _3_.outputType) === null || _4_ === void 0 ? void 0 : _4_.status) == 'Maybe-Undefined') {\n      node.outputType = {\n        status: 'Maybe-Undefined',\n        valueType: (_6_ = (_5_ = node.left) === null || _5_ === void 0 ? void 0 : _5_.outputType) === null || _6_ === void 0 ? void 0 : _6_.valueType\n      };\n    } else {\n      node.outputType = {\n        status: 'Definitely',\n        valueType: (_8_ = (_7_ = node.left) === null || _7_ === void 0 ? void 0 : _7_.outputType) === null || _8_ === void 0 ? void 0 : _8_.valueType\n      };\n    }\n    return errors;\n  }\n}\nclass MudCheckFunction {\n  mudCheck(node, nodes, registeredNodes, dependsMap, assertMap) {\n    let errors = [];\n    if (node.name == 'Sink') {\n      assertMap = [];\n    }\n    const arg1Errors = mudCheckNode(node.args[0], nodes, registeredNodes, dependsMap, assertMap);\n    errors = errors.concat(arg1Errors);\n    if (node.args.length > 1) {\n      const arg2Errors = mudCheckNode(node.args[1], nodes, registeredNodes, dependsMap, assertMap);\n      errors = errors.concat(arg2Errors);\n    }\n    const functionName = node.name;\n    const argType = builtins[functionName].inputType;\n    const returnType = builtins[functionName].resultType;\n    if (functionName == 'Sink') {\n      if (((_10_ = (_9_ = node.args[0]) === null || _9_ === void 0 ? void 0 : _9_.outputType) === null || _10_ === void 0 ? void 0 : _10_.status) == 'Maybe-Undefined') {\n        errors.push(new TypeError(\"User facing content could be undefined.\", node.args[0].pos));\n      }\n    }\n    if (((_12_ = (_11_ = node.args[0]) === null || _11_ === void 0 ? void 0 : _11_.outputType) === null || _12_ === void 0 ? void 0 : _12_.status) == 'Maybe-Undefined' || functionName == 'Input') {\n      if (functionName != 'IsDefined') {\n        node.outputType.status = 'Maybe-Undefined';\n      } else {\n        node.outputType.status = 'Definitely';\n      }\n    } else if (node.args.length > 1) {\n      if (node.args[1].outputType.status == 'Maybe-Undefined') {\n        node.outputType.status = 'Maybe-Undefined';\n      } else {\n        node.outputType.status = 'Definitely';\n      }\n    } else {\n      node.outputType.status = 'Definitely';\n    }\n    node.outputType.valueType = returnType;\n    return errors;\n  }\n}\nclass MudCheckChoose {\n  mudCheck(node, nodes, registeredNodes, dependsMap, assertMap) {\n    let errors = [];\n    const predicate = node.case.predicate;\n    const consequent = node.case.consequent;\n    const otherwise = node.otherwise;\n    const predErrors = mudCheckNode(predicate, nodes, registeredNodes, dependsMap, assertMap);\n    const consErrors = mudCheckNode(consequent, nodes, registeredNodes, dependsMap, assertMap);\n    const otherErrors = mudCheckNode(otherwise, nodes, registeredNodes, dependsMap, assertMap);\n    errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\n    node.outputType.valueType = consequent.outputType.valueType;\n    let consDef = false;\n    let otherDef = false;\n    let localAsserts = [];\n    if (otherwise.outputType.status == 'Definitely') {\n      otherDef = true;\n    }\n    if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'BinaryOperation') {\n      consDef = doBinOp(predicate, consequent, dependsMap, assertMap);\n    }\n    if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'Function') {\n      if (predicate.name == 'IsDefined') {\n        handleAsserts(predicate, dependsMap, assertMap);\n        consDef = handleCheck(consequent, dependsMap, assertMap);\n      }\n    }\n    if (((_13_ = consequent) === null || _13_ === void 0 ? void 0 : _13_.outputType.status) == 'Definitely') {\n      consDef = true;\n    }\n    if (consDef && otherDef) {\n      node.outputType.status = 'Definitely';\n    }\n    return errors;\n  }\n}\nclass MudCheckVariable {\n  mudCheck(node, nodes, registeredNodes, dependsMap, assertMap) {\n    let errors = [];\n    const assignmentErrors = mudCheckNode(node.assignment, nodes, registeredNodes, dependsMap, assertMap);\n    errors = errors.concat(assignmentErrors);\n    node.outputType.status = node.assignment.outputType.status;\n    node.outputType.valueType = node.assignment.outputType.valueType;\n    return errors;\n  }\n}\nclass MudCheckIdentifier {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    let errors = [];\n    let valueNode = registeredNodes[node.assignmentId].assignment;\n    if (valueNode == undefined) {\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\n    } else {\n      node.outputType.status = valueNode.outputType.status;\n      node.outputType.valueType = valueNode.outputType.valueType;\n    }\n    return errors;\n  }\n}\nconst builtins = {\n  \"IsDefined\": {\n    inputType: 'any',\n    resultType: 'boolean'\n  },\n  \"Inverse\": {\n    inputType: 'number',\n    resultType: 'number'\n  },\n  \"Input\": {\n    inputType: 'number',\n    resultType: 'number'\n  },\n  \"Sink\": {\n    inputType: 'any',\n    resultType: 'any'\n  },\n  \"ParseOrderedPair\": {\n    inputType: 'number',\n    resultType: 'pair'\n  },\n  \"X\": {\n    inputType: 'pair',\n    resultType: 'number'\n  },\n  \"Y\": {\n    inputType: 'pair',\n    resultType: 'number'\n  }\n};\nconst mudCheckerMap = {\n  'Number': new MudCheckNumber(),\n  'Boolean': new MudCheckBoolean(),\n  'BinaryOperation': new MudCheckBinary(),\n  'Function': new MudCheckFunction(),\n  'Choose': new MudCheckChoose(),\n  'VariableAssignment': new MudCheckVariable(),\n  'Identifier': new MudCheckIdentifier()\n};\nfunction handleAsserts(predicate, dependsMap, assertMap) {\n  let predBases = findBase_1.findBases(predicate, dependsMap);\n  for (let k = 0; k < predBases.length; k++) {\n    assertMap.push(predBases[k]);\n  }\n}\nfunction handleCheck(consequent, dependsMap, assertMap) {\n  let consBases = findBase_1.findBases(consequent, dependsMap);\n  let contained = true;\n  for (let i = 0; i < consBases.length; i++) {\n    if (!assertMap.find(e => e == consBases[i])) {\n      contained = false;\n    }\n  }\n  return contained;\n}\nfunction resolveBF(predicate, consequent, dependsMap, assertMap) {\n  if (predicate.right.name == 'IsDefined') {\n    handleAsserts(predicate.right, dependsMap, assertMap);\n    return handleCheck(consequent, dependsMap, assertMap);\n  } else {\n    return false;\n  }\n}\nfunction resolveFB(predicate, consequent, dependsMap, assertMap) {\n  if (predicate.left.name == 'IsDefined') {\n    handleAsserts(predicate.left, dependsMap, assertMap);\n    return handleCheck(consequent, dependsMap, assertMap);\n  } else {\n    return false;\n  }\n}\nfunction resolveFF(predicate, consequent, dependsMap, assertMap) {\n  let consDefLeft = false;\n  let consDefRight = false;\n  let consDefBoth = false;\n  let localAsserts = [];\n  if (predicate.left.name == 'IsDefined') {\n    handleAsserts(predicate.left, dependsMap, localAsserts);\n    consDefLeft = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefLeft) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n  if (predicate.right.name == 'IsDefined') {\n    handleAsserts(predicate.right, dependsMap, localAsserts);\n    consDefRight = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefRight) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n  if (predicate.left.name == 'IsDefined' && predicate.right.name == 'IsDefined' && predicate.operator == '&') {\n    handleAsserts(predicate.left, dependsMap, localAsserts);\n    handleAsserts(predicate.right, dependsMap, localAsserts);\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefBoth) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n  if (predicate.operator == '&') {\n    return consDefLeft || consDefRight || consDefBoth;\n  } else if (predicate.operator == '|') {\n    return consDefLeft && consDefRight;\n  } else {\n    return false;\n  }\n}\nfunction resolveBBO(predicate, consequent, dependsMap, assertMap) {\n  let consDefRight = doBinOp(predicate.right, consequent, dependsMap, assertMap);\n  if (predicate.left.value == false && predicate.operator == '|') {\n    return consDefRight;\n  }\n  if (predicate.left.value == true && predicate.operator == '&') {\n    return consDefRight;\n  } else {\n    return false;\n  }\n}\nfunction resolveBOB(predicate, consequent, dependsMap, assertMap) {\n  let consDefLeft = doBinOp(predicate.left, consequent, dependsMap, assertMap);\n  if (predicate.right.value == false && predicate.operator == '|') {\n    return consDefLeft;\n  }\n  if (predicate.right.value == true && predicate.operator == '&') {\n    return consDefLeft;\n  } else {\n    return false;\n  }\n}\nfunction resolveBOF(predicate, consequent, dependsMap, assertMap) {\n  let consDefLeft = false;\n  let consDefRight = false;\n  let consDefBoth = false;\n  let localAsserts = [];\n  consDefLeft = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\n  if (consDefLeft) {\n    assertMap = assertMap.concat(localAsserts);\n  }\n  localAsserts = [];\n  if (predicate.right.name == 'IsDefined') {\n    handleAsserts(predicate.right, dependsMap, localAsserts);\n    consDefRight = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefRight) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n  if (predicate.right.name == 'IsDefined' && predicate.operator == '&') {\n    let temp = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\n    handleAsserts(predicate.right, dependsMap, localAsserts);\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefBoth) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n  if (predicate.operator == '&') {\n    return consDefLeft || consDefRight || consDefBoth;\n  } else if (predicate.operator == '|') {\n    return consDefLeft && consDefRight;\n  } else {\n    return false;\n  }\n}\nfunction resolveFBO(predicate, consequent, dependsMap, assertMap) {\n  let consDefLeft = false;\n  let consDefRight = false;\n  let consDefBoth = false;\n  let localAsserts = [];\n  consDefRight = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\n  if (consDefRight) {\n    assertMap = assertMap.concat(localAsserts);\n  }\n  localAsserts = [];\n  if (predicate.left.name == 'IsDefined') {\n    handleAsserts(predicate.left, dependsMap, localAsserts);\n    consDefLeft = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefLeft) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n  if (predicate.left.name == 'IsDefined' && predicate.operator == '&') {\n    let temp = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\n    handleAsserts(predicate.left, dependsMap, localAsserts);\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefBoth) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n  if (predicate.operator == '&') {\n    return consDefLeft || consDefRight || consDefBoth;\n  } else if (predicate.operator == '|') {\n    return consDefLeft && consDefRight;\n  } else {\n    return false;\n  }\n}\nfunction resolveBOBO(predicate, consequent, dependsMap, assertMap) {\n  let consDefLeft = false;\n  let consDefRight = false;\n  let consDefBoth = false;\n  let localAsserts = [];\n  consDefRight = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\n  if (consDefRight) {\n    assertMap = assertMap.concat(localAsserts);\n  }\n  localAsserts = [];\n  consDefLeft = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\n  if (consDefLeft) {\n    assertMap = assertMap.concat(localAsserts);\n  }\n  localAsserts = [];\n  if (predicate.operator == '&') {\n    let temp = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\n    let temp2 = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefBoth) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n  if (predicate.operator == '&') {\n    return consDefLeft || consDefRight || consDefBoth;\n  } else if (predicate.operator == '|') {\n    return consDefLeft && consDefRight;\n  } else {\n    return false;\n  }\n}\nfunction doBinOp(predicate, consequent, dependsMap, assertMap) {\n  let consDef = false;\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'Boolean') {\n    consDef = resolveFB(predicate, consequent, dependsMap, assertMap);\n  }\n  if (predicate.left.nodeType == 'Boolean' && predicate.right.nodeType == 'Function') {\n    consDef = resolveBF(predicate, consequent, dependsMap, assertMap);\n  }\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'Function') {\n    consDef = resolveFF(predicate, consequent, dependsMap, assertMap);\n  }\n  if (predicate.left.nodeType == 'Boolean' && predicate.right.nodeType == 'BinaryOperation') {\n    consDef = resolveBBO(predicate, consequent, dependsMap, assertMap);\n  }\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'Boolean') {\n    consDef = resolveBOB(predicate, consequent, dependsMap, assertMap);\n  }\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'BinaryOperation') {\n    consDef = resolveFBO(predicate, consequent, dependsMap, assertMap);\n  }\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'Function') {\n    consDef = resolveBOF(predicate, consequent, dependsMap, assertMap);\n  }\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'BinaryOperation') {\n    consDef = resolveBOBO(predicate, consequent, dependsMap, assertMap);\n  }\n  return consDef;\n}\n","sourceMap":"{\"version\":3,\"sources\":[\"src/mudChecker.ts\"],\"names\":[\"nodes\",\"registeredNodes\",\"dependsMap\",\"assertMap\",\"errors\",\"map\",\"n\",\"mudCheckNode\",\"concat\",\"node\",\"mudCheckerMap\",\"nodeType\",\"mudCheck\",\"constructor\",\"message\",\"position\",\"left\",\"right\",\"outputType\",\"status\",\"valueType\",\"name\",\"arg1Errors\",\"args\",\"length\",\"arg2Errors\",\"functionName\",\"argType\",\"builtins\",\"inputType\",\"returnType\",\"resultType\",\"push\",\"TypeError\",\"pos\",\"predicate\",\"case\",\"consequent\",\"otherwise\",\"predErrors\",\"consErrors\",\"otherErrors\",\"consDef\",\"otherDef\",\"localAsserts\",\"doBinOp\",\"handleAsserts\",\"handleCheck\",\"assignmentErrors\",\"assignment\",\"valueNode\",\"assignmentId\",\"undefined\",\"MudCheckNumber\",\"MudCheckBoolean\",\"MudCheckBinary\",\"MudCheckFunction\",\"MudCheckChoose\",\"MudCheckVariable\",\"MudCheckIdentifier\",\"predBases\",\"findBase_1\",\"k\",\"consBases\",\"contained\",\"i\",\"find\",\"e\",\"consDefLeft\",\"consDefRight\",\"consDefBoth\",\"operator\",\"value\",\"temp\",\"temp2\",\"resolveFB\",\"resolveBF\",\"resolveFF\",\"resolveBBO\",\"resolveBOB\",\"resolveFBO\",\"resolveBOF\",\"resolveBOBO\"],\"mappings\":\"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\",\"sourcesContent\":[\"import {Position} from './position';\\nimport * as AST from './ast';\\nimport {equals} from './equals';\\nimport {findBases} from './findBase';\\n\\nexport function mudCheck(nodes: AST.Node[], \\n                        registeredNodes: {[key: string]: AST.Node},\\n                        dependsMap: {[key: string]: string[]},\\n                        assertMap: string[]): TypeError[] {\\n  const errors = nodes.map(n => mudCheckNode(n, nodes, registeredNodes, dependsMap, assertMap));\\n  return ([] as TypeError[]).concat(...errors);\\n}\\n\\nfunction mudCheckNode(node: AST.Node, \\n                    nodes: AST.Node[], \\n                    registeredNodes: {[key: string]: AST.Node},\\n                    dependsMap: {[key: string]: string[]},\\n                    assertMap: string[]): TypeError[] {\\n  return mudCheckerMap[node.nodeType].mudCheck(node, nodes, registeredNodes, dependsMap, assertMap);\\n}\\n\\nexport class TypeError {\\n  constructor(public message: string, public position: Position) {}\\n}\\n\\nexport interface MudChecker {\\n  mudCheck(node: AST.Node, \\n          nodes: AST.Node[], \\n          registeredNodes: {[key: string]: AST.Node},\\n          dependsMap: {[key: string]: string[]},\\n          assertMap: string[]): TypeError[];\\n}\\n\\nclass MudCheckNumber implements MudChecker {\\n  mudCheck(node: AST.NumberNode): TypeError[] {\\n    return [];\\n  }\\n}\\n\\nclass MudCheckBoolean implements MudChecker {\\n    mudCheck(node: AST.BooleanNode): TypeError[] {\\n    return [];\\n  }\\n}\\n\\nclass MudCheckBinary implements MudChecker {\\n    mudCheck(node: AST.BinaryOperationNode, \\n            nodes: AST.Node[], \\n            registeredNodes: {[key: string]: AST.Node},\\n            dependsMap: {[key: string]: string[]},\\n            assertMap: string[]): TypeError[] {\\n        const errors: TypeError[] = mudCheckNode(node.left, nodes, registeredNodes, dependsMap, assertMap)\\n        .concat(mudCheckNode(node.right, nodes, registeredNodes, dependsMap, assertMap));\\n\\n        // If no type errors, update the output type of this node, based on the outputType of its inputs\\n        if (node.right?.outputType?.status == 'Maybe-Undefined' || node.left?.outputType?.status == 'Maybe-Undefined') {\\n            node.outputType = {status: 'Maybe-Undefined',\\n                              valueType: node.left?.outputType?.valueType };\\n        } else {\\n            node.outputType = {status: 'Definitely',\\n                            valueType: node.left?.outputType?.valueType };\\n        }\\n\\n        return errors;\\n    }\\n}\\n\\nclass MudCheckFunction implements MudChecker {\\n    mudCheck(node: AST.FunctionNode, \\n            nodes: AST.Node[], \\n            registeredNodes: {[key: string]: AST.Node},\\n            dependsMap: {[key: string]: string[]},\\n            assertMap: string[]): TypeError[] {\\n        let errors: TypeError[] = [];\\n\\n        if (node.name == 'Sink') {\\n          assertMap = [];\\n        }\\n        \\n        // First typecheck the argument\\n        const arg1Errors = mudCheckNode(node.args[0], nodes, registeredNodes, dependsMap, assertMap);\\n        errors = errors.concat(arg1Errors);\\n        if (node.args.length > 1) {\\n        const arg2Errors = mudCheckNode(node.args[1], nodes, registeredNodes, dependsMap, assertMap);\\n        errors = errors.concat(arg2Errors);\\n        }\\n\\n        const functionName = node.name\\n        const argType = builtins[functionName].inputType;\\n        const returnType = builtins[functionName].resultType;\\n\\n        // only show error if in sink \\\"node\\\"\\n        if (functionName == 'Sink') {\\n        // if sink \\\"node\\\" takes in possibly undefined values, warn the author\\n        // a sink has one argument\\n        if (node.args[0]?.outputType?.status == 'Maybe-Undefined') {\\n            errors.push(new TypeError(\\\"User facing content could be undefined.\\\", node.args[0].pos));\\n        }\\n        }\\n\\n        // If no type errors, update the output type of this node, based on the outputType of its argument\\n        if (node.args[0]?.outputType?.status == 'Maybe-Undefined' || functionName == 'Input') {\\n            // IsDefined should always output a definitely regardless of argument status\\n            if (functionName != 'IsDefined') {\\n            node.outputType.status = 'Maybe-Undefined';\\n            }\\n            else {\\n            node.outputType.status = 'Definitely';\\n            }\\n        } else if (node.args.length > 1) {\\n            if (node.args[1].outputType.status == 'Maybe-Undefined') {\\n            // Note: IsDefined only has one argument, so we don't need to check for that here\\n            node.outputType.status = 'Maybe-Undefined';\\n            } else {\\n            node.outputType.status = 'Definitely';\\n            }\\n        } else {\\n            node.outputType.status = 'Definitely';\\n        }\\n\\n        node.outputType.valueType = returnType;\\n\\n        return errors;\\n    }\\n}\\n\\nclass MudCheckChoose implements MudChecker {\\n    mudCheck(node: AST.ChooseNode, \\n            nodes: AST.Node[], \\n            registeredNodes: {[key: string]: AST.Node},\\n            dependsMap: {[key: string]: string[]},\\n            assertMap: string[]): TypeError[] {\\n        let errors: TypeError[] = [];\\n\\n        const predicate = node.case.predicate;\\n        const consequent = node.case.consequent;\\n        const otherwise = node.otherwise;\\n\\n        // add stuff to the assertMap\\n\\n        // First typecheck the inner nodes\\n        const predErrors = mudCheckNode(predicate, nodes, registeredNodes, dependsMap, assertMap);\\n        const consErrors = mudCheckNode(consequent, nodes, registeredNodes, dependsMap, assertMap);\\n        const otherErrors = mudCheckNode(otherwise, nodes, registeredNodes, dependsMap, assertMap);\\n        errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\\n\\n        node.outputType.valueType = consequent.outputType.valueType;\\n\\n        // DEFUALT status = maybe-undefined\\n\\n        let consDef = false;\\n        let otherDef = false;\\n        let localAsserts: string[] = [];\\n\\n        if (otherwise.outputType.status == 'Definitely') {\\n          otherDef = true;\\n        }\\n\\n        // consequent in MU and we have a binary predicate\\n        if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'BinaryOperation') {\\n          // Cases: both bool *******************************\\n          //        bool, function (and vice versa) *********\\n          //        bool, binary op (and vice versa) IN PROGRESS\\n          //        function, binary op (and vice versa)\\n          //        both function ***************************\\n          //        both binary op\\n\\n          // no need for bool, bool\\n\\n          consDef = doBinOp(predicate, consequent, dependsMap, assertMap);\\n\\n        }\\n\\n\\n        // propagate maybe-undefined type, or change to definitely\\n        // if the predicate is not a function, we cannot error check its type\\n        if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'Function') {\\n          // we can only errorr check with IsDefined function\\n          // IsDefined has only one argument\\n          if (predicate.name == 'IsDefined') {\\n            handleAsserts(predicate, dependsMap, assertMap);\\n            consDef = handleCheck(consequent, dependsMap, assertMap);\\n          }\\n        }\\n\\n        if (consequent?.outputType.status == 'Definitely') {\\n          consDef = true;\\n        }\\n\\n        if (consDef && otherDef) {\\n          node.outputType.status = 'Definitely';\\n        }\\n\\n        return errors;\\n    }\\n}\\n\\nclass MudCheckVariable implements MudChecker {\\n    mudCheck(node: AST.VariableAssignmentNode, \\n            nodes: AST.Node[], \\n            registeredNodes: {[key: string]: AST.Node},\\n            dependsMap: {[key: string]: string[]},\\n            assertMap: string[]): TypeError[] {\\n    let errors: TypeError[] = [];\\n    // First typecheck the assignment node\\n    const assignmentErrors = mudCheckNode(node.assignment, nodes, registeredNodes, dependsMap, assertMap);\\n    errors = errors.concat(assignmentErrors);\\n\\n    // Set variable assignment node output type to the same as it's assignment\\n    node.outputType.status = node.assignment.outputType.status;\\n    node.outputType.valueType = node.assignment.outputType.valueType;\\n\\n    return errors;\\n  }\\n}\\n\\nclass MudCheckIdentifier implements MudChecker {\\n    mudCheck(node: AST.IdentifierNode, \\n            nodes: AST.Node[], \\n            registeredNodes: {[key: string]: AST.Node},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n    let errors: TypeError[] = [];\\n\\n    // Maybe make assigmentId be valueId?\\n    let valueNode = registeredNodes[node.assignmentId].assignment;\\n\\n    // If this assignmentId is not found in the AST, throw an error\\n    if (valueNode == undefined) {\\n      errors.push(new TypeError(\\\"This variable doesn't have a value\\\", node.pos));\\n    } else {\\n      // If we found the assignment node, set the output type of the identifier\\n      node.outputType.status = valueNode.outputType.status;\\n      node.outputType.valueType = valueNode.outputType.valueType;\\n    }\\n\\n    return errors;\\n  }\\n}\\n\\n// Dictionary of builtin functions that maps a function name to the type of its argument\\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType} } = {\\n  \\\"IsDefined\\\": {inputType: 'any', resultType: 'boolean'},\\n  \\\"Inverse\\\": {inputType: 'number', resultType: 'number'},\\n  \\\"Input\\\": {inputType: 'number', resultType: 'number'},\\n  \\\"Sink\\\": {inputType: 'any', resultType: 'any'},\\n  \\\"ParseOrderedPair\\\": {inputType: 'number', resultType: 'pair'},\\n  \\\"X\\\": {inputType: 'pair', resultType: 'number'},\\n  \\\"Y\\\": {inputType: 'pair', resultType: 'number'}\\n}\\n\\nconst mudCheckerMap: Partial<{[K in AST.NodeType]: MudChecker}> = {\\n  'Number' : new MudCheckNumber(),\\n  'Boolean' : new MudCheckBoolean(),\\n  'BinaryOperation' : new MudCheckBinary(),\\n  'Function' : new MudCheckFunction(),\\n  'Choose': new MudCheckChoose(),\\n  'VariableAssignment': new MudCheckVariable(),\\n  'Identifier': new MudCheckIdentifier()\\n}\\n\\nfunction handleAsserts(predicate: AST.Node,\\n                      dependsMap: {[key: string]: string[]},\\n                      assertMap: string[]): void {\\n\\n    // look up the bases of the predicate\\n    let predBases = findBases(predicate, dependsMap);\\n    // set outputType to Definitely if consBases are contained in predBases\\n    // add to assertMap\\n    for (let k = 0; k < predBases.length; k++) {\\n      assertMap.push(predBases[k]);\\n    }\\n}\\n\\nfunction handleCheck(consequent: AST.Node,\\n                    dependsMap: {[key: string]: string[]},\\n                    assertMap: string[]): boolean {\\n\\n  let consBases = findBases(consequent, dependsMap);\\n\\n  let contained = true;\\n    for (let i = 0; i < consBases.length; i++) {\\n      if (!assertMap.find(e => e == consBases[i])) {\\n        contained = false;\\n      }\\n    }\\n\\n    return contained;\\n}\\n\\nfunction resolveBF(predicate: AST.Node,\\n                  consequent: AST.Node,\\n                  dependsMap: {[key: string]: string[]},\\n                  assertMap: string[]): boolean {\\n\\n  // boolean, function\\n  if (predicate.right.name == 'IsDefined') {\\n    handleAsserts(predicate.right, dependsMap, assertMap);\\n    return handleCheck(consequent, dependsMap, assertMap);\\n  }\\n  else {\\n    return false;\\n  }\\n\\n}\\n\\nfunction resolveFB(predicate: AST.Node,\\n                  consequent: AST.Node,\\n                  dependsMap: {[key: string]: string[]},\\n                  assertMap: string[]): boolean {\\n  // function, boolean\\n  if (predicate.left.name == 'IsDefined') {\\n    handleAsserts(predicate.left, dependsMap, assertMap);\\n    return handleCheck(consequent, dependsMap, assertMap);\\n  }\\n  else {\\n    return false;\\n  }\\n}\\n\\nfunction resolveFF(predicate: AST.Node,\\n                  consequent: AST.Node,\\n                  dependsMap: {[key: string]: string[]},\\n                  assertMap: string[]): boolean {\\n  // function, function\\n  let consDefLeft = false;\\n  let consDefRight = false;\\n  let consDefBoth = false;\\n  let localAsserts: string[] = [];\\n\\n  if (predicate.left.name == 'IsDefined') {\\n    handleAsserts(predicate.left, dependsMap, localAsserts);\\n    consDefLeft = handleCheck(consequent, dependsMap, localAsserts);\\n    if (consDefLeft) {\\n      assertMap = assertMap.concat(localAsserts);\\n    }\\n    localAsserts = [];\\n  }\\n\\n  if (predicate.right.name == 'IsDefined') {\\n    handleAsserts(predicate.right, dependsMap, localAsserts);\\n    consDefRight = handleCheck(consequent, dependsMap, localAsserts);\\n    if (consDefRight) {\\n      assertMap = assertMap.concat(localAsserts);\\n    }\\n    localAsserts = [];\\n  }\\n\\n  if (predicate.left.name == 'IsDefined' && predicate.right.name == 'IsDefined' && predicate.operator == '&') {\\n    handleAsserts(predicate.left, dependsMap, localAsserts);\\n    handleAsserts(predicate.right, dependsMap, localAsserts);\\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\\n    if (consDefBoth) {\\n      assertMap = assertMap.concat(localAsserts);\\n    }\\n    localAsserts = [];\\n  }\\n\\n  if (predicate.operator == '&') {\\n    return consDefLeft || consDefRight || consDefBoth;\\n  }\\n  else if (predicate.operator == '|') {\\n    return consDefLeft && consDefRight;\\n  }\\n  else {\\n    return false;\\n  }\\n}\\n\\nfunction resolveBBO(predicate: AST.Node,\\n  consequent: AST.Node,\\n  dependsMap: {[key: string]: string[]},\\n  assertMap: string[]): boolean {\\n  // boolean, binary operation\\n  // recurse on the right\\n  let consDefRight = doBinOp(predicate.right, consequent, dependsMap, assertMap);\\n  if (predicate.left.value == false && predicate.operator == '|') {\\n    return consDefRight;\\n  }\\n  if (predicate.left.value == true && predicate.operator == '&') {\\n    return consDefRight;\\n  }\\n  else {\\n    // this may change to true\\n    return false;\\n  }\\n\\n}\\n\\nfunction resolveBOB(predicate: AST.Node,\\n  consequent: AST.Node,\\n  dependsMap: {[key: string]: string[]},\\n  assertMap: string[]): boolean {\\n  // binary operation, boolean\\n  let consDefLeft = doBinOp(predicate.left, consequent, dependsMap, assertMap);\\n  if (predicate.right.value == false && predicate.operator == '|') {\\n    return consDefLeft;\\n  }\\n  if (predicate.right.value == true && predicate.operator == '&') {\\n    return consDefLeft;\\n  }\\n  else {\\n    // this may change to true\\n    return false;\\n  }\\n}\\n\\nfunction resolveBOF(predicate: AST.Node,\\n  consequent: AST.Node,\\n  dependsMap: {[key: string]: string[]},\\n  assertMap: string[]): boolean {\\n  // binary operation, function\\n  // recurse on the left with local asserts\\n  let consDefLeft = false;\\n  let consDefRight = false;\\n  let consDefBoth = false;\\n  let localAsserts: string[] = [];\\n\\n  consDefLeft = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\\n  if (consDefLeft) {\\n    assertMap = assertMap.concat(localAsserts);\\n  }\\n  localAsserts = [];\\n\\n  if (predicate.right.name == 'IsDefined') {\\n    handleAsserts(predicate.right, dependsMap, localAsserts);\\n    consDefRight = handleCheck(consequent, dependsMap, localAsserts);\\n    if (consDefRight) {\\n      assertMap = assertMap.concat(localAsserts);\\n    }\\n    localAsserts = [];\\n  }\\n\\n  if (predicate.right.name == 'IsDefined' && predicate.operator == '&') {\\n    let temp = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\\n    handleAsserts(predicate.right, dependsMap, localAsserts);\\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\\n    if (consDefBoth) {\\n      assertMap = assertMap.concat(localAsserts);\\n    }\\n    localAsserts = [];\\n  }\\n\\n  if (predicate.operator == '&') {\\n    return consDefLeft || consDefRight || consDefBoth;\\n  }\\n  else if (predicate.operator == '|') {\\n    return consDefLeft && consDefRight;\\n  }\\n  else {\\n    return false;\\n  }\\n  \\n}\\n\\nfunction resolveFBO(predicate: AST.Node,\\n  consequent: AST.Node,\\n  dependsMap: {[key: string]: string[]},\\n  assertMap: string[]): boolean {\\n  // function, binary operation\\n  // recurse on the left with local asserts\\n  let consDefLeft = false;\\n  let consDefRight = false;\\n  let consDefBoth = false;\\n  let localAsserts: string[] = [];\\n\\n  consDefRight = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\\n  if (consDefRight) {\\n    assertMap = assertMap.concat(localAsserts);\\n  }\\n  localAsserts = [];\\n\\n  if (predicate.left.name == 'IsDefined') {\\n    handleAsserts(predicate.left, dependsMap, localAsserts);\\n    consDefLeft = handleCheck(consequent, dependsMap, localAsserts);\\n    if (consDefLeft) {\\n      assertMap = assertMap.concat(localAsserts);\\n    }\\n    localAsserts = [];\\n  }\\n\\n  if (predicate.left.name == 'IsDefined' && predicate.operator == '&') {\\n    let temp = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\\n    handleAsserts(predicate.left, dependsMap, localAsserts);\\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\\n    if (consDefBoth) {\\n      assertMap = assertMap.concat(localAsserts);\\n    }\\n    localAsserts = [];\\n  }\\n\\n  if (predicate.operator == '&') {\\n    return consDefLeft || consDefRight || consDefBoth;\\n  }\\n  else if (predicate.operator == '|') {\\n    return consDefLeft && consDefRight;\\n  }\\n  else {\\n    return false;\\n  }\\n}\\n\\nfunction resolveBOBO(predicate: AST.Node,\\n  consequent: AST.Node,\\n  dependsMap: {[key: string]: string[]},\\n  assertMap: string[]): boolean {\\n  // binary operation, binary operation\\n  let consDefLeft = false;\\n  let consDefRight = false;\\n  let consDefBoth = false;\\n  let localAsserts: string[] = [];\\n\\n  consDefRight = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\\n  if (consDefRight) {\\n    assertMap = assertMap.concat(localAsserts);\\n  }\\n  localAsserts = [];\\n\\n  consDefLeft = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\\n  if (consDefLeft) {\\n    assertMap = assertMap.concat(localAsserts);\\n  }\\n  localAsserts = [];\\n\\n  if (predicate.operator == '&') {\\n    let temp = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\\n    let temp2 = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\\n    if (consDefBoth) {\\n      assertMap = assertMap.concat(localAsserts);\\n    }\\n    localAsserts = [];\\n  }\\n\\n  if (predicate.operator == '&') {\\n    return consDefLeft || consDefRight || consDefBoth;\\n  }\\n  else if (predicate.operator == '|') {\\n    return consDefLeft && consDefRight;\\n  }\\n  else {\\n    return false;\\n  }\\n}\\n\\nfunction doBinOp(predicate: AST.Node,\\n  consequent: AST.Node,\\n  dependsMap: {[key: string]: string[]},\\n  assertMap: string[]): boolean {\\n  let consDef = false;\\n  // function, boolean\\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'Boolean') {\\n    consDef = resolveFB(predicate, consequent, dependsMap, assertMap);\\n  }\\n\\n  // boolean, function\\n  if (predicate.left.nodeType == 'Boolean' && predicate.right.nodeType == 'Function') {\\n    consDef = resolveBF(predicate, consequent, dependsMap, assertMap);\\n  }\\n\\n  // function, function\\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'Function') {\\n    consDef = resolveFF(predicate, consequent, dependsMap, assertMap);\\n\\n  }\\n\\n  // bool, binary op\\n  if (predicate.left.nodeType == 'Boolean' && predicate.right.nodeType == 'BinaryOperation') {\\n    consDef = resolveBBO(predicate, consequent, dependsMap, assertMap);\\n  }\\n\\n  // binary op, bool\\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'Boolean') {\\n    consDef = resolveBOB(predicate, consequent, dependsMap, assertMap);\\n  }\\n\\n  // function, binary op\\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'BinaryOperation') {\\n    consDef = resolveFBO(predicate, consequent, dependsMap, assertMap);\\n  }\\n\\n  // binary op, function\\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'Function') {\\n    consDef = resolveBOF(predicate, consequent, dependsMap, assertMap);\\n  }\\n\\n  // binary op, binary op\\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'BinaryOperation') {\\n    consDef = resolveBOBO(predicate, consequent, dependsMap, assertMap);\\n  }\\n\\n  return consDef;\\n}\"]}"}