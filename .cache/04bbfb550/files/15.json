{"contents":"var _1_, _2_;\nvar _3_, _4_;\nvar _5_, _6_;\nvar _7_, _8_;\nvar _9_, _10_;\nvar _11_, _12_;\nvar _13_;\nexports.__esModule = true;\nvar findBase_1 = __fusereq(42);\nfunction mudCheck(nodes, registeredNodes, dependsMap) {\n  const errors = nodes.map(n => mudCheckNode(n, nodes, registeredNodes, dependsMap));\n  return [].concat(...errors);\n}\nexports.mudCheck = mudCheck;\nfunction mudCheckNode(node, nodes, registeredNodes, dependsMap) {\n  return mudCheckerMap[node.nodeType].mudCheck(node, nodes, registeredNodes, dependsMap);\n}\nclass TypeError {\n  constructor(message, position) {\n    this.message = message;\n    this.position = position;\n  }\n}\nexports.TypeError = TypeError;\nclass MudCheckNumber {\n  mudCheck(node) {\n    return [];\n  }\n}\nclass MudCheckBoolean {\n  mudCheck(node) {\n    return [];\n  }\n}\nclass MudCheckBinary {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    const errors = mudCheckNode(node.left, nodes, registeredNodes, dependsMap).concat(mudCheckNode(node.right, nodes, registeredNodes, dependsMap));\n    if (((_2_ = (_1_ = node.right) === null || _1_ === void 0 ? void 0 : _1_.outputType) === null || _2_ === void 0 ? void 0 : _2_.status) == 'Maybe-Undefined' || ((_4_ = (_3_ = node.left) === null || _3_ === void 0 ? void 0 : _3_.outputType) === null || _4_ === void 0 ? void 0 : _4_.status) == 'Maybe-Undefined') {\n      node.outputType = {\n        status: 'Maybe-Undefined',\n        valueType: (_6_ = (_5_ = node.left) === null || _5_ === void 0 ? void 0 : _5_.outputType) === null || _6_ === void 0 ? void 0 : _6_.valueType\n      };\n    } else {\n      node.outputType = {\n        status: 'Definitely',\n        valueType: (_8_ = (_7_ = node.left) === null || _7_ === void 0 ? void 0 : _7_.outputType) === null || _8_ === void 0 ? void 0 : _8_.valueType\n      };\n    }\n    if (node.operator == '|') {\n      let intersection = [];\n      let leftAsserts = node.left.outputType.asserts;\n      let rightAsserts = node.right.outputType.asserts;\n      for (let i = 0; i < leftAsserts.length; i++) {\n        if (rightAsserts.find(e => e == leftAsserts[i])) {\n          intersection.push(leftAsserts[i]);\n        }\n      }\n      node.outputType.asserts = intersection;\n    } else {\n      let leftAsserts = node.left.outputType.asserts;\n      let rightAsserts = node.right.outputType.asserts;\n      let allAsserts = leftAsserts.concat(rightAsserts);\n      node.outputType.asserts = allAsserts;\n    }\n    return errors;\n  }\n}\nclass MudCheckFunction {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    let errors = [];\n    if (node.name == 'IsDefined') {\n      let bases = findBase_1.findBases(node, dependsMap);\n      node.outputType.asserts = node.outputType.asserts.concat(bases);\n    }\n    const arg1Errors = mudCheckNode(node.args[0], nodes, registeredNodes, dependsMap);\n    errors = errors.concat(arg1Errors);\n    if (node.args.length > 1) {\n      const arg2Errors = mudCheckNode(node.args[1], nodes, registeredNodes, dependsMap);\n      errors = errors.concat(arg2Errors);\n    }\n    const functionName = node.name;\n    const returnType = builtins[functionName].resultType;\n    if (functionName == 'Sink') {\n      if (((_10_ = (_9_ = node.args[0]) === null || _9_ === void 0 ? void 0 : _9_.outputType) === null || _10_ === void 0 ? void 0 : _10_.status) == 'Maybe-Undefined') {\n        errors.push(new TypeError(\"User facing content could be undefined.\", node.args[0].pos));\n      }\n    }\n    if (builtins[functionName].status == \"Variable\") {\n      node.outputType.status = (_12_ = (_11_ = node.args[0]) === null || _11_ === void 0 ? void 0 : _11_.outputType) === null || _12_ === void 0 ? void 0 : _12_.status;\n    } else {\n      node.outputType.status = builtins[functionName].status;\n    }\n    node.outputType.valueType = returnType;\n    return errors;\n  }\n}\nclass MudCheckChoose {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    let errors = [];\n    const predicate = node.case.predicate;\n    const consequent = node.case.consequent;\n    const otherwise = node.otherwise;\n    const predErrors = mudCheckNode(predicate, nodes, registeredNodes, dependsMap);\n    const consErrors = mudCheckNode(consequent, nodes, registeredNodes, dependsMap);\n    const otherErrors = mudCheckNode(otherwise, nodes, registeredNodes, dependsMap);\n    errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\n    node.outputType.valueType = consequent.outputType.valueType;\n    let consDef = false;\n    let otherDef = false;\n    let localAsserts = [];\n    if (otherwise.outputType.status == 'Definitely') {\n      otherDef = true;\n    }\n    if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'BinaryOperation') {\n      consDef = handleCheck(consequent, dependsMap, predicate.outputType.asserts);\n    }\n    if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'Function') {\n      if (predicate.name == 'IsDefined') {\n        consDef = handleCheck(consequent, dependsMap, predicate.outputType.asserts);\n      }\n    }\n    if (((_13_ = consequent) === null || _13_ === void 0 ? void 0 : _13_.outputType.status) == 'Definitely') {\n      consDef = true;\n    }\n    if (consDef && otherDef) {\n      node.outputType.status = 'Definitely';\n    }\n    return errors;\n  }\n}\nclass MudCheckVariable {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    let errors = [];\n    const assignmentErrors = mudCheckNode(node.assignment, nodes, registeredNodes, dependsMap);\n    errors = errors.concat(assignmentErrors);\n    node.outputType.status = node.assignment.outputType.status;\n    node.outputType.valueType = node.assignment.outputType.valueType;\n    return errors;\n  }\n}\nclass MudCheckIdentifier {\n  mudCheck(node, nodes, registeredNodes, dependsMap) {\n    let errors = [];\n    let valueNode = registeredNodes[node.assignmentId].assignment;\n    if (valueNode == undefined) {\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\n    } else {\n      node.outputType.status = valueNode.outputType.status;\n      node.outputType.valueType = valueNode.outputType.valueType;\n    }\n    return errors;\n  }\n}\nconst builtins = {\n  \"IsDefined\": {\n    inputType: 'any',\n    resultType: 'boolean',\n    status: \"Definitely\"\n  },\n  \"Inverse\": {\n    inputType: 'number',\n    resultType: 'number',\n    status: \"Variable\"\n  },\n  \"InputN\": {\n    inputType: 'number',\n    resultType: 'number',\n    status: \"Maybe-Undefined\"\n  },\n  \"Sink\": {\n    inputType: 'any',\n    resultType: 'any',\n    status: \"Variable\"\n  },\n  \"ParseOrderedPair\": {\n    inputType: 'number',\n    resultType: 'pair',\n    status: \"Maybe-Undefined\"\n  },\n  \"X\": {\n    inputType: 'pair',\n    resultType: 'number',\n    status: \"Variable\"\n  },\n  \"Y\": {\n    inputType: 'pair',\n    resultType: 'number',\n    status: \"Variable\"\n  },\n  \"Not\": {\n    inputType: 'boolean',\n    resultType: 'boolean',\n    status: \"Definitely\"\n  },\n  \"InputB\": {\n    inputType: 'boolean',\n    resultType: 'boolean',\n    status: \"Maybe-Undefined\"\n  }\n};\nconst mudCheckerMap = {\n  'Number': new MudCheckNumber(),\n  'Boolean': new MudCheckBoolean(),\n  'BinaryOperation': new MudCheckBinary(),\n  'Function': new MudCheckFunction(),\n  'Choose': new MudCheckChoose(),\n  'VariableAssignment': new MudCheckVariable(),\n  'Identifier': new MudCheckIdentifier()\n};\nfunction handleCheck(consequent, dependsMap, asserts) {\n  let consBases = findBase_1.findBases(consequent, dependsMap);\n  let contained = true;\n  for (let i = 0; i < consBases.length; i++) {\n    if (!asserts.find(e => e == consBases[i])) {\n      contained = false;\n    }\n  }\n  return contained;\n}\n","sourceMap":"{\"version\":3,\"sources\":[\"src/mudChecker.ts\"],\"names\":[\"nodes\",\"registeredNodes\",\"dependsMap\",\"errors\",\"map\",\"n\",\"mudCheckNode\",\"concat\",\"node\",\"mudCheckerMap\",\"nodeType\",\"mudCheck\",\"constructor\",\"message\",\"position\",\"left\",\"right\",\"outputType\",\"status\",\"valueType\",\"operator\",\"intersection\",\"leftAsserts\",\"asserts\",\"rightAsserts\",\"i\",\"length\",\"find\",\"e\",\"push\",\"allAsserts\",\"name\",\"bases\",\"findBase_1\",\"arg1Errors\",\"args\",\"arg2Errors\",\"functionName\",\"returnType\",\"builtins\",\"resultType\",\"TypeError\",\"pos\",\"predicate\",\"case\",\"consequent\",\"otherwise\",\"predErrors\",\"consErrors\",\"otherErrors\",\"consDef\",\"otherDef\",\"localAsserts\",\"handleCheck\",\"assignmentErrors\",\"assignment\",\"valueNode\",\"assignmentId\",\"undefined\",\"inputType\",\"MudCheckNumber\",\"MudCheckBoolean\",\"MudCheckBinary\",\"MudCheckFunction\",\"MudCheckChoose\",\"MudCheckVariable\",\"MudCheckIdentifier\",\"consBases\",\"contained\"],\"mappings\":\"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\",\"sourcesContent\":[\"import {Position} from './position';\\nimport * as AST from './ast';\\nimport {equals} from './equals';\\nimport {findBases} from './findBase';\\n\\nexport function mudCheck(nodes: AST.Node[], \\n                        registeredNodes: {[key: string]: AST.Node},\\n                        dependsMap: {[key: string]: string[]}): TypeError[] {\\n  const errors = nodes.map(n => mudCheckNode(n, nodes, registeredNodes, dependsMap));\\n  return ([] as TypeError[]).concat(...errors);\\n}\\n\\nfunction mudCheckNode(node: AST.Node, \\n                    nodes: AST.Node[], \\n                    registeredNodes: {[key: string]: AST.Node},\\n                    dependsMap: {[key: string]: string[]}): TypeError[] {\\n  return mudCheckerMap[node.nodeType].mudCheck(node, nodes, registeredNodes, dependsMap);\\n}\\n\\nexport class TypeError {\\n  constructor(public message: string, public position: Position) {}\\n}\\n\\nexport interface MudChecker {\\n  mudCheck(node: AST.Node, \\n          nodes: AST.Node[], \\n          registeredNodes: {[key: string]: AST.Node},\\n          dependsMap: {[key: string]: string[]}): TypeError[];\\n}\\n\\nclass MudCheckNumber implements MudChecker {\\n  mudCheck(node: AST.NumberNode): TypeError[] {\\n    return [];\\n  }\\n}\\n\\nclass MudCheckBoolean implements MudChecker {\\n    mudCheck(node: AST.BooleanNode): TypeError[] {\\n    return [];\\n  }\\n}\\n\\nclass MudCheckBinary implements MudChecker {\\n    mudCheck(node: AST.BinaryOperationNode, \\n            nodes: AST.Node[], \\n            registeredNodes: {[key: string]: AST.Node},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n        const errors: TypeError[] = mudCheckNode(node.left, nodes, registeredNodes, dependsMap)\\n        .concat(mudCheckNode(node.right, nodes, registeredNodes, dependsMap));\\n\\n        // If no type errors, update the output type of this node, based on the outputType of its inputs\\n        if (node.right?.outputType?.status == 'Maybe-Undefined' || node.left?.outputType?.status == 'Maybe-Undefined') {\\n            node.outputType = {status: 'Maybe-Undefined',\\n                              valueType: node.left?.outputType?.valueType };\\n        } else {\\n            node.outputType = {status: 'Definitely',\\n                            valueType: node.left?.outputType?.valueType };\\n        }\\n\\n        if (node.operator == '|') {\\n          let intersection = [];\\n          let leftAsserts = node.left.outputType.asserts;\\n          let rightAsserts = node.right.outputType.asserts;\\n          for (let i = 0; i < leftAsserts.length; i++) {\\n            if (rightAsserts.find(e => e == leftAsserts[i])) {\\n              intersection.push(leftAsserts[i]);\\n            }\\n          }\\n          node.outputType.asserts = intersection;\\n        }\\n        else {\\n          // if it's an and, we take all of the asserts\\n          let leftAsserts = node.left.outputType.asserts;\\n          let rightAsserts = node.right.outputType.asserts;\\n          let allAsserts = leftAsserts.concat(rightAsserts);\\n\\n          node.outputType.asserts = allAsserts;\\n        }\\n\\n        return errors;\\n    }\\n}\\n\\nclass MudCheckFunction implements MudChecker {\\n    mudCheck(node: AST.FunctionNode, \\n            nodes: AST.Node[], \\n            registeredNodes: {[key: string]: AST.Node},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n        let errors: TypeError[] = [];\\n\\n        if (node.name == 'IsDefined') {\\n          let bases = findBases(node, dependsMap);\\n          node.outputType.asserts = node.outputType.asserts.concat(bases);\\n        }\\n        \\n        // First typecheck the argument\\n        const arg1Errors = mudCheckNode(node.args[0], nodes, registeredNodes, dependsMap);\\n        errors = errors.concat(arg1Errors);\\n        if (node.args.length > 1) {\\n        const arg2Errors = mudCheckNode(node.args[1], nodes, registeredNodes, dependsMap);\\n        errors = errors.concat(arg2Errors);\\n        }\\n\\n       \\n\\n        const functionName = node.name\\n        const returnType = builtins[functionName].resultType;\\n\\n        // only show error if in sink \\\"node\\\"\\n        if (functionName == 'Sink') {\\n          // if sink \\\"node\\\" takes in possibly undefined values, warn the author\\n          // a sink has one argument\\n          if (node.args[0]?.outputType?.status == 'Maybe-Undefined') {\\n              errors.push(new TypeError(\\\"User facing content could be undefined.\\\", node.args[0].pos));\\n          }\\n        }\\n        \\n        if (builtins[functionName].status == \\\"Variable\\\") {\\n          node.outputType.status = node.args[0]?.outputType?.status;\\n        }\\n        else {\\n          node.outputType.status = builtins[functionName].status;\\n        }\\n       \\n\\n        node.outputType.valueType = returnType;\\n\\n        return errors;\\n    }\\n}\\n\\nclass MudCheckChoose implements MudChecker {\\n    mudCheck(node: AST.ChooseNode, \\n            nodes: AST.Node[], \\n            registeredNodes: {[key: string]: AST.Node},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n        let errors: TypeError[] = [];\\n\\n        const predicate = node.case.predicate;\\n        const consequent = node.case.consequent;\\n        const otherwise = node.otherwise;\\n\\n        // add stuff to the assertMap\\n\\n        // First typecheck the inner nodes\\n        const predErrors = mudCheckNode(predicate, nodes, registeredNodes, dependsMap);\\n        const consErrors = mudCheckNode(consequent, nodes, registeredNodes, dependsMap);\\n        const otherErrors = mudCheckNode(otherwise, nodes, registeredNodes, dependsMap);\\n        errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\\n\\n        node.outputType.valueType = consequent.outputType.valueType;\\n\\n        // DEFUALT status = maybe-undefined\\n\\n        let consDef = false;\\n        let otherDef = false;\\n        let localAsserts: string[] = [];\\n\\n        if (otherwise.outputType.status == 'Definitely') {\\n          otherDef = true;\\n        }\\n\\n        // consequent in MU and we have a binary predicate\\n        if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'BinaryOperation') {\\n          \\n          consDef = handleCheck(consequent, dependsMap, predicate.outputType.asserts);\\n\\n        }\\n\\n\\n        // propagate maybe-undefined type, or change to definitely\\n        // if the predicate is not a function, we cannot error check its type\\n        if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'Function') {\\n          // we can only errorr check with IsDefined function\\n          // IsDefined has only one argument\\n          if (predicate.name == 'IsDefined') {\\n            consDef = handleCheck(consequent, dependsMap, predicate.outputType.asserts);\\n          }\\n        }\\n\\n        if (consequent?.outputType.status == 'Definitely') {\\n          consDef = true;\\n        }\\n\\n        if (consDef && otherDef) {\\n          node.outputType.status = 'Definitely';\\n        }\\n\\n        return errors;\\n    }\\n}\\n\\nclass MudCheckVariable implements MudChecker {\\n    mudCheck(node: AST.VariableAssignmentNode, \\n            nodes: AST.Node[], \\n            registeredNodes: {[key: string]: AST.Node},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n    let errors: TypeError[] = [];\\n    // First typecheck the assignment node\\n    const assignmentErrors = mudCheckNode(node.assignment, nodes, registeredNodes, dependsMap);\\n    errors = errors.concat(assignmentErrors);\\n\\n    // Set variable assignment node output type to the same as it's assignment\\n    node.outputType.status = node.assignment.outputType.status;\\n    node.outputType.valueType = node.assignment.outputType.valueType;\\n\\n    return errors;\\n  }\\n}\\n\\nclass MudCheckIdentifier implements MudChecker {\\n    mudCheck(node: AST.IdentifierNode, \\n            nodes: AST.Node[], \\n            registeredNodes: {[key: string]: AST.Node},\\n            dependsMap: {[key: string]: string[]}): TypeError[] {\\n    let errors: TypeError[] = [];\\n\\n    // Maybe make assigmentId be valueId?\\n    let valueNode = registeredNodes[node.assignmentId].assignment;\\n\\n    // If this assignmentId is not found in the AST, throw an error\\n    if (valueNode == undefined) {\\n      errors.push(new TypeError(\\\"This variable doesn't have a value\\\", node.pos));\\n    } else {\\n      // If we found the assignment node, set the output type of the identifier\\n      node.outputType.status = valueNode.outputType.status;\\n      node.outputType.valueType = valueNode.outputType.valueType;\\n    }\\n\\n    return errors;\\n  }\\n}\\n\\n// Dictionary of builtin functions that maps a function name to the type of its argument\\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType, status: string} } = {\\n  \\\"IsDefined\\\": {inputType: 'any', resultType: 'boolean', status: \\\"Definitely\\\"},\\n  \\\"Inverse\\\": {inputType: 'number', resultType: 'number', status: \\\"Variable\\\"},\\n  \\\"InputN\\\": {inputType: 'number', resultType: 'number', status: \\\"Maybe-Undefined\\\"},\\n  \\\"Sink\\\": {inputType: 'any', resultType: 'any', status: \\\"Variable\\\"},\\n  \\\"ParseOrderedPair\\\": {inputType: 'number', resultType: 'pair', status: \\\"Maybe-Undefined\\\"},\\n  \\\"X\\\": {inputType: 'pair', resultType: 'number', status: \\\"Variable\\\"},\\n  \\\"Y\\\": {inputType: 'pair', resultType: 'number', status: \\\"Variable\\\"},\\n  \\\"Not\\\": {inputType: 'boolean', resultType: 'boolean', status: \\\"Definitely\\\"},\\n  \\\"InputB\\\": {inputType: 'boolean', resultType: 'boolean', status: \\\"Maybe-Undefined\\\"}\\n}\\n\\nconst mudCheckerMap: Partial<{[K in AST.NodeType]: MudChecker}> = {\\n  'Number' : new MudCheckNumber(),\\n  'Boolean' : new MudCheckBoolean(),\\n  'BinaryOperation' : new MudCheckBinary(),\\n  'Function' : new MudCheckFunction(),\\n  'Choose': new MudCheckChoose(),\\n  'VariableAssignment': new MudCheckVariable(),\\n  'Identifier': new MudCheckIdentifier()\\n}\\n\\nfunction handleCheck(consequent: AST.Node,\\n                    dependsMap: {[key: string]: string[]},\\n                    asserts: string[]): boolean {\\n\\n  let consBases = findBases(consequent, dependsMap);\\n\\n  let contained = true;\\n    for (let i = 0; i < consBases.length; i++) {\\n      if (!asserts.find(e => e == consBases[i])) {\\n        contained = false;\\n      }\\n    }\\n\\n    return contained;\\n}\"]}"}