{"contents":"var _1_, _2_;\nexports.__esModule = true;\nvar position_1 = __fusereq(49);\nclass NumberParselet {\n  parse(_parser, _tokens, token, varMap, registeredNodes) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    let newNode = {\n      nodeType: 'Number',\n      value: parseFloat(token.text),\n      outputType: {\n        status: 'Definitely',\n        valueType: 'number',\n        asserts: [],\n        constType: 'Constant'\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.NumberParselet = NumberParselet;\nclass BooleanParselet {\n  constructor(value) {\n    this.value = value;\n  }\n  parse(_parser, _tokens, token, varMap, registeredNodes) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    let newNode = {\n      nodeType: 'Boolean',\n      value: this.value,\n      outputType: {\n        status: 'Definitely',\n        valueType: 'boolean',\n        asserts: [],\n        constType: 'Constant'\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.BooleanParselet = BooleanParselet;\nclass ParenParselet {\n  parse(parser, tokens, _token, varMap, registeredNodes) {\n    const exp = parser.parse(tokens, 0, varMap, registeredNodes);\n    tokens.expectToken(')');\n    return exp;\n  }\n}\nexports.ParenParselet = ParenParselet;\nclass ConsequentParselet {\n  constructor(tokenType, associativity) {\n    this.tokenType = tokenType;\n    this.associativity = associativity;\n  }\n}\nexports.ConsequentParselet = ConsequentParselet;\nclass BinaryOperatorParselet extends ConsequentParselet {\n  constructor(tokenType, associativity) {\n    super(tokenType, associativity);\n    this.tokenType = tokenType;\n  }\n  parse(parser, tokens, left, token, varMap, registeredNodes) {\n    const bindingPower = parser.bindingPower(token);\n    const right = parser.parse(tokens, this.associativity == 'left' ? bindingPower : bindingPower - 1, varMap, registeredNodes);\n    const position = position_1.join(left.pos, position_1.token2pos(tokens.last()));\n    const id = position_1.pos2string(position);\n    let newNode = {\n      nodeType: 'BinaryOperation',\n      operator: this.tokenType,\n      left,\n      right,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: undefined,\n        asserts: [],\n        constType: undefined\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.BinaryOperatorParselet = BinaryOperatorParselet;\nclass FunctionParselet {\n  parse(parser, tokens, token, varMap, registeredNodes) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    tokens.expectToken('(');\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes);\n    let args = [arg1];\n    if (token.text == \"ParseOrderedPair\") {\n      const arg2 = parser.parse(tokens, 0, varMap, registeredNodes);\n      args.push(arg2);\n    }\n    tokens.expectToken(')');\n    let newNode = {\n      nodeType: 'Function',\n      name: token.text,\n      args: args,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: undefined,\n        asserts: [],\n        constType: undefined\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.FunctionParselet = FunctionParselet;\nclass ChooseParselet {\n  parse(parser, tokens, token, varMap, registeredNodes) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    const predicate = parser.parse(tokens, 0, varMap, registeredNodes);\n    const consequent = parser.parse(tokens, 0, varMap, registeredNodes);\n    tokens.expectToken('CHOOSE2');\n    const otherwise = parser.parse(tokens, 0, varMap, registeredNodes);\n    let newNode = {\n      nodeType: 'Choose',\n      case: {\n        predicate: predicate,\n        consequent: consequent\n      },\n      otherwise: otherwise,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: undefined,\n        asserts: [],\n        constType: undefined\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.ChooseParselet = ChooseParselet;\nclass VariableAssignmentParselet {\n  parse(parser, tokens, token, varMap, registeredNodes) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    tokens.expectToken('=');\n    const assignment = parser.parse(tokens, 0, varMap, registeredNodes);\n    varMap[token.text] = id;\n    let newNode = {\n      nodeType: 'VariableAssignment',\n      name: token.text,\n      assignment: assignment,\n      outputType: {\n        status: \"Maybe-Undefined\",\n        valueType: (_2_ = (_1_ = assignment) === null || _1_ === void 0 ? void 0 : _1_.outputType) === null || _2_ === void 0 ? void 0 : _2_.valueType,\n        asserts: [],\n        constType: undefined\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.VariableAssignmentParselet = VariableAssignmentParselet;\nclass IdentifierParselet {\n  parse(parser, tokens, token, varMap, registeredNodes) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    const assignmentId = varMap[token.text];\n    if (!assignmentId) {\n      const varParselet = new VariableAssignmentParselet();\n      return varParselet.parse(parser, tokens, token, varMap, registeredNodes);\n    } else {\n      let newNode = {\n        nodeType: 'Identifier',\n        name: token.text,\n        assignmentId: assignmentId,\n        outputType: {\n          status: \"Maybe-Undefined\",\n          valueType: undefined,\n          asserts: [],\n          constType: undefined\n        },\n        pos: position,\n        nodeId: id\n      };\n      registeredNodes[id] = newNode;\n      return newNode;\n    }\n  }\n}\nexports.IdentifierParselet = IdentifierParselet;\n","sourceMap":"{\"version\":3,\"sources\":[\"src/parselet.ts\"],\"names\":[\"parse\",\"_parser\",\"_tokens\",\"token\",\"varMap\",\"registeredNodes\",\"position\",\"position_1\",\"id\",\"newNode\",\"nodeType\",\"value\",\"parseFloat\",\"text\",\"outputType\",\"status\",\"valueType\",\"asserts\",\"constType\",\"pos\",\"nodeId\",\"constructor\",\"parser\",\"tokens\",\"_token\",\"exp\",\"expectToken\",\"tokenType\",\"associativity\",\"ConsequentParselet\",\"left\",\"bindingPower\",\"right\",\"last\",\"operator\",\"undefined\",\"arg1\",\"args\",\"arg2\",\"push\",\"name\",\"predicate\",\"consequent\",\"otherwise\",\"case\",\"assignment\",\"assignmentId\",\"varParselet\",\"VariableAssignmentParselet\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { TokenStream } from './tokenstream';\\nimport { Token, TokenType, BinaryOperationTokenType} from './lexer';\\nimport * as AST from './ast';\\nimport { AbstractParser } from './parser';\\nimport {ParseError, token2pos, join, pos2string} from './position';\\nimport {findBases} from './findBase';\\n\\nexport interface InitialParselet {\\n  parse(parser: AbstractParser,\\n        tokens: TokenStream, token: Token,\\n        varMap: {[key: string]: string},\\n        registeredNodes: {[key: string]: AST.Node}): AST.Node;\\n}\\n\\n\\nexport class NumberParselet implements InitialParselet {\\n  parse(_parser: AbstractParser,\\n        _tokens: TokenStream,\\n        token: Token,\\n        varMap: {[key: string]: string},\\n        registeredNodes: {[key: string]: AST.Node}) {\\n    const position = token2pos(token);\\n    const id = pos2string(position);\\n    // add node to the map\\n    let newNode = {\\n      nodeType: 'Number' as 'Number',\\n      value: parseFloat(token.text),\\n      outputType: { status: 'Definitely' as 'Definitely',\\n                    valueType: 'number' as 'number',\\n                    asserts: [],\\n                    constType: 'Constant' as 'Constant'},\\n      pos: position,\\n      nodeId: id\\n    };\\n    registeredNodes[id] = newNode;\\n    return newNode;\\n  }\\n}\\n\\nexport class BooleanParselet implements InitialParselet {\\n  constructor(private value: boolean) {}\\n  parse(_parser: AbstractParser,\\n        _tokens: TokenStream, token: Token,\\n        varMap: {[key: string]: string},\\n        registeredNodes: {[key: string]: AST.Node}) {\\n    const position = token2pos(token);\\n    const id = pos2string(position);\\n    let newNode = {\\n      nodeType: 'Boolean' as 'Boolean',\\n      value: this.value,\\n      outputType: { status: 'Definitely' as 'Definitely',\\n                    valueType: 'boolean' as 'boolean',\\n                    asserts: [],\\n                    constType: 'Constant' as 'Constant'},\\n      pos: position,\\n      nodeId: id\\n    };\\n    registeredNodes[id] = newNode;\\n    return newNode;\\n  }\\n}\\n\\nexport class ParenParselet implements InitialParselet {\\n  parse(parser: AbstractParser,\\n    tokens: TokenStream,\\n    _token: Token,\\n    varMap: {[key: string]: string},\\n    registeredNodes: {[key: string]: AST.Node}) {\\n\\n    const exp = parser.parse(tokens, 0, varMap, registeredNodes);\\n    tokens.expectToken(')');\\n\\n    return exp;\\n  }\\n}\\n\\nexport abstract class ConsequentParselet {\\n  constructor(\\n    readonly tokenType: TokenType,\\n    readonly associativity: 'left' | 'right'\\n  ) {}\\n  abstract parse(\\n    parser: AbstractParser,\\n    tokens: TokenStream,\\n    left: AST.Node,\\n    token: Token,\\n    varMap: {[key: string]: string},\\n    registeredNodes: {[key: string]: AST.Node}): AST.Node;\\n}\\n\\nexport class BinaryOperatorParselet extends ConsequentParselet {\\n  constructor(\\n    public tokenType: BinaryOperationTokenType,\\n    associativity: 'left' | 'right'\\n  ) {\\n    super(tokenType, associativity);\\n  }\\n\\n  parse(\\n    parser: AbstractParser,\\n    tokens: TokenStream,\\n    left: AST.Node,\\n    token: Token,\\n    varMap: {[key: string]: string},\\n    registeredNodes: {[key: string]: AST.Node}): AST.Node {\\n    const bindingPower = parser.bindingPower(token);\\n\\n    const right = parser.parse(\\n      tokens,\\n      this.associativity == 'left' ? bindingPower : bindingPower - 1,\\n      varMap,\\n      registeredNodes\\n    );\\n    const position = join(left.pos, token2pos(tokens.last()));\\n    const id = pos2string(position);\\n    let newNode = {\\n      nodeType: 'BinaryOperation' as 'BinaryOperation',\\n      operator: this.tokenType,\\n      left,\\n      right,\\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\\n                    valueType: undefined,\\n                    asserts: [],\\n                    constType: undefined},\\n      pos: position,\\n      nodeId: id\\n    };\\n    registeredNodes[id] = newNode;\\n\\n    return newNode;\\n  }\\n}\\n\\n// Parse function calls\\nexport class FunctionParselet implements InitialParselet {\\n  \\n  parse(parser: AbstractParser,\\n    tokens: TokenStream,\\n    token: Token,\\n    varMap: {[key: string]: string},\\n    registeredNodes: {[key: string]: AST.Node}) {\\n\\n    const position = token2pos(token);\\n    const id = pos2string(position);\\n    tokens.expectToken('(');\\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes);  // allow for one argument\\n    let args = [arg1];\\n    if (token.text == \\\"ParseOrderedPair\\\") {\\n      const arg2 = parser.parse(tokens, 0, varMap, registeredNodes);  // allow for second argument\\n      args.push(arg2);\\n    }\\n    tokens.expectToken(')');\\n\\n    let newNode = {\\n      nodeType: 'Function' as 'Function',\\n      name: token.text,\\n      args: args,\\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\\n                    valueType: undefined,\\n                    asserts: [],\\n                    constType: undefined},\\n      pos: position,\\n      nodeId: id\\n    };\\n\\n    registeredNodes[id] = newNode;\\n    return newNode;\\n  }\\n}\\n\\nexport class ChooseParselet implements InitialParselet {\\n  parse(parser: AbstractParser,\\n    tokens: TokenStream,\\n    token: Token,\\n    varMap: {[key: string]: string},\\n    registeredNodes: {[key: string]: AST.Node}) {\\n    const position = token2pos(token);\\n    const id = pos2string(position);\\n\\n    const predicate = parser.parse(tokens, 0, varMap, registeredNodes);\\n    const consequent = parser.parse(tokens, 0, varMap, registeredNodes);\\n    tokens.expectToken('CHOOSE2');\\n    const otherwise = parser.parse(tokens, 0, varMap, registeredNodes);\\n\\n    let newNode = {\\n      nodeType: 'Choose' as 'Choose',\\n      case: { predicate: predicate, consequent: consequent },\\n      otherwise: otherwise,\\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\\n                    valueType: undefined,\\n                    asserts: [],\\n                    constType: undefined},\\n      pos: position,\\n      nodeId: id\\n    };\\n    registeredNodes[id] = newNode;\\n    return newNode;\\n  }\\n}\\n\\nexport class VariableAssignmentParselet implements InitialParselet {\\n  parse(parser: AbstractParser,\\n    tokens: TokenStream,\\n    token: Token,\\n    varMap: {[key: string]: string},\\n    registeredNodes: {[key: string]: AST.Node}) {\\n\\n    const position = token2pos(token);\\n    const id = pos2string(position);\\n    \\n    // deal with variable assignment\\n    tokens.expectToken('=');\\n    const assignment = parser.parse(tokens, 0, varMap, registeredNodes);\\n\\n    // need to save the variable and its assignment in a lookup table\\n    varMap[token.text] = id;\\n    let newNode = {\\n      nodeType: 'VariableAssignment' as 'VariableAssignment',\\n      name: token.text,\\n      assignment: assignment,\\n      outputType: { status: \\\"Maybe-Undefined\\\" as \\\"Maybe-Undefined\\\",\\n                    valueType: assignment?.outputType?.valueType,\\n                    asserts: [],\\n                    constType: undefined},\\n      pos: position,\\n      nodeId: id\\n    };\\n    registeredNodes[id] = newNode;\\n\\n    return newNode;\\n  }\\n}\\n\\nexport class IdentifierParselet implements InitialParselet {\\n  parse(parser: AbstractParser,\\n    tokens: TokenStream,\\n    token: Token,\\n    varMap: {[key: string]: string},\\n    registeredNodes: {[key: string]: AST.Node}) {\\n    \\n    const position = token2pos(token);\\n    const id = pos2string(position);\\n    // need to look up known variables in a lookup table (map?)\\n\\n    const assignmentId = varMap[token.text];\\n\\n    if (!assignmentId) {\\n      const varParselet = new VariableAssignmentParselet();\\n      return varParselet.parse(parser, tokens, token, varMap, registeredNodes);\\n    }\\n    else {\\n      let newNode = {\\n        nodeType: 'Identifier' as 'Identifier',\\n        name: token.text,\\n        assignmentId: assignmentId,\\n        outputType: { status: \\\"Maybe-Undefined\\\" as \\\"Maybe-Undefined\\\",\\n                      valueType: undefined,\\n                      asserts: [],\\n                      constType: undefined},\\n        pos: position,\\n        nodeId: id\\n      };\\n      registeredNodes[id] = newNode;\\n      return newNode;\\n    }\\n  }\\n}\\n\"]}"}