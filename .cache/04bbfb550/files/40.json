{"contents":"const C = \"\\u037c\";\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C);\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\");\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {};\nclass StyleModule {\n  constructor(spec, options) {\n    this.rules = [];\n    let {finish} = options || ({});\n    function splitSelector(selector) {\n      return (/^@/).test(selector) ? [selector] : selector.split(/,\\s*/);\n    }\n    function render(selectors, spec, target, isKeyframes) {\n      let local = [], isAt = (/^@(\\w+)\\b/).exec(selectors[0]), keyframes = isAt && isAt[1] == \"keyframes\";\n      if (isAt && spec == null) return target.push(selectors[0] + \";\");\n      for (let prop in spec) {\n        let value = spec[prop];\n        if ((/&/).test(prop)) {\n          render(prop.split(/,\\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\");\n          render(splitSelector(prop), value, local, keyframes);\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\");\n        }\n      }\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") + \" {\" + local.join(\" \") + \"}\");\n      }\n    }\n    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);\n  }\n  getRules() {\n    return this.rules.join(\"\\n\");\n  }\n  static newName() {\n    let id = top[COUNT] || 1;\n    top[COUNT] = id + 1;\n    return C + id.toString(36);\n  }\n  static mount(root, modules) {\n    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);\n  }\n}\nexports.StyleModule = StyleModule;\nlet adoptedSet = null;\nclass StyleSet {\n  constructor(root) {\n    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != \"undefined\") {\n      if (adoptedSet) {\n        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);\n        return root[SET] = adoptedSet;\n      }\n      this.sheet = new CSSStyleSheet();\n      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);\n      adoptedSet = this;\n    } else {\n      this.styleTag = (root.ownerDocument || root).createElement(\"style\");\n      let target = root.head || root;\n      target.insertBefore(this.styleTag, target.firstChild);\n    }\n    this.modules = [];\n    root[SET] = this;\n  }\n  mount(modules) {\n    let sheet = this.sheet;\n    let pos = 0, j = 0;\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod);\n      if (index < j && index > -1) {\n        this.modules.splice(index, 1);\n        j--;\n        index = -1;\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod);\n        if (sheet) for (let k = 0; k < mod.rules.length; k++) sheet.insertRule(mod.rules[k], pos++);\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length;\n        pos += mod.rules.length;\n        j++;\n      }\n    }\n    if (!sheet) {\n      let text = \"\";\n      for (let i = 0; i < this.modules.length; i++) text += this.modules[i].getRules() + \"\\n\";\n      this.styleTag.textContent = text;\n    }\n  }\n}\n"}