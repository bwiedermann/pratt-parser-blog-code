{"contents":"exports.__esModule = true;\nvar stream_parser_1 = __fusereq(6);\nfunction getTokens(text) {\n  const tokens = [];\n  const state = {\n    line: 1,\n    stack: ['default']\n  };\n  for (const line of text.split('\\n')) {\n    const stream = new stream_parser_1.StringStream();\n    stream.string = line;\n    while (!stream.eol()) {\n      const token = getToken(stream, state);\n      const emitToken = makeEmit(stream, state);\n      const fullToken = emitToken(token);\n      if (token != undefined) {\n        tokens.push(fullToken);\n      }\n      if (stream.start == stream.pos) {\n        throw new Error(`getToken failed to advance stream at position ${stream.pos} in string ${stream.string}`);\n      }\n      stream.start = stream.pos;\n    }\n    state.line += 1;\n  }\n  return tokens;\n}\nexports.getTokens = getTokens;\nfunction getToken(stream, state) {\n  switch (state.stack[state.stack.length - 1]) {\n    default:\n      return getDefaultToken(stream, state);\n  }\n}\nexports.getToken = getToken;\nfunction makeEmit(stream, state) {\n  return function emitToken(type) {\n    return {\n      type,\n      first_column: stream.start,\n      last_column: stream.pos,\n      line: state.line,\n      text: stream.current()\n    };\n  };\n}\nfunction getDefaultToken(stream, state) {\n  if (stream.eatSpace()) {\n    return undefined;\n  }\n  if (stream.match(/-?[0-9]+(\\.[0-9]+)?/)) {\n    return 'NUMBER';\n  }\n  if (stream.match(/\\+/)) {\n    return '+';\n  }\n  if (stream.match(/\\-/)) {\n    return '-';\n  }\n  if (stream.match(/\\*/)) {\n    return '*';\n  }\n  if (stream.match(/\\//)) {\n    return '/';\n  }\n  if (stream.match(/\\|/)) {\n    return '|';\n  }\n  if (stream.match(/\\&/)) {\n    return '&';\n  }\n  if (stream.match(/\\(/)) {\n    return '(';\n  }\n  if (stream.match(/\\)/)) {\n    return ')';\n  }\n  if (stream.match(/\\=/)) {\n    return '=';\n  }\n  if (stream.match(/True/)) {\n    return 'TRUE';\n  }\n  if (stream.match(/False/)) {\n    return 'FALSE';\n  }\n  if (stream.match(/#/)) {\n    if (!stream.match(/\\n/)) {\n      stream.match(/.*/);\n    }\n    return 'COMMENT';\n  }\n  if (stream.match(/WHEN/)) {\n    return 'CHOOSE1';\n  }\n  if (stream.match(/OTHERWISE/)) {\n    return 'CHOOSE2';\n  }\n  if (stream.match(/[A-Z]([a-z|A-Z])*/)) {\n    return 'FUNCTION';\n  }\n  if (stream.match(/[a-z]([a-z|A-Z])*/)) {\n    return 'IDENTIFIER';\n  }\n  stream.next();\n  return 'ERROR';\n}\nexports.getDefaultToken = getDefaultToken;\n","sourceMap":"{\"version\":3,\"sources\":[\"src/lexer.ts\"],\"names\":[\"text\",\"tokens\",\"state\",\"line\",\"stack\",\"split\",\"stream\",\"stream_parser_1\",\"string\",\"eol\",\"token\",\"getToken\",\"emitToken\",\"makeEmit\",\"fullToken\",\"undefined\",\"push\",\"start\",\"pos\",\"Error\",\"length\",\"getDefaultToken\",\"type\",\"first_column\",\"last_column\",\"current\",\"eatSpace\",\"match\",\"next\"],\"mappings\":\";;AAEO,mBAAmBA;QAClBC;QACAC;IAAgBC,MAAM;IAAGC,QAAQ;;aAE5BD,QAAQH,KAAKK,MAAM;UACtBC,aAAaC;IACnBD,OAAOE,SAASL;YACRG,OAAOG;YACPC,QAAQC,SAASL,QAAQJ;YACzBU,YAAYC,SAASP,QAAQJ;YAC7BY,YAAYF,UAAUF;UACxBA,SAASK;QACXd,OAAOe,KAAKF;;UAGVR,OAAOW,SAASX,OAAOY;kBACfC,uDAENb,OAAOY,iBACKZ,OAAOE;;MAGzBF,OAAOW,QAAQX,OAAOY;;IAGxBhB,MAAMC,QAAQ;;SAGTF;;;AAGF,kBACLK,QACAJ;UAIQA,MAAME,MAAMF,MAAME,MAAMgB,SAAS;;aAE9BC,gBAAgBf,QAAQJ;;;;AAIrC,kBAAkBI,QAAsBJ;SAC/B,mBAAmBoB;;MAEtBA;MACAC,cAAcjB,OAAOW;MACrBO,aAAalB,OAAOY;MACpBf,MAAMD,MAAMC;MACZH,MAAMM,OAAOmB;;;;AAKZ,yBACLnB,QACAJ;MAGII,OAAOoB;WAEFX;;MAILT,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAKLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;SACVrB,OAAOqB,MAAM;MAEhBrB,OAAOqB,MAAM;;WAER;;MAILrB,OAAOqB,MAAM;WACR;;MAILrB,OAAOqB,MAAM;WACR;;MAILrB,OAAOqB,MAAM;WACR;;MAKLrB,OAAOqB,MAAM;WACR;;EAGTrB,OAAOsB;SACA\",\"sourcesContent\":[\"import {StringStream} from \\\"@codemirror/stream-parser\\\"\\n\\nexport function getTokens(text: string): Token[] {\\n  const tokens: Token[] = [];\\n  const state: State = {line: 1, stack: ['default']};\\n\\n  for (const line of text.split('\\\\n')) {\\n    const stream = new StringStream();\\n    stream.string = line;\\n    while (!stream.eol()) {\\n      const token = getToken(stream, state);\\n      const emitToken = makeEmit(stream, state);\\n      const fullToken = emitToken(token as TokenType);\\n      if (token != undefined) {\\n        tokens.push(fullToken);\\n      }\\n\\n      if (stream.start == stream.pos) {\\n        throw new Error(\\n          `getToken failed to advance stream at position ${\\n            stream.pos\\n          } in string ${stream.string}`,\\n        );\\n      }\\n      stream.start = stream.pos;\\n    }\\n\\n    state.line += 1;\\n  }\\n\\n  return tokens;\\n}\\n\\nexport function getToken(\\n  stream: StringStream,\\n  state: State,\\n): string | undefined {\\n  //Built for codeMirror streams API\\n  //State is a stack of states\\n  switch (state.stack[state.stack.length - 1]) {\\n    default:\\n      return getDefaultToken(stream, state);\\n  }\\n}\\n\\nfunction makeEmit(stream: StringStream, state: State) {\\n  return function emitToken(type: TokenType): Token {\\n    return {\\n      type,\\n      first_column: stream.start,\\n      last_column: stream.pos,\\n      line: state.line,\\n      text: stream.current(),\\n    };\\n  };\\n}\\n\\nexport function getDefaultToken(\\n  stream: StringStream,\\n  state: State,\\n): string | undefined {\\n  // const emitToken = makeEmit(stream, state);\\n  if (stream.eatSpace()) {\\n    // skip whitespace\\n    return undefined;\\n  }\\n  \\n  // parse both negative and positive numbers\\n  if (stream.match(/-?[0-9]+(\\\\.[0-9]+)?/)) {\\n    return 'NUMBER';\\n  }\\n\\n  if (stream.match(/\\\\+/)) {\\n    return '+';\\n  }\\n\\n  // NOTE: when subtracting a positive number, make sure to use parentheses around it\\n  // e.g. 1-(2) will work but 1-2 won't\\n  if (stream.match(/\\\\-/)) {\\n    return '-';\\n  }\\n\\n  if (stream.match(/\\\\*/)) {\\n    return '*';\\n  }\\n\\n  if (stream.match(/\\\\//)) {\\n    return '/';\\n  }\\n\\n  if (stream.match(/\\\\|/)) {\\n    return '|';\\n  }\\n\\n  if (stream.match(/\\\\&/)) {\\n    return '&';\\n  }\\n\\n  if (stream.match(/\\\\(/)) {\\n    return '(';\\n  }\\n\\n  if (stream.match(/\\\\)/)) {\\n    return ')';\\n  }\\n\\n  if (stream.match(/\\\\=/)) {\\n    return '=';\\n  }\\n\\n  if (stream.match(/True/)) {\\n    return 'TRUE';\\n  }\\n\\n  if (stream.match(/False/)) {\\n    return 'FALSE';\\n  }\\n\\n  if (stream.match(/#/)) {\\n    if (!stream.match(/\\\\n/)) {\\n      // comment lasts till end of line\\n      stream.match(/.*/); // if no eol encountered, comment lasts till end of file\\n    }\\n    return 'COMMENT';\\n  }\\n\\n  // keyword WHEN begins a choose node\\n  if (stream.match(/WHEN/)) {\\n    return 'CHOOSE1';\\n  }\\n\\n  // keyword OTHERWISE is used in a choose node\\n  if (stream.match(/OTHERWISE/)) {\\n    return 'CHOOSE2';\\n  }\\n\\n  // functions start with a capital letter and do not contain numbers\\n  if (stream.match(/[A-Z]([a-z|A-Z])*/)) {\\n    return 'FUNCTION';\\n  }\\n\\n  // The form of a valid identifier is: a lower-case alphabetic character,\\n  // followed by zero or more alpha characters.\\n  if (stream.match(/[a-z]([a-z|A-Z])*/)) {\\n    return 'IDENTIFIER';\\n  }\\n  \\n  stream.next();\\n  return 'ERROR';\\n}\\n\\nexport type BinaryOperationTokenType =\\n  | '+'\\n  | '-'\\n  | '*'\\n  | '/'\\n  | '|' // this is an or\\n  | '&' // this is an and\\n\\nexport type TokenType =\\n  | BinaryOperationTokenType\\n  | 'NUM'\\n  | 'TRUE'\\n  | 'FALSE'\\n  | '('\\n  | ')'\\n  | 'COMMENT'\\n  | 'ERROR'\\n  | 'FUNCTION'\\n  | 'IDENTIFIER'\\n  | 'CHOOSE1'\\n  | 'CHOOSE2'\\n  | '='\\n\\nexport interface Token<T extends TokenType = TokenType> {\\n  type: T;\\n  text: string;\\n  line: number;\\n  first_column: number;\\n  last_column: number;\\n}\\n\\ntype Mode = 'default';\\n\\nexport interface State {\\n  stack: Mode[];\\n  line: number;\\n}\\n\"]}"}