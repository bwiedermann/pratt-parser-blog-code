{"contents":"exports.__esModule = true;\nvar state_1 = __fusereq(16);\nvar style_mod_1 = __fusereq(40);\nvar rangeset_1 = __fusereq(39);\nvar rangeset_2 = __fusereq(39);\nexports.Range = rangeset_2.Range;\nvar text_1 = __fusereq(35);\nvar w3c_keyname_1 = __fusereq(41);\nlet [nav, doc] = typeof navigator != \"undefined\" ? [navigator, document] : [{\n  userAgent: \"\",\n  vendor: \"\",\n  platform: \"\"\n}, {\n  documentElement: {\n    style: {}\n  }\n}];\nconst ie_edge = (/Edge\\/(\\d+)/).exec(nav.userAgent);\nconst ie_upto10 = (/MSIE \\d/).test(nav.userAgent);\nconst ie_11up = (/Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/).exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && (/gecko\\/(\\d+)/i).test(nav.userAgent);\nconst chrome = !ie && (/Chrome\\/(\\d+)/).exec(nav.userAgent);\nconst webkit = (\"webkitFontSmoothing\" in doc.documentElement.style);\nconst safari = !ie && (/Apple Computer/).test(nav.vendor);\nvar browser = {\n  mac: (/Mac/).test(nav.platform),\n  ie,\n  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n  gecko,\n  gecko_version: gecko ? +((/Firefox\\/(\\d+)/).exec(nav.userAgent) || [0, 0])[1] : 0,\n  chrome: !!chrome,\n  chrome_version: chrome ? +chrome[1] : 0,\n  ios: safari && ((/Mobile\\/\\w+/).test(nav.userAgent) || nav.maxTouchPoints > 2),\n  android: (/Android\\b/).test(nav.userAgent),\n  webkit,\n  safari,\n  webkit_version: webkit ? +((/\\bAppleWebKit\\/(\\d+)/).exec(navigator.userAgent) || [0, 0])[1] : 0,\n  tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nfunction getSelection(root) {\n  return root.getSelection ? root.getSelection() : document.getSelection();\n}\nfunction selectionCollapsed(domSel) {\n  let collapsed = domSel.isCollapsed;\n  if (collapsed && browser.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) collapsed = false;\n  return collapsed;\n}\nfunction hasSelection(dom, selection) {\n  if (!selection.anchorNode) return false;\n  try {\n    return dom.contains(selection.anchorNode.nodeType == 3 ? selection.anchorNode.parentNode : selection.anchorNode);\n  } catch (_) {\n    return false;\n  }\n}\nfunction clientRectsFor(dom) {\n  if (dom.nodeType == 3) {\n    let range = tempRange();\n    range.setEnd(dom, dom.nodeValue.length);\n    range.setStart(dom, 0);\n    return range.getClientRects();\n  } else if (dom.nodeType == 1) {\n    return dom.getClientRects();\n  } else {\n    return [];\n  }\n}\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;\n}\nfunction domIndex(node) {\n  for (var index = 0; ; index++) {\n    node = node.previousSibling;\n    if (!node) return index;\n  }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (; ; ) {\n    if (node == targetNode && off == targetOff) return true;\n    if (off == (dir < 0 ? 0 : maxOffset(node))) {\n      if (node.nodeName == \"DIV\") return false;\n      let parent = node.parentNode;\n      if (!parent || parent.nodeType != 1) return false;\n      off = domIndex(node) + (dir < 0 ? 0 : 1);\n      node = parent;\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n      off = dir < 0 ? maxOffset(node) : 0;\n    } else {\n      return false;\n    }\n  }\n}\nfunction maxOffset(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nconst Rect0 = {\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0\n};\nfunction flattenRect(rect, left) {\n  let x = left ? rect.left : rect.right;\n  return {\n    left: x,\n    right: x,\n    top: rect.top,\n    bottom: rect.bottom\n  };\n}\nfunction windowRect(win) {\n  return {\n    left: 0,\n    right: win.innerWidth,\n    top: 0,\n    bottom: win.innerHeight\n  };\n}\nconst ScrollSpace = 5;\nfunction scrollRectIntoView(dom, rect) {\n  let doc = dom.ownerDocument, win = doc.defaultView;\n  for (let cur = dom.parentNode; cur; ) {\n    if (cur.nodeType == 1) {\n      let bounding, top = cur == document.body;\n      if (top) {\n        bounding = windowRect(win);\n      } else {\n        if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n          cur = cur.parentNode;\n          continue;\n        }\n        let rect = cur.getBoundingClientRect();\n        bounding = {\n          left: rect.left,\n          right: rect.left + cur.clientWidth,\n          top: rect.top,\n          bottom: rect.top + cur.clientHeight\n        };\n      }\n      let moveX = 0, moveY = 0;\n      if (rect.top < bounding.top) moveY = -(bounding.top - rect.top + ScrollSpace); else if (rect.bottom > bounding.bottom) moveY = rect.bottom - bounding.bottom + ScrollSpace;\n      if (rect.left < bounding.left) moveX = -(bounding.left - rect.left + ScrollSpace); else if (rect.right > bounding.right) moveX = rect.right - bounding.right + ScrollSpace;\n      if (moveX || moveY) {\n        if (top) {\n          win.scrollBy(moveX, moveY);\n        } else {\n          if (moveY) {\n            let start = cur.scrollTop;\n            cur.scrollTop += moveY;\n            moveY = cur.scrollTop - start;\n          }\n          if (moveX) {\n            let start = cur.scrollLeft;\n            cur.scrollLeft += moveX;\n            moveX = cur.scrollLeft - start;\n          }\n          rect = {\n            left: rect.left - moveX,\n            top: rect.top - moveY,\n            right: rect.right - moveX,\n            bottom: rect.bottom - moveY\n          };\n        }\n      }\n      if (top) break;\n      cur = cur.parentNode;\n    } else if (cur.nodeType == 11) {\n      cur = cur.host;\n    } else {\n      break;\n    }\n  }\n}\nclass DOMSelection {\n  constructor() {\n    this.anchorNode = null;\n    this.anchorOffset = 0;\n    this.focusNode = null;\n    this.focusOffset = 0;\n  }\n  eq(domSel) {\n    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n  }\n  set(domSel) {\n    this.anchorNode = domSel.anchorNode;\n    this.anchorOffset = domSel.anchorOffset;\n    this.focusNode = domSel.focusNode;\n    this.focusOffset = domSel.focusOffset;\n  }\n}\nlet preventScrollSupported = null;\nfunction focusPreventScroll(dom) {\n  if (dom.setActive) return dom.setActive();\n  if (preventScrollSupported) return dom.focus(preventScrollSupported);\n  let stack = [];\n  for (let cur = dom; cur; cur = cur.parentNode) {\n    stack.push(cur, cur.scrollTop, cur.scrollLeft);\n    if (cur == cur.ownerDocument) break;\n  }\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = {\n        preventScroll: true\n      };\n      return true;\n    }\n  } : undefined);\n  if (!preventScrollSupported) {\n    preventScrollSupported = false;\n    for (let i = 0; i < stack.length; ) {\n      let elt = stack[i++], top = stack[i++], left = stack[i++];\n      if (elt.scrollTop != top) elt.scrollTop = top;\n      if (elt.scrollLeft != left) elt.scrollLeft = left;\n    }\n  }\n}\nlet scratchRange;\nfunction tempRange() {\n  return scratchRange || (scratchRange = document.createRange());\n}\nclass DOMPos {\n  constructor(node, offset, precise = true) {\n    this.node = node;\n    this.offset = offset;\n    this.precise = precise;\n  }\n  static before(dom, precise) {\n    return new DOMPos(dom.parentNode, domIndex(dom), precise);\n  }\n  static after(dom, precise) {\n    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);\n  }\n}\nconst none$3 = [];\nclass ContentView {\n  constructor() {\n    this.parent = null;\n    this.dom = null;\n    this.dirty = 2;\n  }\n  get editorView() {\n    if (!this.parent) throw new Error(\"Accessing view in orphan content view\");\n    return this.parent.editorView;\n  }\n  get overrideDOMText() {\n    return null;\n  }\n  get posAtStart() {\n    return this.parent ? this.parent.posBefore(this) : 0;\n  }\n  get posAtEnd() {\n    return this.posAtStart + this.length;\n  }\n  posBefore(view) {\n    let pos = this.posAtStart;\n    for (let child of this.children) {\n      if (child == view) return pos;\n      pos += child.length + child.breakAfter;\n    }\n    throw new RangeError(\"Invalid child in posBefore\");\n  }\n  posAfter(view) {\n    return this.posBefore(view) + view.length;\n  }\n  coordsAt(_pos, _side) {\n    return null;\n  }\n  sync(track) {\n    if (this.dirty & 2) {\n      let parent = this.dom, pos = null;\n      for (let child of this.children) {\n        if (child.dirty) {\n          let next = pos ? pos.nextSibling : parent.firstChild;\n          if (next && !child.dom && !ContentView.get(next)) child.reuseDOM(next);\n          child.sync(track);\n          child.dirty = 0;\n        }\n        if (track && track.node == parent && pos != child.dom) track.written = true;\n        syncNodeInto(parent, pos, child.dom);\n        pos = child.dom;\n      }\n      let next = pos ? pos.nextSibling : parent.firstChild;\n      if (next && track && track.node == parent) track.written = true;\n      while (next) next = rm(next);\n    } else if (this.dirty & 1) {\n      for (let child of this.children) if (child.dirty) {\n        child.sync(track);\n        child.dirty = 0;\n      }\n    }\n  }\n  reuseDOM(_dom) {\n    return false;\n  }\n  localPosFromDOM(node, offset) {\n    let after;\n    if (node == this.dom) {\n      after = this.dom.childNodes[offset];\n    } else {\n      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n      for (; ; ) {\n        let parent = node.parentNode;\n        if (parent == this.dom) break;\n        if (bias == 0 && parent.firstChild != parent.lastChild) {\n          if (node == parent.firstChild) bias = -1; else bias = 1;\n        }\n        node = parent;\n      }\n      if (bias < 0) after = node; else after = node.nextSibling;\n    }\n    if (after == this.dom.firstChild) return 0;\n    while (after && !ContentView.get(after)) after = after.nextSibling;\n    if (!after) return this.length;\n    for (let i = 0, pos = 0; ; i++) {\n      let child = this.children[i];\n      if (child.dom == after) return pos;\n      pos += child.length + child.breakAfter;\n    }\n  }\n  domBoundsAround(from, to, offset = 0) {\n    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n    for (let i = 0, pos = offset; i < this.children.length; i++) {\n      let child = this.children[i], end = pos + child.length;\n      if (pos < from && end > to) return child.domBoundsAround(from, to, pos);\n      if (end >= from && fromI == -1) {\n        fromI = i;\n        fromStart = pos;\n      }\n      if (end >= to && end != pos && toI == -1) {\n        toI = i;\n        toEnd = end;\n        break;\n      }\n      pos = end + child.breakAfter;\n    }\n    return {\n      from: fromStart,\n      to: toEnd < 0 ? offset + this.length : toEnd,\n      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n      endDOM: toI < this.children.length - 1 && toI >= 0 ? this.children[toI + 1].dom : null\n    };\n  }\n  markDirty(andParent = false) {\n    if (this.dirty & 2) return;\n    this.dirty |= 2;\n    this.markParentsDirty(andParent);\n  }\n  markParentsDirty(childList) {\n    for (let parent = this.parent; parent; parent = parent.parent) {\n      if (childList) parent.dirty |= 2;\n      if (parent.dirty & 1) return;\n      parent.dirty |= 1;\n      childList = false;\n    }\n  }\n  setParent(parent) {\n    if (this.parent != parent) {\n      this.parent = parent;\n      if (this.dirty) this.markParentsDirty(true);\n    }\n  }\n  setDOM(dom) {\n    this.dom = dom;\n    dom.cmView = this;\n  }\n  get rootView() {\n    for (let v = this; ; ) {\n      let parent = v.parent;\n      if (!parent) return v;\n      v = parent;\n    }\n  }\n  replaceChildren(from, to, children = none$3) {\n    this.markDirty();\n    for (let i = from; i < to; i++) this.children[i].parent = null;\n    this.children.splice(from, to - from, ...children);\n    for (let i = 0; i < children.length; i++) children[i].setParent(this);\n  }\n  ignoreMutation(_rec) {\n    return false;\n  }\n  ignoreEvent(_event) {\n    return false;\n  }\n  childCursor(pos = this.length) {\n    return new ChildCursor(this.children, pos, this.children.length);\n  }\n  childPos(pos, bias = 1) {\n    return this.childCursor().findPos(pos, bias);\n  }\n  toString() {\n    let name = this.constructor.name.replace(\"View\", \"\");\n    return name + (this.children.length ? \"(\" + this.children.join() + \")\" : this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") + (this.breakAfter ? \"#\" : \"\");\n  }\n  static get(node) {\n    return node.cmView;\n  }\n}\nContentView.prototype.breakAfter = 0;\nfunction rm(dom) {\n  let next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next;\n}\nfunction syncNodeInto(parent, after, dom) {\n  let next = after ? after.nextSibling : parent.firstChild;\n  if (dom.parentNode == parent) while (next != dom) next = rm(next); else parent.insertBefore(dom, next);\n}\nclass ChildCursor {\n  constructor(children, pos, i) {\n    this.children = children;\n    this.pos = pos;\n    this.i = i;\n    this.off = 0;\n  }\n  findPos(pos, bias = 1) {\n    for (; ; ) {\n      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n        this.off = pos - this.pos;\n        return this;\n      }\n      let next = this.children[--this.i];\n      this.pos -= next.length + next.breakAfter;\n    }\n  }\n}\nconst none$2 = [];\nclass InlineView extends ContentView {\n  become(_other) {\n    return false;\n  }\n  getSide() {\n    return 0;\n  }\n}\nInlineView.prototype.children = none$2;\nconst MaxJoinLen = 256;\nclass TextView extends InlineView {\n  constructor(text) {\n    super();\n    this.text = text;\n  }\n  get length() {\n    return this.text.length;\n  }\n  createDOM(textDOM) {\n    this.setDOM(textDOM || document.createTextNode(this.text));\n  }\n  sync(track) {\n    if (!this.dom) this.createDOM();\n    if (this.dom.nodeValue != this.text) {\n      if (track && track.node == this.dom) track.written = true;\n      this.dom.nodeValue = this.text;\n    }\n  }\n  reuseDOM(dom) {\n    if (dom.nodeType != 3) return false;\n    this.createDOM(dom);\n    return true;\n  }\n  merge(from, to, source) {\n    if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen)) return false;\n    this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n    this.markDirty();\n    return true;\n  }\n  slice(from) {\n    return new TextView(this.text.slice(from));\n  }\n  localPosFromDOM(node, offset) {\n    return node == this.dom ? offset : offset ? this.text.length : 0;\n  }\n  domAtPos(pos) {\n    return new DOMPos(this.dom, pos);\n  }\n  domBoundsAround(_from, _to, offset) {\n    return {\n      from: offset,\n      to: offset + this.length,\n      startDOM: this.dom,\n      endDOM: this.dom.nextSibling\n    };\n  }\n  coordsAt(pos, side) {\n    return textCoords(this.dom, pos, side);\n  }\n}\nclass MarkView extends InlineView {\n  constructor(mark, children = [], length = 0) {\n    super();\n    this.mark = mark;\n    this.children = children;\n    this.length = length;\n    for (let ch of children) ch.setParent(this);\n  }\n  createDOM() {\n    let dom = document.createElement(this.mark.tagName);\n    if (this.mark.class) dom.className = this.mark.class;\n    if (this.mark.attrs) for (let name in this.mark.attrs) dom.setAttribute(name, this.mark.attrs[name]);\n    this.setDOM(dom);\n  }\n  sync(track) {\n    if (!this.dom) this.createDOM();\n    super.sync(track);\n  }\n  merge(from, to, source, openStart, openEnd) {\n    if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n    mergeInlineChildren(this, from, to, source ? source.children : none$2, openStart - 1, openEnd - 1);\n    this.markDirty();\n    return true;\n  }\n  slice(from) {\n    return new MarkView(this.mark, sliceInlineChildren(this.children, from), this.length - from);\n  }\n  domAtPos(pos) {\n    return inlineDOMAtPos(this.dom, this.children, pos);\n  }\n  coordsAt(pos, side) {\n    return coordsInChildren(this, pos, side);\n  }\n}\nfunction textCoords(text, pos, side) {\n  let length = text.nodeValue.length;\n  if (pos > length) pos = length;\n  let from = pos, to = pos, flatten = 0;\n  if (pos == 0 && side < 0 || pos == length && side >= 0) {\n    if (!(browser.chrome || browser.gecko)) {\n      if (pos) {\n        from--;\n        flatten = 1;\n      } else {\n        to++;\n        flatten = -1;\n      }\n    }\n  } else {\n    if (side < 0) from--; else to++;\n  }\n  let range = tempRange();\n  range.setEnd(text, to);\n  range.setStart(text, from);\n  let rects = range.getClientRects();\n  if (!rects.length) return Rect0;\n  let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n  if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, r => r.width) || rect;\n  return flatten ? flattenRect(rect, flatten < 0) : rect;\n}\nclass WidgetView extends InlineView {\n  constructor(widget, length, side) {\n    super();\n    this.widget = widget;\n    this.length = length;\n    this.side = side;\n  }\n  static create(widget, length, side) {\n    return new (widget.customView || WidgetView)(widget, length, side);\n  }\n  slice(from) {\n    return WidgetView.create(this.widget, this.length - from, this.side);\n  }\n  sync() {\n    if (!this.dom || !this.widget.updateDOM(this.dom)) {\n      this.setDOM(this.widget.toDOM(this.editorView));\n      this.dom.contentEditable = \"false\";\n    }\n  }\n  getSide() {\n    return this.side;\n  }\n  merge(from, to, source, openStart, openEnd) {\n    if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n    this.length = from + (source ? source.length : 0) + (this.length - to);\n    return true;\n  }\n  become(other) {\n    if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {\n      if (this.widget.constructor == other.widget.constructor) {\n        if (!this.widget.eq(other.widget)) this.markDirty(true);\n        this.widget = other.widget;\n        return true;\n      }\n    }\n    return false;\n  }\n  ignoreMutation() {\n    return true;\n  }\n  ignoreEvent(event) {\n    return this.widget.ignoreEvent(event);\n  }\n  get overrideDOMText() {\n    if (this.length == 0) return text_1.Text.empty;\n    let top = this;\n    while (top.parent) top = top.parent;\n    let view = top.editorView, text = view && view.state.doc, start = this.posAtStart;\n    return text ? text.slice(start, start + this.length) : text_1.Text.empty;\n  }\n  domAtPos(pos) {\n    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n  }\n  domBoundsAround() {\n    return null;\n  }\n  coordsAt(pos, side) {\n    let rects = this.dom.getClientRects(), rect = null;\n    if (!rects.length) return Rect0;\n    for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {\n      rect = rects[i];\n      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;\n    }\n    return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect : flattenRect(rect, pos == 0);\n  }\n}\nclass CompositionView extends WidgetView {\n  domAtPos(pos) {\n    return new DOMPos(this.widget.text, pos);\n  }\n  sync() {\n    if (!this.dom) this.setDOM(this.widget.toDOM());\n  }\n  localPosFromDOM(node, offset) {\n    return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;\n  }\n  ignoreMutation() {\n    return false;\n  }\n  get overrideDOMText() {\n    return null;\n  }\n  coordsAt(pos, side) {\n    return textCoords(this.widget.text, pos, side);\n  }\n}\nfunction mergeInlineChildren(parent, from, to, elts, openStart, openEnd) {\n  let cur = parent.childCursor();\n  let {i: toI, off: toOff} = cur.findPos(to, 1);\n  let {i: fromI, off: fromOff} = cur.findPos(from, -1);\n  let dLen = from - to;\n  for (let view of elts) dLen += view.length;\n  parent.length += dLen;\n  let {children} = parent;\n  if (fromI == toI && fromOff) {\n    let start = children[fromI];\n    if (elts.length == 1 && start.merge(fromOff, toOff, elts[0], openStart, openEnd)) return;\n    if (elts.length == 0) {\n      start.merge(fromOff, toOff, null, openStart, openEnd);\n      return;\n    }\n    let after = start.slice(toOff);\n    if (after.merge(0, 0, elts[elts.length - 1], 0, openEnd)) elts[elts.length - 1] = after; else elts.push(after);\n    toI++;\n    openEnd = toOff = 0;\n  }\n  if (toOff) {\n    let end = children[toI];\n    if (elts.length && end.merge(0, toOff, elts[elts.length - 1], 0, openEnd)) {\n      elts.pop();\n      openEnd = 0;\n    } else {\n      end.merge(0, toOff, null, 0, 0);\n    }\n  } else if (toI < children.length && elts.length && children[toI].merge(0, 0, elts[elts.length - 1], 0, openEnd)) {\n    elts.pop();\n    openEnd = 0;\n  }\n  if (fromOff) {\n    let start = children[fromI];\n    if (elts.length && start.merge(fromOff, start.length, elts[0], openStart, 0)) {\n      elts.shift();\n      openStart = 0;\n    } else {\n      start.merge(fromOff, start.length, null, 0, 0);\n    }\n    fromI++;\n  } else if (fromI && elts.length) {\n    let end = children[fromI - 1];\n    if (end.merge(end.length, end.length, elts[0], openStart, 0)) {\n      elts.shift();\n      openStart = 0;\n    }\n  }\n  while (fromI < toI && elts.length && children[toI - 1].become(elts[elts.length - 1])) {\n    elts.pop();\n    toI--;\n    openEnd = 0;\n  }\n  while (fromI < toI && elts.length && children[fromI].become(elts[0])) {\n    elts.shift();\n    fromI++;\n    openStart = 0;\n  }\n  if (!elts.length && fromI && toI < children.length && openStart && openEnd && children[toI].merge(0, 0, children[fromI - 1], openStart, openEnd)) fromI--;\n  if (elts.length || fromI != toI) parent.replaceChildren(fromI, toI, elts);\n}\nfunction sliceInlineChildren(children, from) {\n  let result = [], off = 0;\n  for (let elt of children) {\n    let end = off + elt.length;\n    if (end > from) result.push(off < from ? elt.slice(from - off) : elt);\n    off = end;\n  }\n  return result;\n}\nfunction inlineDOMAtPos(dom, children, pos) {\n  let i = 0;\n  for (let off = 0; i < children.length; i++) {\n    let child = children[i], end = off + child.length;\n    if (end == off && child.getSide() <= 0) continue;\n    if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);\n    if (pos <= off) break;\n    off = end;\n  }\n  for (; i > 0; i--) {\n    let before = children[i - 1].dom;\n    if (before.parentNode == dom) return DOMPos.after(before);\n  }\n  return new DOMPos(dom, 0);\n}\nfunction joinInlineInto(parent, view, open) {\n  let last, {children} = parent;\n  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n    joinInlineInto(last, view.children[0], open - 1);\n  } else {\n    children.push(view);\n    view.setParent(parent);\n  }\n  parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n  for (let off = 0, i = 0; i < view.children.length; i++) {\n    let child = view.children[i], end = off + child.length;\n    if (end == off && child.getSide() <= 0) continue;\n    if (side <= 0 || end == view.length ? end >= pos : end > pos) return child.coordsAt(pos - off, side);\n    off = end;\n  }\n  return (view.dom.lastChild || view.dom).getBoundingClientRect();\n}\nfunction combineAttrs(source, target) {\n  for (let name in source) {\n    if (name == \"class\" && target.class) target.class += \" \" + source.class; else if (name == \"style\" && target.style) target.style += \";\" + source.style; else target[name] = source[name];\n  }\n  return target;\n}\nfunction attrsEq(a, b) {\n  if (a == b) return true;\n  if (!a || !b) return false;\n  let keysA = Object.keys(a), keysB = Object.keys(b);\n  if (keysA.length != keysB.length) return false;\n  for (let key of keysA) {\n    if (keysB.indexOf(key) == -1 || a[key] !== b[key]) return false;\n  }\n  return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n  if (prev) for (let name in prev) if (!(attrs && (name in attrs))) dom.removeAttribute(name);\n  if (attrs) for (let name in attrs) if (!(prev && prev[name] == attrs[name])) dom.setAttribute(name, attrs[name]);\n}\nclass WidgetType {\n  eq(_widget) {\n    return false;\n  }\n  updateDOM(_dom) {\n    return false;\n  }\n  compare(other) {\n    return this == other || this.constructor == other.constructor && this.eq(other);\n  }\n  get estimatedHeight() {\n    return -1;\n  }\n  ignoreEvent(_event) {\n    return true;\n  }\n  get customView() {\n    return null;\n  }\n}\nvar BlockType;\n(function (BlockType) {\n  BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n  BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n  BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n  BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n})(BlockType || (BlockType = {}));\nclass Decoration extends rangeset_1.RangeValue {\n  constructor(startSide, endSide, widget, spec) {\n    super();\n    this.startSide = startSide;\n    this.endSide = endSide;\n    this.widget = widget;\n    this.spec = spec;\n  }\n  get heightRelevant() {\n    return false;\n  }\n  static mark(spec) {\n    return new MarkDecoration(spec);\n  }\n  static widget(spec) {\n    let side = spec.side || 0;\n    if (spec.block) side += (200000000 + 1) * (side > 0 ? 1 : -1);\n    return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);\n  }\n  static replace(spec) {\n    let block = !!spec.block;\n    let {start, end} = getInclusive(spec);\n    let startSide = block ? -200000000 * (start ? 2 : 1) : 100000000 * (start ? -1 : 1);\n    let endSide = block ? 200000000 * (end ? 2 : 1) : 100000000 * (end ? 1 : -1);\n    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n  }\n  static line(spec) {\n    return new LineDecoration(spec);\n  }\n  static set(of, sort = false) {\n    return rangeset_1.RangeSet.of(of, sort);\n  }\n  hasHeight() {\n    return this.widget ? this.widget.estimatedHeight > -1 : false;\n  }\n}\nDecoration.none = rangeset_1.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n  constructor(spec) {\n    let {start, end} = getInclusive(spec);\n    super(100000000 * (start ? -1 : 1), 100000000 * (end ? 1 : -1), null, spec);\n    this.tagName = spec.tagName || \"span\";\n    this.class = spec.class || \"\";\n    this.attrs = spec.attributes || null;\n  }\n  eq(other) {\n    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);\n  }\n  range(from, to = from) {\n    if (from >= to) throw new RangeError(\"Mark decorations may not be empty\");\n    return super.range(from, to);\n  }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n  constructor(spec) {\n    super(-100000000, -100000000, null, spec);\n  }\n  eq(other) {\n    return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);\n  }\n  range(from, to = from) {\n    if (to != from) throw new RangeError(\"Line decoration ranges must be zero-length\");\n    return super.range(from, to);\n  }\n}\nLineDecoration.prototype.mapMode = state_1.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n  constructor(spec, startSide, endSide, block, widget, isReplace) {\n    super(startSide, endSide, widget, spec);\n    this.block = block;\n    this.isReplace = isReplace;\n    this.mapMode = !block ? state_1.MapMode.TrackDel : startSide < 0 ? state_1.MapMode.TrackBefore : state_1.MapMode.TrackAfter;\n  }\n  get type() {\n    return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n  }\n  get heightRelevant() {\n    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;\n  }\n  eq(other) {\n    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;\n  }\n  range(from, to = from) {\n    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide < 0)) throw new RangeError(\"Invalid range for replacement decoration\");\n    if (!this.isReplace && to != from) throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n    return super.range(from, to);\n  }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec) {\n  let {inclusiveStart: start, inclusiveEnd: end} = spec;\n  if (start == null) start = spec.inclusive;\n  if (end == null) end = spec.inclusive;\n  return {\n    start: start || false,\n    end: end || false\n  };\n}\nfunction widgetsEq(a, b) {\n  return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n  let last = ranges.length - 1;\n  if (last >= 0 && ranges[last] + margin > from) ranges[last] = Math.max(ranges[last], to); else ranges.push(from, to);\n}\nclass LineView extends ContentView {\n  constructor() {\n    super(...arguments);\n    this.children = [];\n    this.length = 0;\n    this.prevAttrs = undefined;\n    this.attrs = null;\n    this.breakAfter = 0;\n  }\n  merge(from, to, source, takeDeco, openStart, openEnd) {\n    if (source) {\n      if (!(source instanceof LineView)) return false;\n      if (!this.dom) source.transferDOM(this);\n    }\n    if (takeDeco) this.setDeco(source ? source.attrs : null);\n    mergeInlineChildren(this, from, to, source ? source.children : none$1, openStart, openEnd);\n    return true;\n  }\n  split(at) {\n    let end = new LineView();\n    end.breakAfter = this.breakAfter;\n    if (this.length == 0) return end;\n    let {i, off} = this.childPos(at);\n    if (off) {\n      end.append(this.children[i].slice(off), 0);\n      this.children[i].merge(off, this.children[i].length, null, 0, 0);\n      i++;\n    }\n    for (let j = i; j < this.children.length; j++) end.append(this.children[j], 0);\n    while (i > 0 && this.children[i - 1].length == 0) {\n      this.children[i - 1].parent = null;\n      i--;\n    }\n    this.children.length = i;\n    this.markDirty();\n    this.length = at;\n    return end;\n  }\n  transferDOM(other) {\n    if (!this.dom) return;\n    other.setDOM(this.dom);\n    other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n    this.prevAttrs = undefined;\n    this.dom = null;\n  }\n  setDeco(attrs) {\n    if (!attrsEq(this.attrs, attrs)) {\n      if (this.dom) {\n        this.prevAttrs = this.attrs;\n        this.markDirty();\n      }\n      this.attrs = attrs;\n    }\n  }\n  append(child, openStart) {\n    joinInlineInto(this, child, openStart);\n  }\n  addLineDeco(deco) {\n    let attrs = deco.spec.attributes;\n    if (attrs) this.attrs = combineAttrs(attrs, this.attrs || ({}));\n  }\n  domAtPos(pos) {\n    return inlineDOMAtPos(this.dom, this.children, pos);\n  }\n  sync(track) {\n    if (!this.dom) {\n      this.setDOM(document.createElement(\"div\"));\n      this.dom.className = \"cm-line\";\n      this.prevAttrs = this.attrs ? null : undefined;\n    }\n    if (this.prevAttrs !== undefined) {\n      updateAttrs(this.dom, this.prevAttrs, this.attrs);\n      this.dom.classList.add(\"cm-line\");\n      this.prevAttrs = undefined;\n    }\n    super.sync(track);\n    let last = this.dom.lastChild;\n    if (!last || last.nodeName != \"BR\" && ContentView.get(last) instanceof WidgetView) {\n      let hack = document.createElement(\"BR\");\n      hack.cmIgnore = true;\n      this.dom.appendChild(hack);\n    }\n  }\n  measureTextSize() {\n    if (this.children.length == 0 || this.length > 20) return null;\n    let totalWidth = 0;\n    for (let child of this.children) {\n      if (!(child instanceof TextView)) return null;\n      let rects = clientRectsFor(child.dom);\n      if (rects.length != 1) return null;\n      totalWidth += rects[0].width;\n    }\n    return {\n      lineHeight: this.dom.getBoundingClientRect().height,\n      charWidth: totalWidth / this.length\n    };\n  }\n  coordsAt(pos, side) {\n    return coordsInChildren(this, pos, side);\n  }\n  match(_other) {\n    return false;\n  }\n  get type() {\n    return BlockType.Text;\n  }\n  static find(docView, pos) {\n    for (let i = 0, off = 0; ; i++) {\n      let block = docView.children[i], end = off + block.length;\n      if (end >= pos) {\n        if (block instanceof LineView) return block;\n        if (block.length) return null;\n      }\n      off = end + block.breakAfter;\n    }\n  }\n}\nconst none$1 = [];\nclass BlockWidgetView extends ContentView {\n  constructor(widget, length, type) {\n    super();\n    this.widget = widget;\n    this.length = length;\n    this.type = type;\n    this.breakAfter = 0;\n  }\n  merge(from, to, source, _takeDeco, openStart, openEnd) {\n    if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n    this.length = from + (source ? source.length : 0) + (this.length - to);\n    return true;\n  }\n  domAtPos(pos) {\n    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n  }\n  split(at) {\n    let len = this.length - at;\n    this.length = at;\n    return new BlockWidgetView(this.widget, len, this.type);\n  }\n  get children() {\n    return none$1;\n  }\n  sync() {\n    if (!this.dom || !this.widget.updateDOM(this.dom)) {\n      this.setDOM(this.widget.toDOM(this.editorView));\n      this.dom.contentEditable = \"false\";\n    }\n  }\n  get overrideDOMText() {\n    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : state_1.Text.empty;\n  }\n  domBoundsAround() {\n    return null;\n  }\n  match(other) {\n    if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {\n      if (!other.widget.eq(this.widget)) this.markDirty(true);\n      this.widget = other.widget;\n      this.length = other.length;\n      this.breakAfter = other.breakAfter;\n      return true;\n    }\n    return false;\n  }\n  ignoreMutation() {\n    return true;\n  }\n  ignoreEvent(event) {\n    return this.widget.ignoreEvent(event);\n  }\n}\nclass ContentBuilder {\n  constructor(doc, pos, end) {\n    this.doc = doc;\n    this.pos = pos;\n    this.end = end;\n    this.content = [];\n    this.curLine = null;\n    this.breakAtStart = 0;\n    this.openStart = -1;\n    this.openEnd = -1;\n    this.text = \"\";\n    this.textOff = 0;\n    this.cursor = doc.iter();\n    this.skip = pos;\n  }\n  posCovered() {\n    if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n    let last = this.content[this.content.length - 1];\n    return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\n  }\n  getLine() {\n    if (!this.curLine) this.content.push(this.curLine = new LineView());\n    return this.curLine;\n  }\n  addWidget(view) {\n    this.curLine = null;\n    this.content.push(view);\n  }\n  finish() {\n    if (!this.posCovered()) this.getLine();\n  }\n  wrapMarks(view, active) {\n    for (let i = active.length - 1; i >= 0; i--) view = new MarkView(active[i], [view], view.length);\n    return view;\n  }\n  buildText(length, active, openStart) {\n    while (length > 0) {\n      if (this.textOff == this.text.length) {\n        let {value, lineBreak, done} = this.cursor.next(this.skip);\n        this.skip = 0;\n        if (done) throw new Error(\"Ran out of text content when drawing inline views\");\n        if (lineBreak) {\n          if (!this.posCovered()) this.getLine();\n          if (this.content.length) this.content[this.content.length - 1].breakAfter = 1; else this.breakAtStart = 1;\n          this.curLine = null;\n          length--;\n          continue;\n        } else {\n          this.text = value;\n          this.textOff = 0;\n        }\n      }\n      let take = Math.min(this.text.length - this.textOff, length, 512);\n      this.getLine().append(this.wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n      this.textOff += take;\n      length -= take;\n      openStart = 0;\n    }\n  }\n  span(from, to, active, openStart) {\n    this.buildText(to - from, active, openStart);\n    this.pos = to;\n    if (this.openStart < 0) this.openStart = openStart;\n  }\n  point(from, to, deco, active, openStart) {\n    let len = to - from;\n    if (deco instanceof PointDecoration) {\n      if (deco.block) {\n        let {type} = deco;\n        if (type == BlockType.WidgetAfter && !this.posCovered()) this.getLine();\n        this.addWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type));\n      } else {\n        let widget = this.wrapMarks(WidgetView.create(deco.widget || new NullWidget(\"span\"), len, deco.startSide), active);\n        this.getLine().append(widget, openStart);\n      }\n    } else if (this.doc.lineAt(this.pos).from == this.pos) {\n      this.getLine().addLineDeco(deco);\n    }\n    if (len) {\n      if (this.textOff + len <= this.text.length) {\n        this.textOff += len;\n      } else {\n        this.skip += len - (this.text.length - this.textOff);\n        this.text = \"\";\n        this.textOff = 0;\n      }\n      this.pos = to;\n    }\n    if (this.openStart < 0) this.openStart = openStart;\n  }\n  static build(text, from, to, decorations) {\n    let builder = new ContentBuilder(text, from, to);\n    builder.openEnd = rangeset_1.RangeSet.spans(decorations, from, to, builder);\n    if (builder.openStart < 0) builder.openStart = builder.openEnd;\n    builder.finish();\n    return builder;\n  }\n}\nclass NullWidget extends WidgetType {\n  constructor(tag) {\n    super();\n    this.tag = tag;\n  }\n  eq(other) {\n    return other.tag == this.tag;\n  }\n  toDOM() {\n    return document.createElement(this.tag);\n  }\n  updateDOM(elt) {\n    return elt.nodeName.toLowerCase() == this.tag;\n  }\n}\nconst none = [];\nconst clickAddsSelectionRange = state_1.Facet.define();\nconst dragMovesSelection$1 = state_1.Facet.define();\nconst mouseSelectionStyle = state_1.Facet.define();\nconst exceptionSink = state_1.Facet.define();\nconst updateListener = state_1.Facet.define();\nconst inputHandler = state_1.Facet.define();\nfunction logException(state, exception, context) {\n  let handler = state.facet(exceptionSink);\n  if (handler.length) handler[0](exception); else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception); else if (context) console.error(context + \":\", exception); else console.error(exception);\n}\nconst editable = state_1.Facet.define({\n  combine: values => values.length ? values[0] : true\n});\nclass PluginFieldProvider {\n  constructor(field, get) {\n    this.field = field;\n    this.get = get;\n  }\n}\nclass PluginField {\n  from(get) {\n    return new PluginFieldProvider(this, get);\n  }\n  static define() {\n    return new PluginField();\n  }\n}\nPluginField.decorations = PluginField.define();\nPluginField.scrollMargins = PluginField.define();\nlet nextPluginID = 0;\nconst viewPlugin = state_1.Facet.define();\nclass ViewPlugin {\n  constructor(id, create, fields) {\n    this.id = id;\n    this.create = create;\n    this.fields = fields;\n    this.extension = viewPlugin.of(this);\n  }\n  static define(create, spec) {\n    let {eventHandlers, provide, decorations} = spec || ({});\n    let fields = [];\n    if (provide) for (let provider of Array.isArray(provide) ? provide : [provide]) fields.push(provider);\n    if (eventHandlers) fields.push(domEventHandlers.from(value => ({\n      plugin: value,\n      handlers: eventHandlers\n    })));\n    if (decorations) fields.push(PluginField.decorations.from(decorations));\n    return new ViewPlugin(nextPluginID++, create, fields);\n  }\n  static fromClass(cls, spec) {\n    return ViewPlugin.define(view => new cls(view), spec);\n  }\n}\nconst domEventHandlers = PluginField.define();\nclass PluginInstance {\n  constructor(spec) {\n    this.spec = spec;\n    this.mustUpdate = null;\n    this.value = null;\n  }\n  takeField(type, target) {\n    for (let {field, get} of this.spec.fields) if (field == type) target.push(get(this.value));\n  }\n  update(view) {\n    if (!this.value) {\n      try {\n        this.value = this.spec.create(view);\n      } catch (e) {\n        logException(view.state, e, \"CodeMirror plugin crashed\");\n        return PluginInstance.dummy;\n      }\n    } else if (this.mustUpdate) {\n      let update = this.mustUpdate;\n      this.mustUpdate = null;\n      if (!this.value.update) return this;\n      try {\n        this.value.update(update);\n      } catch (e) {\n        logException(update.state, e, \"CodeMirror plugin crashed\");\n        if (this.value.destroy) try {\n          this.value.destroy();\n        } catch (_) {}\n        return PluginInstance.dummy;\n      }\n    }\n    return this;\n  }\n  destroy(view) {\n    var _a;\n    if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n      try {\n        this.value.destroy();\n      } catch (e) {\n        logException(view.state, e, \"CodeMirror plugin crashed\");\n      }\n    }\n  }\n}\nPluginInstance.dummy = new PluginInstance(ViewPlugin.define(() => ({})));\nconst editorAttributes = state_1.Facet.define({\n  combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\nconst contentAttributes = state_1.Facet.define({\n  combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\nconst decorations = state_1.Facet.define();\nconst styleModule = state_1.Facet.define();\nclass ChangedRange {\n  constructor(fromA, toA, fromB, toB) {\n    this.fromA = fromA;\n    this.toA = toA;\n    this.fromB = fromB;\n    this.toB = toB;\n  }\n  join(other) {\n    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n  }\n  addToSet(set) {\n    let i = set.length, me = this;\n    for (; i > 0; i--) {\n      let range = set[i - 1];\n      if (range.fromA > me.toA) continue;\n      if (range.toA < me.fromA) break;\n      me = me.join(range);\n      set.splice(i - 1, 1);\n    }\n    set.splice(i, 0, me);\n    return set;\n  }\n  static extendWithRanges(diff, ranges) {\n    if (ranges.length == 0) return diff;\n    let result = [];\n    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {\n      let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n      let end = next ? next.fromB : 1e9;\n      while (rI < ranges.length && ranges[rI] < end) {\n        let from = ranges[rI], to = ranges[rI + 1];\n        let fromB = Math.max(posB, from), toB = Math.min(end, to);\n        if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n        if (to > end) break; else rI += 2;\n      }\n      if (!next) return result;\n      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n      posA = next.toA;\n      posB = next.toB;\n    }\n  }\n}\nclass ViewUpdate {\n  constructor(view, state, transactions = none) {\n    this.view = view;\n    this.state = state;\n    this.transactions = transactions;\n    this.flags = 0;\n    this.startState = view.state;\n    this.changes = state_1.ChangeSet.empty(this.startState.doc.length);\n    for (let tr of transactions) this.changes = this.changes.compose(tr.changes);\n    let changedRanges = [];\n    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n    this.changedRanges = changedRanges;\n    let focus = view.hasFocus;\n    if (focus != view.inputState.notifiedFocused) {\n      view.inputState.notifiedFocused = focus;\n      this.flags |= 1;\n    }\n    if (this.docChanged) this.flags |= 2;\n  }\n  get viewportChanged() {\n    return (this.flags & 4) > 0;\n  }\n  get heightChanged() {\n    return (this.flags & 2) > 0;\n  }\n  get geometryChanged() {\n    return this.docChanged || (this.flags & (16 | 2)) > 0;\n  }\n  get focusChanged() {\n    return (this.flags & 1) > 0;\n  }\n  get docChanged() {\n    return this.transactions.some(tr => tr.docChanged);\n  }\n  get selectionSet() {\n    return this.transactions.some(tr => tr.selection);\n  }\n  get empty() {\n    return this.flags == 0 && this.transactions.length == 0;\n  }\n}\nclass DocView extends ContentView {\n  constructor(view) {\n    super();\n    this.view = view;\n    this.compositionDeco = Decoration.none;\n    this.decorations = [];\n    this.minWidth = 0;\n    this.minWidthFrom = 0;\n    this.minWidthTo = 0;\n    this.impreciseAnchor = null;\n    this.impreciseHead = null;\n    this.setDOM(view.contentDOM);\n    this.children = [new LineView()];\n    this.children[0].setParent(this);\n    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);\n  }\n  get root() {\n    return this.view.root;\n  }\n  get editorView() {\n    return this.view;\n  }\n  get length() {\n    return this.view.state.doc.length;\n  }\n  update(update) {\n    let changedRanges = update.changedRanges;\n    if (this.minWidth > 0 && changedRanges.length) {\n      if (!changedRanges.every(({fromA, toA}) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n        this.minWidth = 0;\n      } else {\n        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n      }\n    }\n    if (this.view.inputState.composing < 0) this.compositionDeco = Decoration.none; else if (update.transactions.length) this.compositionDeco = computeCompositionDeco(this.view, update.changes);\n    let forceSelection = (browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines;\n    let prevDeco = this.decorations, deco = this.updateDeco();\n    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n    let pointerSel = update.transactions.some(tr => tr.annotation(state_1.Transaction.userEvent) == \"pointerselection\");\n    if (this.dirty == 0 && changedRanges.length == 0 && !(update.flags & (4 | 8)) && update.state.selection.main.from >= this.view.viewport.from && update.state.selection.main.to <= this.view.viewport.to) {\n      this.updateSelection(forceSelection, pointerSel);\n      return false;\n    } else {\n      this.updateInner(changedRanges, deco, update.startState.doc.length, forceSelection, pointerSel);\n      return true;\n    }\n  }\n  updateInner(changes, deco, oldLength, forceSelection = false, pointerSel = false) {\n    this.updateChildren(changes, deco, oldLength);\n    this.view.observer.ignore(() => {\n      this.dom.style.height = this.view.viewState.domHeight + \"px\";\n      this.dom.style.minWidth = this.minWidth ? this.minWidth + \"px\" : \"\";\n      let track = browser.chrome ? {\n        node: getSelection(this.view.root).focusNode,\n        written: false\n      } : undefined;\n      this.sync(track);\n      this.dirty = 0;\n      if (track === null || track === void 0 ? void 0 : track.written) forceSelection = true;\n      this.updateSelection(forceSelection, pointerSel);\n      this.dom.style.height = \"\";\n    });\n  }\n  updateChildren(changes, deco, oldLength) {\n    let cursor = this.childCursor(oldLength);\n    for (let i = changes.length - 1; ; i--) {\n      let next = i >= 0 ? changes[i] : null;\n      if (!next) break;\n      let {fromA, toA, fromB, toB} = next;\n      let {content, breakAtStart, openStart, openEnd} = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);\n      let {i: toI, off: toOff} = cursor.findPos(toA, 1);\n      let {i: fromI, off: fromOff} = cursor.findPos(fromA, -1);\n      this.replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n    }\n  }\n  replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd) {\n    let before = this.children[fromI], last = content.length ? content[content.length - 1] : null;\n    let breakAtEnd = last ? last.breakAfter : breakAtStart;\n    if (fromI == toI && !breakAtStart && !breakAtEnd && content.length < 2 && before.merge(fromOff, toOff, content.length ? last : null, fromOff == 0, openStart, openEnd)) return;\n    let after = this.children[toI];\n    if (toOff < after.length || after.children.length && after.children[after.children.length - 1].length == 0) {\n      if (fromI == toI) {\n        after = after.split(toOff);\n        toOff = 0;\n      }\n      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n        content[content.length - 1] = after;\n      } else {\n        if (toOff || after.children.length && after.children[0].length == 0) after.merge(0, toOff, null, false, 0, openEnd);\n        content.push(after);\n      }\n    } else if (after.breakAfter) {\n      if (last) last.breakAfter = 1; else breakAtStart = 1;\n    }\n    toI++;\n    before.breakAfter = breakAtStart;\n    if (fromOff > 0) {\n      if (!breakAtStart && content.length && before.merge(fromOff, before.length, content[0], false, openStart, 0)) {\n        before.breakAfter = content.shift().breakAfter;\n      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n        before.merge(fromOff, before.length, null, false, openStart, 0);\n      }\n      fromI++;\n    }\n    while (fromI < toI && content.length) {\n      if (this.children[toI - 1].match(content[content.length - 1])) (toI--, content.pop()); else if (this.children[fromI].match(content[0])) (fromI++, content.shift()); else break;\n    }\n    if (fromI < toI || content.length) this.replaceChildren(fromI, toI, content);\n  }\n  updateSelection(force = false, fromPointer = false) {\n    if (!(fromPointer || this.mayControlSelection())) return;\n    let main = this.view.state.selection.main;\n    let anchor = this.domAtPos(main.anchor);\n    let head = main.empty ? anchor : this.domAtPos(main.head);\n    if (browser.gecko && main.empty && betweenUneditable(anchor)) {\n      let dummy = document.createTextNode(\"\");\n      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n      anchor = head = new DOMPos(dummy, 0);\n      force = true;\n    }\n    let domSel = getSelection(this.root);\n    if (force || !domSel.focusNode || browser.gecko && main.empty && nextToUneditable(domSel.focusNode, domSel.focusOffset) || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n      this.view.observer.ignore(() => {\n        if (main.empty) {\n          if (browser.gecko) {\n            let nextTo = nextToUneditable(anchor.node, anchor.offset);\n            if (nextTo && nextTo != (1 | 2)) {\n              let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);\n              if (text) anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);\n            }\n          }\n          domSel.collapse(anchor.node, anchor.offset);\n          if (main.bidiLevel != null && domSel.cursorBidiLevel != null) domSel.cursorBidiLevel = main.bidiLevel;\n        } else if (domSel.extend) {\n          domSel.collapse(anchor.node, anchor.offset);\n          domSel.extend(head.node, head.offset);\n        } else {\n          let range = document.createRange();\n          if (main.anchor > main.head) [anchor, head] = [head, anchor];\n          range.setEnd(head.node, head.offset);\n          range.setStart(anchor.node, anchor.offset);\n          domSel.removeAllRanges();\n          domSel.addRange(range);\n        }\n      });\n    }\n    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n  }\n  enforceCursorAssoc() {\n    let cursor = this.view.state.selection.main;\n    let sel = getSelection(this.root);\n    if (!cursor.empty || !cursor.assoc || !sel.modify) return;\n    let line = LineView.find(this, cursor.head);\n    if (!line) return;\n    let lineStart = line.posAtStart;\n    if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;\n    let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n    if (!before || !after || before.bottom > after.top) return;\n    let dom = this.domAtPos(cursor.head + cursor.assoc);\n    sel.collapse(dom.node, dom.offset);\n    sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n  }\n  mayControlSelection() {\n    return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, getSelection(this.root));\n  }\n  nearest(dom) {\n    for (let cur = dom; cur; ) {\n      let domView = ContentView.get(cur);\n      if (domView && domView.rootView == this) return domView;\n      cur = cur.parentNode;\n    }\n    return null;\n  }\n  posFromDOM(node, offset) {\n    let view = this.nearest(node);\n    if (!view) throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n    return view.localPosFromDOM(node, offset) + view.posAtStart;\n  }\n  domAtPos(pos) {\n    let {i, off} = this.childCursor().findPos(pos, -1);\n    for (; i < this.children.length - 1; ) {\n      let child = this.children[i];\n      if (off < child.length || child instanceof LineView) break;\n      i++;\n      off = 0;\n    }\n    return this.children[i].domAtPos(off);\n  }\n  coordsAt(pos, side) {\n    for (let off = this.length, i = this.children.length - 1; ; i--) {\n      let child = this.children[i], start = off - child.breakAfter - child.length;\n      if (pos > start || pos == start && (child.type == BlockType.Text || !i || this.children[i - 1].breakAfter)) return child.coordsAt(pos - start, side);\n      off = start;\n    }\n  }\n  measureVisibleLineHeights() {\n    let result = [], {from, to} = this.view.viewState.viewport;\n    let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n    for (let pos = 0, i = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = pos + child.length;\n      if (end > to) break;\n      if (pos >= from) {\n        result.push(child.dom.getBoundingClientRect().height);\n        let width = child.dom.scrollWidth;\n        if (width > minWidth) {\n          this.minWidth = minWidth = width;\n          this.minWidthFrom = pos;\n          this.minWidthTo = end;\n        }\n      }\n      pos = end + child.breakAfter;\n    }\n    return result;\n  }\n  measureTextSize() {\n    for (let child of this.children) {\n      if (child instanceof LineView) {\n        let measure = child.measureTextSize();\n        if (measure) return measure;\n      }\n    }\n    let dummy = document.createElement(\"div\"), lineHeight, charWidth;\n    dummy.className = \"cm-line\";\n    dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n    this.view.observer.ignore(() => {\n      this.dom.appendChild(dummy);\n      let rect = clientRectsFor(dummy.firstChild)[0];\n      lineHeight = dummy.getBoundingClientRect().height;\n      charWidth = rect ? rect.width / 27 : 7;\n      dummy.remove();\n    });\n    return {\n      lineHeight,\n      charWidth\n    };\n  }\n  childCursor(pos = this.length) {\n    let i = this.children.length;\n    if (i) pos -= this.children[--i].length;\n    return new ChildCursor(this.children, pos, i);\n  }\n  computeBlockGapDeco() {\n    let deco = [], vs = this.view.viewState;\n    for (let pos = 0, i = 0; ; i++) {\n      let next = i == vs.viewports.length ? null : vs.viewports[i];\n      let end = next ? next.from - 1 : this.length;\n      if (end > pos) {\n        let height = vs.lineAt(end, 0).bottom - vs.lineAt(pos, 0).top;\n        deco.push(Decoration.replace({\n          widget: new BlockGapWidget(height),\n          block: true,\n          inclusive: true\n        }).range(pos, end));\n      }\n      if (!next) break;\n      pos = next.to + 1;\n    }\n    return Decoration.set(deco);\n  }\n  updateDeco() {\n    return this.decorations = [this.computeBlockGapDeco(), this.view.viewState.lineGapDeco, this.compositionDeco, ...this.view.state.facet(decorations), ...this.view.pluginField(PluginField.decorations)];\n  }\n  scrollPosIntoView(pos, side) {\n    let rect = this.coordsAt(pos, side);\n    if (!rect) return;\n    let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;\n    for (let margins of this.view.pluginField(PluginField.scrollMargins)) if (margins) {\n      let {left, right, top, bottom} = margins;\n      if (left != null) mLeft = Math.max(mLeft, left);\n      if (right != null) mRight = Math.max(mRight, right);\n      if (top != null) mTop = Math.max(mTop, top);\n      if (bottom != null) mBottom = Math.max(mBottom, bottom);\n    }\n    scrollRectIntoView(this.dom, {\n      left: rect.left - mLeft,\n      top: rect.top - mTop,\n      right: rect.right + mRight,\n      bottom: rect.bottom + mBottom\n    });\n  }\n}\nfunction betweenUneditable(pos) {\n  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") && (pos.offset < pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nclass BlockGapWidget extends WidgetType {\n  constructor(height) {\n    super();\n    this.height = height;\n  }\n  toDOM() {\n    let elt = document.createElement(\"div\");\n    this.updateDOM(elt);\n    return elt;\n  }\n  eq(other) {\n    return other.height == this.height;\n  }\n  updateDOM(elt) {\n    elt.style.height = this.height + \"px\";\n    return true;\n  }\n  get estimatedHeight() {\n    return this.height;\n  }\n}\nfunction computeCompositionDeco(view, changes) {\n  let sel = getSelection(view.root);\n  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n  if (!textNode) return Decoration.none;\n  let cView = view.docView.nearest(textNode);\n  let from, to, topNode = textNode;\n  if (cView instanceof InlineView) {\n    while (cView.parent instanceof InlineView) cView = cView.parent;\n    from = cView.posAtStart;\n    to = from + cView.length;\n    topNode = cView.dom;\n  } else if (cView instanceof LineView) {\n    while (topNode.parentNode != cView.dom) topNode = topNode.parentNode;\n    let prev = topNode.previousSibling;\n    while (prev && !ContentView.get(prev)) prev = prev.previousSibling;\n    from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;\n  } else {\n    return Decoration.none;\n  }\n  let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));\n  let text = textNode.nodeValue, {state} = view;\n  if (newTo - newFrom < text.length) {\n    if (state.sliceDoc(newFrom, Math.min(state.doc.length, newFrom + text.length)) == text) newTo = newFrom + text.length; else if (state.sliceDoc(Math.max(0, newTo - text.length), newTo) == text) newFrom = newTo - text.length; else return Decoration.none;\n  } else if (state.sliceDoc(newFrom, newTo) != text) {\n    return Decoration.none;\n  }\n  return Decoration.set(Decoration.replace({\n    widget: new CompositionWidget(topNode, textNode)\n  }).range(newFrom, newTo));\n}\nclass CompositionWidget extends WidgetType {\n  constructor(top, text) {\n    super();\n    this.top = top;\n    this.text = text;\n  }\n  eq(other) {\n    return this.top == other.top && this.text == other.text;\n  }\n  toDOM() {\n    return this.top;\n  }\n  ignoreEvent() {\n    return false;\n  }\n  get customView() {\n    return CompositionView;\n  }\n}\nfunction nearbyTextNode(node, offset, side) {\n  for (; ; ) {\n    if (node.nodeType == 3) return node;\n    if (node.nodeType == 1 && offset > 0 && side <= 0) {\n      node = node.childNodes[offset - 1];\n      offset = maxOffset(node);\n    } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n      node = node.childNodes[offset];\n      offset = 0;\n    } else {\n      return null;\n    }\n  }\n}\nfunction nextToUneditable(node, offset) {\n  if (node.nodeType != 1) return 0;\n  return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 : 0);\n}\nclass DecorationComparator$1 {\n  constructor() {\n    this.changes = [];\n  }\n  compareRange(from, to) {\n    addRange(from, to, this.changes);\n  }\n  comparePoint(from, to) {\n    addRange(from, to, this.changes);\n  }\n}\nfunction findChangedDeco(a, b, diff) {\n  let comp = new DecorationComparator$1();\n  rangeset_1.RangeSet.compare(a, b, diff, comp);\n  return comp.changes;\n}\nvar Direction;\n(function (Direction) {\n  Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n  Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n})(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\nfunction dec(str) {\n  let result = [];\n  for (let i = 0; i < str.length; i++) result.push(1 << +str[i]);\n  return result;\n}\nconst LowTypes = dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\nconst ArabicTypes = dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nfunction charType(ch) {\n  return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 : 0x2000 <= ch && ch <= 0x200b ? 256 : ch == 0x200c ? 256 : 1;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\nclass BidiSpan {\n  constructor(from, to, level) {\n    this.from = from;\n    this.to = to;\n    this.level = level;\n  }\n  get dir() {\n    return this.level % 2 ? RTL : LTR;\n  }\n  side(end, dir) {\n    return this.dir == dir == end ? this.to : this.from;\n  }\n  static find(order, index, level, assoc) {\n    let maybe = -1;\n    for (let i = 0; i < order.length; i++) {\n      let span = order[i];\n      if (span.from <= index && span.to >= index) {\n        if (span.level == level) return i;\n        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;\n      }\n    }\n    if (maybe < 0) throw new RangeError(\"Index out of range\");\n    return maybe;\n  }\n}\nconst types = [];\nfunction computeOrder(line, direction) {\n  let len = line.length, outerType = direction == LTR ? 1 : 2;\n  if (!line || outerType == 1 && !BidiRE.test(line)) return trivialOrder(len);\n  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n    let type = charType(line.charCodeAt(i));\n    if (type == 512) type = prev; else if (type == 8 && prevStrong == 4) type = 16;\n    types[i] = type == 4 ? 2 : type;\n    if (type & 7) prevStrong = type;\n    prev = type;\n  }\n  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n    let type = types[i];\n    if (type == 128) {\n      if (i < len - 1 && prev == types[i + 1] && prev & 24) type = types[i] = prev; else types[i] = 256;\n    } else if (type == 64) {\n      let end = i + 1;\n      while (end < len && types[end] == 64) end++;\n      let replace = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;\n      for (let j = i; j < end; j++) types[j] = replace;\n      i = end - 1;\n    } else if (type == 8 && prevStrong == 1) {\n      types[i] = 1;\n    }\n    prev = type;\n    if (type & 7) prevStrong = type;\n  }\n  for (let i = 0; i < len; i++) {\n    if (types[i] == 256) {\n      let end = i + 1;\n      while (end < len && types[end] == 256) end++;\n      let beforeL = (i ? types[i - 1] : outerType) == 1;\n      let afterL = (end < len ? types[end] : outerType) == 1;\n      let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;\n      for (let j = i; j < end; j++) types[j] = replace;\n      i = end - 1;\n    }\n  }\n  let order = [];\n  if (outerType == 1) {\n    for (let i = 0; i < len; ) {\n      let start = i, rtl = types[i++] != 1;\n      while (i < len && rtl == (types[i] != 1)) i++;\n      if (rtl) {\n        for (let j = i; j > start; ) {\n          let end = j, l = types[--j] != 2;\n          while (j > start && l == (types[j - 1] != 2)) j--;\n          order.push(new BidiSpan(j, end, l ? 2 : 1));\n        }\n      } else {\n        order.push(new BidiSpan(start, i, 0));\n      }\n    }\n  } else {\n    for (let i = 0; i < len; ) {\n      let start = i, rtl = types[i++] == 2;\n      while (i < len && rtl == (types[i] == 2)) i++;\n      order.push(new BidiSpan(start, i, rtl ? 1 : 2));\n    }\n  }\n  return order;\n}\nfunction trivialOrder(length) {\n  return [new BidiSpan(0, length, 0)];\n}\nlet movedOver = \"\";\nfunction moveVisually(line, order, dir, start, forward) {\n  var _a;\n  let startIndex = start.head - line.from, spanI = -1;\n  if (startIndex == 0) {\n    if (!forward || !line.length) return null;\n    if (order[0].level != dir) {\n      startIndex = order[0].side(false, dir);\n      spanI = 0;\n    }\n  } else if (startIndex == line.length) {\n    if (forward) return null;\n    let last = order[order.length - 1];\n    if (last.level != dir) {\n      startIndex = last.side(true, dir);\n      spanI = order.length - 1;\n    }\n  }\n  if (spanI < 0) spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n  let span = order[spanI];\n  if (startIndex == span.side(forward, dir)) {\n    span = order[spanI += forward ? 1 : -1];\n    startIndex = span.side(!forward, dir);\n  }\n  let indexForward = forward == (span.dir == dir);\n  let nextIndex = text_1.findClusterBreak(line.text, startIndex, indexForward);\n  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n  if (nextIndex != span.side(forward, dir)) return state_1.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);\n  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n  if (!nextSpan && span.level != dir) return state_1.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);\n  if (nextSpan && nextSpan.level < span.level) return state_1.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, 0, nextSpan.level);\n  return state_1.EditorSelection.cursor(nextIndex + line.from, 0, span.level);\n}\nfunction groupAt(state, pos, bias = 1) {\n  let categorize = state.charCategorizer(pos);\n  let line = state.doc.lineAt(pos), linePos = pos - line.from;\n  if (line.length == 0) return state_1.EditorSelection.cursor(pos);\n  if (linePos == 0) bias = 1; else if (linePos == line.length) bias = -1;\n  let from = linePos, to = linePos;\n  if (bias < 0) from = text_1.findClusterBreak(line.text, linePos, false); else to = text_1.findClusterBreak(line.text, linePos);\n  let cat = categorize(line.text.slice(from, to));\n  while (from > 0) {\n    let prev = text_1.findClusterBreak(line.text, from, false);\n    if (categorize(line.text.slice(prev, from)) != cat) break;\n    from = prev;\n  }\n  while (to < line.length) {\n    let next = text_1.findClusterBreak(line.text, to);\n    if (categorize(line.text.slice(to, next)) != cat) break;\n    to = next;\n  }\n  return state_1.EditorSelection.range(from + line.from, to + line.from);\n}\nfunction getdx(x, rect) {\n  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n  return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n  return top < rect.top ? {\n    top,\n    left: rect.left,\n    right: rect.right,\n    bottom: rect.bottom\n  } : rect;\n}\nfunction upBot(rect, bottom) {\n  return bottom > rect.bottom ? {\n    top: rect.top,\n    left: rect.left,\n    right: rect.right,\n    bottom\n  } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n  let closest, closestRect, closestX, closestY;\n  let above, below, aboveRect, belowRect;\n  for (let child = parent.firstChild; child; child = child.nextSibling) {\n    let rects = clientRectsFor(child);\n    for (let i = 0; i < rects.length; i++) {\n      let rect = rects[i];\n      if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n      let dx = getdx(x, rect), dy = getdy(y, rect);\n      if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n      if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n        closest = child;\n        closestRect = rect;\n        closestX = dx;\n        closestY = dy;\n      }\n      if (dx == 0) {\n        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n          above = child;\n          aboveRect = rect;\n        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n          below = child;\n          belowRect = rect;\n        }\n      } else if (aboveRect && yOverlap(aboveRect, rect)) {\n        aboveRect = upBot(aboveRect, rect.bottom);\n      } else if (belowRect && yOverlap(belowRect, rect)) {\n        belowRect = upTop(belowRect, rect.top);\n      }\n    }\n  }\n  if (aboveRect && aboveRect.bottom >= y) {\n    closest = above;\n    closestRect = aboveRect;\n  } else if (belowRect && belowRect.top <= y) {\n    closest = below;\n    closestRect = belowRect;\n  }\n  if (!closest) return {\n    node: parent,\n    offset: 0\n  };\n  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n  if (closest.nodeType == 3) return domPosInText(closest, clipX, y);\n  if (!closestX && closest.contentEditable == \"true\") return domPosAtCoords(closest, clipX, y);\n  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n  return {\n    node: parent,\n    offset\n  };\n}\nfunction domPosInText(node, x, y) {\n  let len = node.nodeValue.length, range = tempRange();\n  for (let i = 0; i < len; i++) {\n    range.setEnd(node, i + 1);\n    range.setStart(node, i);\n    let rects = range.getClientRects();\n    for (let j = 0; j < rects.length; j++) {\n      let rect = rects[j];\n      if (rect.top == rect.bottom) continue;\n      if (rect.left - 1 <= x && rect.right + 1 >= x && rect.top - 1 <= y && rect.bottom + 1 >= y) {\n        let right = x >= (rect.left + rect.right) / 2, after = right;\n        if (browser.chrome || browser.gecko) {\n          range.setEnd(node, i);\n          let rectBefore = range.getBoundingClientRect();\n          if (rectBefore.left == rect.right) after = !right;\n        }\n        return {\n          node,\n          offset: i + (after ? 1 : 0)\n        };\n      }\n    }\n  }\n  return {\n    node,\n    offset: 0\n  };\n}\nfunction posAtCoords(view, {x, y}, bias = -1) {\n  let content = view.contentDOM.getBoundingClientRect(), block;\n  let halfLine = view.defaultLineHeight / 2;\n  for (let bounced = false; ; ) {\n    block = view.blockAtHeight(y, content.top);\n    if (block.top > y || block.bottom < y) {\n      bias = block.top > y ? -1 : 1;\n      y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));\n      if (bounced) return -1; else bounced = true;\n    }\n    if (block.type == BlockType.Text) break;\n    y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n  }\n  let lineStart = block.from;\n  if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : null;\n  if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : null;\n  x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n  let root = view.root, element = root.elementFromPoint(x, y);\n  let node, offset = -1;\n  if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {\n    if (root.caretPositionFromPoint) {\n      let pos = root.caretPositionFromPoint(x, y);\n      if (pos) ({offsetNode: node, offset} = pos);\n    } else if (root.caretRangeFromPoint) {\n      let range = root.caretRangeFromPoint(x, y);\n      if (range) ({startContainer: node, startOffset: offset} = range);\n    }\n  }\n  if (!node || !view.docView.dom.contains(node)) {\n    let line = LineView.find(view.docView, lineStart);\n    ({node, offset} = domPosAtCoords(line.dom, x, y));\n  }\n  return view.docView.posFromDOM(node, offset);\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n  let line = view.state.doc.lineAt(start.head);\n  let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n  if (coords) {\n    let editorRect = view.dom.getBoundingClientRect();\n    let pos = view.posAtCoords({\n      x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n      y: (coords.top + coords.bottom) / 2\n    });\n    if (pos != null) return state_1.EditorSelection.cursor(pos, forward ? -1 : 1);\n  }\n  let lineView = LineView.find(view.docView, start.head);\n  let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;\n  return state_1.EditorSelection.cursor(end, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n  for (let cur = start, check = null; ; ) {\n    let next = moveVisually(line, spans, view.textDirection, cur, forward), char = movedOver;\n    if (!next) {\n      if (line.number == (forward ? view.state.doc.lines : 1)) return cur;\n      char = \"\\n\";\n      line = view.state.doc.line(line.number + (forward ? 1 : -1));\n      spans = view.bidiSpans(line);\n      next = state_1.EditorSelection.cursor(forward ? line.from : line.to);\n    }\n    if (!check) {\n      if (!by) return next;\n      check = by(char);\n    } else if (!check(char)) {\n      return cur;\n    }\n    cur = next;\n  }\n}\nfunction byGroup(view, pos, start) {\n  let categorize = view.state.charCategorizer(pos);\n  let cat = categorize(start);\n  return next => {\n    let nextCat = categorize(next);\n    if (cat == state_1.CharCategory.Space) cat = nextCat;\n    return cat == nextCat;\n  };\n}\nfunction moveVertically(view, start, forward, distance) {\n  var _a;\n  let startPos = start.head, dir = forward ? 1 : -1;\n  if (startPos == (forward ? view.state.doc.length : 0)) return state_1.EditorSelection.cursor(startPos);\n  let startCoords = view.coordsAtPos(startPos);\n  if (startCoords) {\n    let rect = view.dom.getBoundingClientRect();\n    let goal = (_a = start.goalColumn) !== null && _a !== void 0 ? _a : startCoords.left - rect.left;\n    let resolvedGoal = rect.left + goal;\n    let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;\n    for (let startY = dir < 0 ? startCoords.top : startCoords.bottom, extra = 0; extra < 50; extra += 10) {\n      let pos = posAtCoords(view, {\n        x: resolvedGoal,\n        y: startY + (dist + extra) * dir\n      }, dir);\n      if (pos == null) break;\n      if (pos != startPos) return state_1.EditorSelection.cursor(pos, undefined, undefined, goal);\n    }\n  }\n  let {doc} = view.state, line = doc.lineAt(startPos), tabSize = view.state.tabSize;\n  let goal = start.goalColumn, goalCol = 0;\n  if (goal == null) {\n    for (const iter = doc.iterRange(line.from, startPos); !iter.next().done; ) goalCol = text_1.countColumn(iter.value, goalCol, tabSize);\n    goal = goalCol * view.defaultCharacterWidth;\n  } else {\n    goalCol = Math.round(goal / view.defaultCharacterWidth);\n  }\n  if (dir < 0 && line.from == 0) return state_1.EditorSelection.cursor(0); else if (dir > 0 && line.to == doc.length) return state_1.EditorSelection.cursor(line.to);\n  let otherLine = doc.line(line.number + dir);\n  let result = otherLine.from;\n  let seen = 0;\n  for (const iter = doc.iterRange(otherLine.from, otherLine.to); seen >= goalCol && !iter.next().done; ) {\n    const {offset, leftOver} = text_1.findColumn(iter.value, seen, goalCol, tabSize);\n    seen = goalCol - leftOver;\n    result += offset;\n  }\n  return state_1.EditorSelection.cursor(result, undefined, undefined, goal);\n}\nclass InputState {\n  constructor(view) {\n    this.lastKeyCode = 0;\n    this.lastKeyTime = 0;\n    this.lastSelectionOrigin = null;\n    this.lastSelectionTime = 0;\n    this.lastEscPress = 0;\n    this.scrollHandlers = [];\n    this.registeredEvents = [];\n    this.customHandlers = [];\n    this.composing = -1;\n    this.compositionEndedAt = 0;\n    this.mouseSelection = null;\n    for (let type in handlers) {\n      let handler = handlers[type];\n      view.contentDOM.addEventListener(type, event => {\n        if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event) || type == \"keydown\" && this.screenKeyEvent(view, event)) return;\n        if (this.mustFlushObserver(event)) view.observer.forceFlush();\n        if (this.runCustomHandlers(type, view, event)) event.preventDefault(); else handler(view, event);\n      });\n      this.registeredEvents.push(type);\n    }\n    view.contentDOM.addEventListener(\"keydown\", event => {\n      view.inputState.lastKeyCode = event.keyCode;\n      view.inputState.lastKeyTime = Date.now();\n    });\n    this.notifiedFocused = view.hasFocus;\n    this.ensureHandlers(view);\n  }\n  setSelectionOrigin(origin) {\n    this.lastSelectionOrigin = origin;\n    this.lastSelectionTime = Date.now();\n  }\n  ensureHandlers(view) {\n    let handlers = this.customHandlers = view.pluginField(domEventHandlers);\n    for (let set of handlers) {\n      for (let type in set.handlers) if (this.registeredEvents.indexOf(type) < 0 && type != \"scroll\") {\n        this.registeredEvents.push(type);\n        view.contentDOM.addEventListener(type, event => {\n          if (!eventBelongsToEditor(view, event)) return;\n          if (this.runCustomHandlers(type, view, event)) event.preventDefault();\n        });\n      }\n    }\n  }\n  runCustomHandlers(type, view, event) {\n    for (let set of this.customHandlers) {\n      let handler = set.handlers[type], handled = false;\n      if (handler) {\n        try {\n          handled = handler.call(set.plugin, event, view);\n        } catch (e) {\n          logException(view.state, e);\n        }\n        if (handled || event.defaultPrevented) {\n          if (browser.android && type == \"keydown\" && event.keyCode == 13) view.observer.flushSoon();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  runScrollHandlers(view, event) {\n    for (let set of this.customHandlers) {\n      let handler = set.handlers.scroll;\n      if (handler) {\n        try {\n          handler.call(set.plugin, event, view);\n        } catch (e) {\n          logException(view.state, e);\n        }\n      }\n    }\n  }\n  ignoreDuringComposition(event) {\n    if (!(/^key/).test(event.type)) return false;\n    if (this.composing > 0) return true;\n    if (browser.safari && event.timeStamp - this.compositionEndedAt < 500) {\n      this.compositionEndedAt = 0;\n      return true;\n    }\n    return false;\n  }\n  screenKeyEvent(view, event) {\n    let protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2000;\n    if (event.keyCode == 27) this.lastEscPress = Date.now(); else if (modifierCodes.indexOf(event.keyCode) < 0) this.lastEscPress = 0;\n    return protectedTab;\n  }\n  mustFlushObserver(event) {\n    return event.type == \"keydown\" && event.keyCode != 229 || event.type == \"compositionend\";\n  }\n  startMouseSelection(view, event, style) {\n    if (this.mouseSelection) this.mouseSelection.destroy();\n    this.mouseSelection = new MouseSelection(this, view, event, style);\n  }\n  update(update) {\n    if (this.mouseSelection) this.mouseSelection.update(update);\n    this.lastKeyCode = this.lastSelectionTime = 0;\n  }\n  destroy() {\n    if (this.mouseSelection) this.mouseSelection.destroy();\n  }\n}\nconst modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];\nclass MouseSelection {\n  constructor(inputState, view, startEvent, style) {\n    this.inputState = inputState;\n    this.view = view;\n    this.startEvent = startEvent;\n    this.style = style;\n    let doc = view.contentDOM.ownerDocument;\n    doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n    doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n    this.extend = startEvent.shiftKey;\n    this.multiple = view.state.facet(state_1.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n    this.dragMove = dragMovesSelection(view, startEvent);\n    this.dragging = isInPrimarySelection(view, startEvent) ? null : false;\n    if (this.dragging === false) {\n      startEvent.preventDefault();\n      this.select(startEvent);\n    }\n  }\n  move(event) {\n    if (event.buttons == 0) return this.destroy();\n    if (this.dragging !== false) return;\n    this.select(event);\n  }\n  up(event) {\n    if (this.dragging == null) this.select(this.startEvent);\n    if (!this.dragging) event.preventDefault();\n    this.destroy();\n  }\n  destroy() {\n    let doc = this.view.contentDOM.ownerDocument;\n    doc.removeEventListener(\"mousemove\", this.move);\n    doc.removeEventListener(\"mouseup\", this.up);\n    this.inputState.mouseSelection = null;\n  }\n  select(event) {\n    let selection = this.style.get(event, this.extend, this.multiple);\n    if (!selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc) this.view.dispatch({\n      selection,\n      annotations: state_1.Transaction.userEvent.of(\"pointerselection\"),\n      scrollIntoView: true\n    });\n  }\n  update(update) {\n    if (update.docChanged && this.dragging) this.dragging = this.dragging.map(update.changes);\n    this.style.update(update);\n  }\n}\nfunction addsSelectionRange(view, event) {\n  let facet = view.state.facet(clickAddsSelectionRange);\n  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n  let facet = view.state.facet(dragMovesSelection$1);\n  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n  let {main} = view.state.selection;\n  if (main.empty) return false;\n  let sel = getSelection(view.root);\n  if (sel.rangeCount == 0) return true;\n  let rects = sel.getRangeAt(0).getClientRects();\n  for (let i = 0; i < rects.length; i++) {\n    let rect = rects[i];\n    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;\n  }\n  return false;\n}\nfunction eventBelongsToEditor(view, event) {\n  if (!event.bubbles) return true;\n  if (event.defaultPrevented) return false;\n  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode) if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;\n  return true;\n}\nconst handlers = Object.create(null);\nconst brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;\nfunction capturePaste(view) {\n  let parent = view.dom.parentNode;\n  if (!parent) return;\n  let target = parent.appendChild(document.createElement(\"textarea\"));\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.focus();\n  setTimeout(() => {\n    view.focus();\n    target.remove();\n    doPaste(view, target.value);\n  }, 50);\n}\nfunction doPaste(view, input) {\n  let {state} = view, changes, i = 1, text = state.toText(input);\n  let byLine = text.lines == state.selection.ranges.length;\n  let linewise = lastLinewiseCopy && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();\n  if (linewise) {\n    let lastLine = -1;\n    changes = state.changeByRange(range => {\n      let line = state.doc.lineAt(range.from);\n      if (line.from == lastLine) return {\n        range\n      };\n      lastLine = line.from;\n      let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n      return {\n        changes: {\n          from: line.from,\n          insert\n        },\n        range: state_1.EditorSelection.cursor(range.from + insert.length)\n      };\n    });\n  } else if (byLine) {\n    changes = state.changeByRange(range => {\n      let line = text.line(i++);\n      return {\n        changes: {\n          from: range.from,\n          to: range.to,\n          insert: line.text\n        },\n        range: state_1.EditorSelection.cursor(range.from + line.length)\n      };\n    });\n  } else {\n    changes = state.replaceSelection(text);\n  }\n  view.dispatch(changes, {\n    annotations: state_1.Transaction.userEvent.of(\"paste\"),\n    scrollIntoView: true\n  });\n}\nfunction mustCapture(event) {\n  let mods = (event.ctrlKey ? 1 : 0) | (event.metaKey ? 8 : 0) | (event.altKey ? 2 : 0) | (event.shiftKey ? 4 : 0);\n  let code = event.keyCode, macCtrl = browser.mac && mods == 1;\n  return code == 8 || macCtrl && code == 72 || code == 46 || macCtrl && code == 68 || code == 27 || mods == (browser.mac ? 8 : 1) && (code == 66 || code == 73 || code == 89 || code == 90);\n}\nhandlers.keydown = (view, event) => {\n  if (mustCapture(event)) event.preventDefault();\n  view.inputState.setSelectionOrigin(\"keyboardselection\");\n};\nlet lastTouch = 0;\nfunction mouseLikeTouchEvent(e) {\n  return e.touches.length == 1 && e.touches[0].radiusX <= 1 && e.touches[0].radiusY <= 1;\n}\nhandlers.touchstart = (view, e) => {\n  if (!mouseLikeTouchEvent(e)) lastTouch = Date.now();\n  view.inputState.setSelectionOrigin(\"pointerselection\");\n};\nhandlers.touchmove = view => {\n  view.inputState.setSelectionOrigin(\"pointerselection\");\n};\nhandlers.mousedown = (view, event) => {\n  view.observer.flush();\n  if (lastTouch > Date.now() - 2000) return;\n  let style = null;\n  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {\n    style = makeStyle(view, event);\n    if (style) break;\n  }\n  if (!style && event.button == 0) style = basicMouseSelection(view, event);\n  if (style) {\n    if (view.root.activeElement != view.contentDOM) view.observer.ignore(() => focusPreventScroll(view.contentDOM));\n    view.inputState.startMouseSelection(view, event, style);\n  }\n};\nfunction rangeForClick(view, pos, bias, type) {\n  if (type == 1) {\n    return state_1.EditorSelection.cursor(pos, bias);\n  } else if (type == 2) {\n    return groupAt(view.state, pos, bias);\n  } else {\n    let line = LineView.find(view.docView, pos);\n    if (line) return state_1.EditorSelection.range(line.posAtStart, line.posAtEnd);\n    let {from, to} = view.state.doc.lineAt(pos);\n    return state_1.EditorSelection.range(from, to);\n  }\n}\nlet insideY = (y, rect) => y >= rect.top && y <= rect.bottom;\nlet inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;\nfunction findPositionSide(view, pos, x, y) {\n  let line = LineView.find(view.docView, pos);\n  if (!line) return 1;\n  let off = pos - line.posAtStart;\n  if (off == 0) return 1;\n  if (off == line.length) return -1;\n  let before = line.coordsAt(off, -1);\n  if (before && inside(x, y, before)) return -1;\n  let after = line.coordsAt(off, 1);\n  if (after && inside(x, y, after)) return 1;\n  return before && insideY(y, before) ? -1 : 1;\n}\nfunction queryPos(view, event) {\n  let pos = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  });\n  if (pos == null) return null;\n  return {\n    pos,\n    bias: findPositionSide(view, pos, event.clientX, event.clientY)\n  };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0;\nfunction getClickType(event) {\n  if (!BadMouseDetail) return event.detail;\n  let last = lastMouseDown;\n  lastMouseDown = event;\n  return lastMouseDownCount = !last || last.timeStamp > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n  let start = queryPos(view, event), type = getClickType(event);\n  let startSel = view.state.selection;\n  let last = start, lastEvent = event;\n  return {\n    update(update) {\n      if (update.changes) {\n        if (start) start.pos = update.changes.mapPos(start.pos);\n        startSel = startSel.map(update.changes);\n      }\n    },\n    get(event, extend, multiple) {\n      let cur;\n      if (event.clientX == lastEvent.clientX && event.clientY == lastEvent.clientY) cur = last; else {\n        cur = last = queryPos(view, event);\n        lastEvent = event;\n      }\n      if (!cur || !start) return startSel;\n      let range = rangeForClick(view, cur.pos, cur.bias, type);\n      if (start.pos != cur.pos && !extend) {\n        let startRange = rangeForClick(view, start.pos, start.bias, type);\n        let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n        range = from < range.from ? state_1.EditorSelection.range(from, to) : state_1.EditorSelection.range(to, from);\n      }\n      if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to)); else if (multiple) return startSel.addRange(range); else return state_1.EditorSelection.create([range]);\n    }\n  };\n}\nhandlers.dragstart = (view, event) => {\n  let {selection: {main}} = view.state;\n  let {mouseSelection} = view.inputState;\n  if (mouseSelection) mouseSelection.dragging = main;\n  if (event.dataTransfer) {\n    event.dataTransfer.setData(\"Text\", view.state.sliceDoc(main.from, main.to));\n    event.dataTransfer.effectAllowed = \"copyMove\";\n  }\n};\nhandlers.drop = (view, event) => {\n  if (!event.dataTransfer) return;\n  let dropPos = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  });\n  let text = event.dataTransfer.getData(\"Text\");\n  if (dropPos == null || !text) return;\n  event.preventDefault();\n  let {mouseSelection} = view.inputState;\n  let del = mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? {\n    from: mouseSelection.dragging.from,\n    to: mouseSelection.dragging.to\n  } : null;\n  let ins = {\n    from: dropPos,\n    insert: text\n  };\n  let changes = view.state.changes(del ? [del, ins] : ins);\n  view.focus();\n  view.dispatch({\n    changes,\n    selection: {\n      anchor: changes.mapPos(dropPos, -1),\n      head: changes.mapPos(dropPos, 1)\n    },\n    annotations: state_1.Transaction.userEvent.of(\"drop\")\n  });\n};\nhandlers.paste = (view, event) => {\n  view.observer.flush();\n  let data = brokenClipboardAPI ? null : event.clipboardData;\n  let text = data && data.getData(\"text/plain\");\n  if (text) {\n    doPaste(view, text);\n    event.preventDefault();\n  } else {\n    capturePaste(view);\n  }\n};\nfunction captureCopy(view, text) {\n  let parent = view.dom.parentNode;\n  if (!parent) return;\n  let target = parent.appendChild(document.createElement(\"textarea\"));\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.value = text;\n  target.focus();\n  target.selectionEnd = text.length;\n  target.selectionStart = 0;\n  setTimeout(() => {\n    target.remove();\n    view.focus();\n  }, 50);\n}\nfunction copiedRange(state) {\n  let content = [], ranges = [], linewise = false;\n  for (let range of state.selection.ranges) if (!range.empty) {\n    content.push(state.sliceDoc(range.from, range.to));\n    ranges.push(range);\n  }\n  if (!content.length) {\n    let upto = -1;\n    for (let {from} of state.selection.ranges) {\n      let line = state.doc.lineAt(from);\n      if (line.number > upto) {\n        content.push(line.text);\n        ranges.push({\n          from: line.from,\n          to: Math.min(state.doc.length, line.to + 1)\n        });\n      }\n      upto = line.number;\n    }\n    linewise = true;\n  }\n  return {\n    text: content.join(state.lineBreak),\n    ranges,\n    linewise\n  };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event) => {\n  let {text, ranges, linewise} = copiedRange(view.state);\n  if (!text) return;\n  lastLinewiseCopy = linewise ? text : null;\n  let data = brokenClipboardAPI ? null : event.clipboardData;\n  if (data) {\n    event.preventDefault();\n    data.clearData();\n    data.setData(\"text/plain\", text);\n  } else {\n    captureCopy(view, text);\n  }\n  if (event.type == \"cut\") view.dispatch({\n    changes: ranges,\n    scrollIntoView: true,\n    annotations: state_1.Transaction.userEvent.of(\"cut\")\n  });\n};\nhandlers.focus = handlers.blur = view => {\n  setTimeout(() => {\n    if (view.hasFocus != view.inputState.notifiedFocused) view.update([]);\n  }, 10);\n};\nhandlers.beforeprint = view => {\n  view.viewState.printing = true;\n  view.requestMeasure();\n  setTimeout(() => {\n    view.viewState.printing = false;\n    view.requestMeasure();\n  }, 2000);\n};\nfunction forceClearComposition(view) {\n  if (view.docView.compositionDeco.size) view.update([]);\n}\nhandlers.compositionstart = handlers.compositionupdate = view => {\n  if (view.inputState.composing < 0) {\n    if (view.docView.compositionDeco.size) {\n      view.observer.flush();\n      forceClearComposition(view);\n    }\n    view.inputState.composing = 0;\n  }\n};\nhandlers.compositionend = view => {\n  view.inputState.composing = -1;\n  view.inputState.compositionEndedAt = Date.now();\n  setTimeout(() => {\n    if (view.inputState.composing < 0) forceClearComposition(view);\n  }, 50);\n};\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\"];\nclass HeightOracle {\n  constructor() {\n    this.doc = text_1.Text.empty;\n    this.lineWrapping = false;\n    this.direction = Direction.LTR;\n    this.heightSamples = {};\n    this.lineHeight = 14;\n    this.charWidth = 7;\n    this.lineLength = 30;\n    this.heightChanged = false;\n  }\n  heightForGap(from, to) {\n    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n    if (this.lineWrapping) lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);\n    return this.lineHeight * lines;\n  }\n  heightForLine(length) {\n    if (!this.lineWrapping) return this.lineHeight;\n    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n    return lines * this.lineHeight;\n  }\n  setDoc(doc) {\n    this.doc = doc;\n    return this;\n  }\n  mustRefresh(lineHeights, whiteSpace, direction) {\n    let newHeight = false;\n    for (let i = 0; i < lineHeights.length; i++) {\n      let h = lineHeights[i];\n      if (h < 0) {\n        i++;\n      } else if (!this.heightSamples[Math.floor(h * 10)]) {\n        newHeight = true;\n        this.heightSamples[Math.floor(h * 10)] = true;\n      }\n    }\n    return newHeight || wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping || this.direction != direction;\n  }\n  refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {\n    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping || this.direction != direction;\n    this.lineWrapping = lineWrapping;\n    this.direction = direction;\n    this.lineHeight = lineHeight;\n    this.charWidth = charWidth;\n    this.lineLength = lineLength;\n    if (changed) {\n      this.heightSamples = {};\n      for (let i = 0; i < knownHeights.length; i++) {\n        let h = knownHeights[i];\n        if (h < 0) i++; else this.heightSamples[Math.floor(h * 10)] = true;\n      }\n    }\n    return changed;\n  }\n}\nclass MeasuredHeights {\n  constructor(from, heights) {\n    this.from = from;\n    this.heights = heights;\n    this.index = 0;\n  }\n  get more() {\n    return this.index < this.heights.length;\n  }\n}\nclass BlockInfo {\n  constructor(from, length, top, height, type) {\n    this.from = from;\n    this.length = length;\n    this.top = top;\n    this.height = height;\n    this.type = type;\n  }\n  get to() {\n    return this.from + this.length;\n  }\n  get bottom() {\n    return this.top + this.height;\n  }\n  join(other) {\n    let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);\n    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);\n  }\n}\nvar QueryType;\n(function (QueryType) {\n  QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n  QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n  QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n})(QueryType || (QueryType = {}));\nconst Epsilon = 1e-4;\nclass HeightMap {\n  constructor(length, height, flags = 2) {\n    this.length = length;\n    this.height = height;\n    this.flags = flags;\n  }\n  get outdated() {\n    return (this.flags & 2) > 0;\n  }\n  set outdated(value) {\n    this.flags = (value ? 2 : 0) | this.flags & ~2;\n  }\n  setHeight(oracle, height) {\n    if (this.height != height) {\n      if (Math.abs(this.height - height) > Epsilon) oracle.heightChanged = true;\n      this.height = height;\n    }\n  }\n  replace(_from, _to, nodes) {\n    return HeightMap.of(nodes);\n  }\n  decomposeLeft(_to, result) {\n    result.push(this);\n  }\n  decomposeRight(_from, result) {\n    result.push(this);\n  }\n  applyChanges(decorations, oldDoc, oracle, changes) {\n    let me = this;\n    for (let i = changes.length - 1; i >= 0; i--) {\n      let {fromA, toA, fromB, toB} = changes[i];\n      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n      toB += end.to - toA;\n      toA = end.to;\n      while (i > 0 && start.from <= changes[i - 1].toA) {\n        fromA = changes[i - 1].fromA;\n        fromB = changes[i - 1].fromB;\n        i--;\n        if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n      }\n      fromB += start.from - fromA;\n      fromA = start.from;\n      let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);\n      me = me.replace(fromA, toA, nodes);\n    }\n    return me.updateHeight(oracle, 0);\n  }\n  static empty() {\n    return new HeightMapText(0, 0);\n  }\n  static of(nodes) {\n    if (nodes.length == 1) return nodes[0];\n    let i = 0, j = nodes.length, before = 0, after = 0;\n    for (; ; ) {\n      if (i == j) {\n        if (before > after * 2) {\n          let split = nodes[i - 1];\n          if (split.break) nodes.splice(--i, 1, split.left, null, split.right); else nodes.splice(--i, 1, split.left, split.right);\n          j += 1 + split.break;\n          before -= split.size;\n        } else if (after > before * 2) {\n          let split = nodes[j];\n          if (split.break) nodes.splice(j, 1, split.left, null, split.right); else nodes.splice(j, 1, split.left, split.right);\n          j += 2 + split.break;\n          after -= split.size;\n        } else {\n          break;\n        }\n      } else if (before < after) {\n        let next = nodes[i++];\n        if (next) before += next.size;\n      } else {\n        let next = nodes[--j];\n        if (next) after += next.size;\n      }\n    }\n    let brk = 0;\n    if (nodes[i - 1] == null) {\n      brk = 1;\n      i--;\n    } else if (nodes[i] == null) {\n      brk = 1;\n      j++;\n    }\n    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n  }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n  constructor(length, height, type) {\n    super(length, height);\n    this.type = type;\n  }\n  blockAt(_height, _doc, top, offset) {\n    return new BlockInfo(offset, this.length, top, this.height, this.type);\n  }\n  lineAt(_value, _type, doc, top, offset) {\n    return this.blockAt(0, doc, top, offset);\n  }\n  forEachLine(_from, _to, doc, top, offset, f) {\n    f(this.blockAt(0, doc, top, offset));\n  }\n  updateHeight(oracle, offset = 0, _force = false, measured) {\n    if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);\n    this.outdated = false;\n    return this;\n  }\n  toString() {\n    return `block(${this.length})`;\n  }\n}\nclass HeightMapText extends HeightMapBlock {\n  constructor(length, height) {\n    super(length, height, BlockType.Text);\n    this.collapsed = 0;\n    this.widgetHeight = 0;\n  }\n  replace(_from, _to, nodes) {\n    let node = nodes[0];\n    if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {\n      if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height); else node.height = this.height;\n      if (!this.outdated) node.outdated = false;\n      return node;\n    } else {\n      return HeightMap.of(nodes);\n    }\n  }\n  updateHeight(oracle, offset = 0, force = false, measured) {\n    if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]); else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));\n    this.outdated = false;\n    return this;\n  }\n  toString() {\n    return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n  }\n}\nclass HeightMapGap extends HeightMap {\n  constructor(length) {\n    super(length, 0);\n  }\n  lines(doc, offset) {\n    let firstLine = doc.lineAt(offset).number, lastLine = doc.lineAt(offset + this.length).number;\n    return {\n      firstLine,\n      lastLine,\n      lineHeight: this.height / (lastLine - firstLine + 1)\n    };\n  }\n  blockAt(height, doc, top, offset) {\n    let {firstLine, lastLine, lineHeight} = this.lines(doc, offset);\n    let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));\n    let {from, length} = doc.line(firstLine + line);\n    return new BlockInfo(from, length, top + lineHeight * line, lineHeight, BlockType.Text);\n  }\n  lineAt(value, type, doc, top, offset) {\n    if (type == QueryType.ByHeight) return this.blockAt(value, doc, top, offset);\n    if (type == QueryType.ByPosNoHeight) {\n      let {from, to} = doc.lineAt(value);\n      return new BlockInfo(from, to - from, 0, 0, BlockType.Text);\n    }\n    let {firstLine, lineHeight} = this.lines(doc, offset);\n    let {from, length, number} = doc.lineAt(value);\n    return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);\n  }\n  forEachLine(from, to, doc, top, offset, f) {\n    let {firstLine, lineHeight} = this.lines(doc, offset);\n    for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end; ) {\n      let line = doc.lineAt(pos);\n      if (pos == from) top += lineHeight * (line.number - firstLine);\n      f(new BlockInfo(line.from, line.length, top, top += lineHeight, BlockType.Text));\n      pos = line.to + 1;\n    }\n  }\n  replace(from, to, nodes) {\n    let after = this.length - to;\n    if (after > 0) {\n      let last = nodes[nodes.length - 1];\n      if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after); else nodes.push(null, new HeightMapGap(after - 1));\n    }\n    if (from > 0) {\n      let first = nodes[0];\n      if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length); else nodes.unshift(new HeightMapGap(from - 1), null);\n    }\n    return HeightMap.of(nodes);\n  }\n  decomposeLeft(to, result) {\n    result.push(new HeightMapGap(to - 1), null);\n  }\n  decomposeRight(from, result) {\n    result.push(null, new HeightMapGap(this.length - from - 1));\n  }\n  updateHeight(oracle, offset = 0, force = false, measured) {\n    let end = offset + this.length;\n    if (measured && measured.from <= offset + this.length && measured.more) {\n      let nodes = [], pos = Math.max(offset, measured.from);\n      if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n      while (pos <= end && measured.more) {\n        let len = oracle.doc.lineAt(pos).length;\n        if (nodes.length) nodes.push(null);\n        let line = new HeightMapText(len, measured.heights[measured.index++]);\n        line.outdated = false;\n        nodes.push(line);\n        pos += len + 1;\n      }\n      if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n      oracle.heightChanged = true;\n      return HeightMap.of(nodes);\n    } else if (force || this.outdated) {\n      this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n      this.outdated = false;\n    }\n    return this;\n  }\n  toString() {\n    return `gap(${this.length})`;\n  }\n}\nclass HeightMapBranch extends HeightMap {\n  constructor(left, brk, right) {\n    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));\n    this.left = left;\n    this.right = right;\n    this.size = left.size + right.size;\n  }\n  get break() {\n    return this.flags & 1;\n  }\n  blockAt(height, doc, top, offset) {\n    let mid = top + this.left.height;\n    return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc, top, offset) : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);\n  }\n  lineAt(value, type, doc, top, offset) {\n    let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n    let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;\n    let base = left ? this.left.lineAt(value, type, doc, top, offset) : this.right.lineAt(value, type, doc, rightTop, rightOffset);\n    if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;\n    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n    if (left) return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset)); else return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);\n  }\n  forEachLine(from, to, doc, top, offset, f) {\n    let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n    if (this.break) {\n      if (from < rightOffset) this.left.forEachLine(from, to, doc, top, offset, f);\n      if (to >= rightOffset) this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);\n    } else {\n      let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);\n      if (from < mid.from) this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);\n      if (mid.to >= from && mid.from <= to) f(mid);\n      if (to > mid.to) this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);\n    }\n  }\n  replace(from, to, nodes) {\n    let rightStart = this.left.length + this.break;\n    if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);\n    if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n    let result = [];\n    if (from > 0) this.decomposeLeft(from, result);\n    let left = result.length;\n    for (let node of nodes) result.push(node);\n    if (from > 0) mergeGaps(result, left - 1);\n    if (to < this.length) {\n      let right = result.length;\n      this.decomposeRight(to, result);\n      mergeGaps(result, right);\n    }\n    return HeightMap.of(result);\n  }\n  decomposeLeft(to, result) {\n    let left = this.left.length;\n    if (to <= left) return this.left.decomposeLeft(to, result);\n    result.push(this.left);\n    if (this.break) {\n      left++;\n      if (to >= left) result.push(null);\n    }\n    if (to > left) this.right.decomposeLeft(to - left, result);\n  }\n  decomposeRight(from, result) {\n    let left = this.left.length, right = left + this.break;\n    if (from >= right) return this.right.decomposeRight(from - right, result);\n    if (from < left) this.left.decomposeRight(from, result);\n    if (this.break && from < right) result.push(null);\n    result.push(this.right);\n  }\n  balanced(left, right) {\n    if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [left, null, right] : [left, right]);\n    this.left = left;\n    this.right = right;\n    this.height = left.height + right.height;\n    this.outdated = left.outdated || right.outdated;\n    this.size = left.size + right.size;\n    this.length = left.length + this.break + right.length;\n    return this;\n  }\n  updateHeight(oracle, offset = 0, force = false, measured) {\n    let {left, right} = this, rightStart = offset + left.length + this.break, rebalance = null;\n    if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured); else left.updateHeight(oracle, offset, force);\n    if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured); else right.updateHeight(oracle, rightStart, force);\n    if (rebalance) return this.balanced(left, right);\n    this.height = this.left.height + this.right.height;\n    this.outdated = false;\n    return this;\n  }\n  toString() {\n    return this.left + (this.break ? \" \" : \"-\") + this.right;\n  }\n}\nfunction mergeGaps(nodes, around) {\n  let before, after;\n  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n  constructor(pos, oracle) {\n    this.pos = pos;\n    this.oracle = oracle;\n    this.nodes = [];\n    this.lineStart = -1;\n    this.lineEnd = -1;\n    this.covering = null;\n    this.writtenTo = pos;\n  }\n  get isCovered() {\n    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n  }\n  span(_from, to) {\n    if (this.lineStart > -1) {\n      let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n      if (last instanceof HeightMapText) last.length += end - this.pos; else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));\n      this.writtenTo = end;\n      if (to > end) {\n        this.nodes.push(null);\n        this.writtenTo++;\n        this.lineStart = -1;\n      }\n    }\n    this.pos = to;\n  }\n  point(from, to, deco) {\n    if (from < to || deco.heightRelevant) {\n      let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;\n      let len = to - from;\n      if (deco.block) {\n        this.addBlock(new HeightMapBlock(len, height, deco.type));\n      } else if (len || height >= relevantWidgetHeight) {\n        this.addLineDeco(height, len);\n      }\n    } else if (to > from) {\n      this.span(from, to);\n    }\n    if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n  }\n  enterLine() {\n    if (this.lineStart > -1) return;\n    let {from, to} = this.oracle.doc.lineAt(this.pos);\n    this.lineStart = from;\n    this.lineEnd = to;\n    if (this.writtenTo < from) {\n      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n      this.nodes.push(null);\n    }\n    if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));\n    this.writtenTo = this.pos;\n  }\n  blankContent(from, to) {\n    let gap = new HeightMapGap(to - from);\n    if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4;\n    return gap;\n  }\n  ensureLine() {\n    this.enterLine();\n    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n    if (last instanceof HeightMapText) return last;\n    let line = new HeightMapText(0, -1);\n    this.nodes.push(line);\n    return line;\n  }\n  addBlock(block) {\n    this.enterLine();\n    if (block.type == BlockType.WidgetAfter && !this.isCovered) this.ensureLine();\n    this.nodes.push(block);\n    this.writtenTo = this.pos = this.pos + block.length;\n    if (block.type != BlockType.WidgetBefore) this.covering = block;\n  }\n  addLineDeco(height, length) {\n    let line = this.ensureLine();\n    line.length += length;\n    line.collapsed += length;\n    line.widgetHeight = Math.max(line.widgetHeight, height);\n    this.writtenTo = this.pos = this.pos + length;\n  }\n  finish(from) {\n    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1)); else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n    let pos = from;\n    for (let node of this.nodes) {\n      if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);\n      pos += node ? node.length : 1;\n    }\n    return this.nodes;\n  }\n  static build(oracle, decorations, from, to) {\n    let builder = new NodeBuilder(from, oracle);\n    rangeset_1.RangeSet.spans(decorations, from, to, builder, 0);\n    return builder.finish(from);\n  }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n  let comp = new DecorationComparator();\n  rangeset_1.RangeSet.compare(a, b, diff, comp, 0);\n  return comp.changes;\n}\nclass DecorationComparator {\n  constructor() {\n    this.changes = [];\n  }\n  compareRange() {}\n  comparePoint(from, to, a, b) {\n    if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);\n  }\n}\nfunction visiblePixelRange(dom, paddingTop) {\n  let rect = dom.getBoundingClientRect();\n  let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);\n  let top = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);\n  for (let parent = dom.parentNode; parent; ) {\n    if (parent.nodeType == 1) {\n      if ((parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) && window.getComputedStyle(parent).overflow != \"visible\") {\n        let parentRect = parent.getBoundingClientRect();\n        left = Math.max(left, parentRect.left);\n        right = Math.min(right, parentRect.right);\n        top = Math.max(top, parentRect.top);\n        bottom = Math.min(bottom, parentRect.bottom);\n      }\n      parent = parent.parentNode;\n    } else if (parent.nodeType == 11) {\n      parent = parent.host;\n    } else {\n      break;\n    }\n  }\n  return {\n    left: left - rect.left,\n    right: right - rect.left,\n    top: top - (rect.top + paddingTop),\n    bottom: bottom - (rect.top + paddingTop)\n  };\n}\nclass LineGap {\n  constructor(from, to, size) {\n    this.from = from;\n    this.to = to;\n    this.size = size;\n  }\n  static same(a, b) {\n    if (a.length != b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      let gA = a[i], gB = b[i];\n      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;\n    }\n    return true;\n  }\n  draw(wrapping) {\n    return Decoration.replace({\n      widget: new LineGapWidget(this.size, wrapping)\n    }).range(this.from, this.to);\n  }\n}\nclass LineGapWidget extends WidgetType {\n  constructor(size, vertical) {\n    super();\n    this.size = size;\n    this.vertical = vertical;\n  }\n  eq(other) {\n    return other.size == this.size && other.vertical == this.vertical;\n  }\n  toDOM() {\n    let elt = document.createElement(\"div\");\n    if (this.vertical) {\n      elt.style.height = this.size + \"px\";\n    } else {\n      elt.style.width = this.size + \"px\";\n      elt.style.height = \"2px\";\n      elt.style.display = \"inline-block\";\n    }\n    return elt;\n  }\n  get estimatedHeight() {\n    return this.vertical ? this.size : -1;\n  }\n}\nclass ViewState {\n  constructor(state) {\n    this.state = state;\n    this.pixelViewport = {\n      left: 0,\n      right: window.innerWidth,\n      top: 0,\n      bottom: 0\n    };\n    this.inView = true;\n    this.paddingTop = 0;\n    this.paddingBottom = 0;\n    this.contentWidth = 0;\n    this.heightOracle = new HeightOracle();\n    this.scaler = IdScaler;\n    this.scrollTo = null;\n    this.printing = false;\n    this.visibleRanges = [];\n    this.mustEnforceCursorAssoc = false;\n    this.heightMap = HeightMap.empty().applyChanges(state.facet(decorations), text_1.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\n    this.viewport = this.getViewport(0, null);\n    this.updateForViewport();\n    this.lineGaps = this.ensureLineGaps([]);\n    this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));\n    this.computeVisibleRanges();\n  }\n  updateForViewport() {\n    let viewports = [this.viewport], {main} = this.state.selection;\n    for (let i = 0; i <= 1; i++) {\n      let pos = i ? main.head : main.anchor;\n      if (!viewports.some(({from, to}) => pos >= from && pos <= to)) {\n        let {from, to} = this.lineAt(pos, 0);\n        viewports.push(new Viewport(from, to));\n      }\n    }\n    this.viewports = viewports.sort((a, b) => a.from - b.from);\n    this.scaler = this.heightMap.height <= 7000000 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);\n  }\n  update(update, scrollTo = null) {\n    let prev = this.state;\n    this.state = update.state;\n    let newDeco = this.state.facet(decorations);\n    let contentChanges = update.changedRanges;\n    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.startState.facet(decorations), newDeco, update ? update.changes : state_1.ChangeSet.empty(this.state.doc.length)));\n    let prevHeight = this.heightMap.height;\n    this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n    if (this.heightMap.height != prevHeight) update.flags |= 2;\n    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n    if (scrollTo && (scrollTo.head < viewport.from || scrollTo.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTo);\n    if (!viewport.eq(this.viewport)) {\n      this.viewport = viewport;\n      update.flags |= 4;\n    }\n    this.updateForViewport();\n    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000) update.flags |= this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n    this.computeVisibleRanges();\n    if (scrollTo) this.scrollTo = scrollTo;\n    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc) this.mustEnforceCursorAssoc = true;\n  }\n  measure(docView, repeated) {\n    let dom = docView.dom, whiteSpace = \"\", direction = Direction.LTR;\n    if (!repeated) {\n      let style = window.getComputedStyle(dom);\n      (whiteSpace = style.whiteSpace, direction = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR);\n      this.paddingTop = parseInt(style.paddingTop) || 0;\n      this.paddingBottom = parseInt(style.paddingBottom) || 0;\n    }\n    let pixelViewport = this.printing ? {\n      top: -1e8,\n      bottom: 1e8,\n      left: -1e8,\n      right: 1e8\n    } : visiblePixelRange(dom, this.paddingTop);\n    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n    this.pixelViewport = pixelViewport;\n    this.inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n    if (!this.inView) return 0;\n    let lineHeights = docView.measureVisibleLineHeights();\n    let refresh = false, bias = 0, result = 0, oracle = this.heightOracle;\n    if (!repeated) {\n      let contentWidth = docView.dom.clientWidth;\n      if (oracle.mustRefresh(lineHeights, whiteSpace, direction) || oracle.lineWrapping && Math.abs(contentWidth - this.contentWidth) > oracle.charWidth) {\n        let {lineHeight, charWidth} = docView.measureTextSize();\n        refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);\n        if (refresh) {\n          docView.minWidth = 0;\n          result |= 16;\n        }\n      }\n      if (this.contentWidth != contentWidth) {\n        this.contentWidth = contentWidth;\n        result |= 16;\n      }\n      if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom); else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);\n    }\n    oracle.heightChanged = false;\n    this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));\n    if (oracle.heightChanged) result |= 2;\n    if (!this.viewportIsAppropriate(this.viewport, bias) || this.scrollTo && (this.scrollTo.head < this.viewport.from || this.scrollTo.head > this.viewport.to)) {\n      let newVP = this.getViewport(bias, this.scrollTo);\n      if (newVP.from != this.viewport.from || newVP.to != this.viewport.to) {\n        this.viewport = newVP;\n        result |= 4;\n      }\n    }\n    this.updateForViewport();\n    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000) result |= this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));\n    this.computeVisibleRanges();\n    if (this.mustEnforceCursorAssoc) {\n      this.mustEnforceCursorAssoc = false;\n      docView.enforceCursorAssoc();\n    }\n    return result;\n  }\n  get visibleTop() {\n    return this.scaler.fromDOM(this.pixelViewport.top, 0);\n  }\n  get visibleBottom() {\n    return this.scaler.fromDOM(this.pixelViewport.bottom, 0);\n  }\n  getViewport(bias, scrollTo) {\n    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 / 2));\n    let map = this.heightMap, doc = this.state.doc, {visibleTop, visibleBottom} = this;\n    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000, QueryType.ByHeight, doc, 0, 0).to);\n    if (scrollTo) {\n      if (scrollTo.head < viewport.from) {\n        let {top: newTop} = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);\n        viewport = new Viewport(map.lineAt(newTop - 1000 / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newTop + (visibleBottom - visibleTop) + 1000 / 2, QueryType.ByHeight, doc, 0, 0).to);\n      } else if (scrollTo.head > viewport.to) {\n        let {bottom: newBottom} = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);\n        viewport = new Viewport(map.lineAt(newBottom - (visibleBottom - visibleTop) - 1000 / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newBottom + 1000 / 2, QueryType.ByHeight, doc, 0, 0).to);\n      }\n    }\n    return viewport;\n  }\n  mapViewport(viewport, changes) {\n    let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);\n  }\n  viewportIsAppropriate({from, to}, bias = 0) {\n    let {top} = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);\n    let {bottom} = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);\n    let {visibleTop, visibleBottom} = this;\n    return (from == 0 || top <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top > visibleTop - 2 * 1000 && bottom < visibleBottom + 2 * 1000);\n  }\n  mapLineGaps(gaps, changes) {\n    if (!gaps.length || changes.empty) return gaps;\n    let mapped = [];\n    for (let gap of gaps) if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n    return mapped;\n  }\n  ensureLineGaps(current) {\n    let gaps = [];\n    if (this.heightOracle.direction != Direction.LTR) return gaps;\n    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, line => {\n      if (line.length < 10000) return;\n      let structure = lineStructure(line.from, line.to, this.state);\n      if (structure.total < 10000) return;\n      let viewFrom, viewTo;\n      if (this.heightOracle.lineWrapping) {\n        if (line.from != this.viewport.from) viewFrom = line.from; else viewFrom = findPosition(structure, (this.visibleTop - line.top) / line.height);\n        if (line.to != this.viewport.to) viewTo = line.to; else viewTo = findPosition(structure, (this.visibleBottom - line.top) / line.height);\n      } else {\n        let totalWidth = structure.total * this.heightOracle.charWidth;\n        viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);\n        viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);\n      }\n      let sel = this.state.selection.main;\n      if (sel.from <= viewFrom && sel.to >= line.from) viewFrom = sel.from;\n      if (sel.from <= line.to && sel.to >= viewTo) viewTo = sel.to;\n      let gapTo = viewFrom - 10000, gapFrom = viewTo + 10000;\n      if (gapTo > line.from + 5000) gaps.push(find(current, gap => gap.from == line.from && gap.to > gapTo - 5000 && gap.to < gapTo + 5000) || new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));\n      if (gapFrom < line.to - 5000) gaps.push(find(current, gap => gap.to == line.to && gap.from > gapFrom - 5000 && gap.from < gapFrom + 5000) || new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));\n    });\n    return gaps;\n  }\n  gapSize(line, pos, start, structure) {\n    if (this.heightOracle.lineWrapping) {\n      let height = line.height * findFraction(structure, pos);\n      return start ? height : line.height - height;\n    } else {\n      let ratio = findFraction(structure, pos);\n      return structure.total * this.heightOracle.charWidth * (start ? ratio : 1 - ratio);\n    }\n  }\n  updateLineGaps(gaps) {\n    if (!LineGap.same(gaps, this.lineGaps)) {\n      this.lineGaps = gaps;\n      this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));\n      return 8;\n    }\n    return 0;\n  }\n  computeVisibleRanges() {\n    let deco = this.state.facet(decorations);\n    if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);\n    let ranges = [];\n    rangeset_1.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n      span(from, to) {\n        ranges.push({\n          from,\n          to\n        });\n      },\n      point() {}\n    }, 20);\n    this.visibleRanges = ranges;\n  }\n  lineAt(pos, editorTop) {\n    editorTop += this.paddingTop;\n    return scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop, 0), this.scaler, editorTop);\n  }\n  lineAtHeight(height, editorTop) {\n    editorTop += this.paddingTop;\n    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height, editorTop), QueryType.ByHeight, this.state.doc, editorTop, 0), this.scaler, editorTop);\n  }\n  blockAtHeight(height, editorTop) {\n    editorTop += this.paddingTop;\n    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height, editorTop), this.state.doc, editorTop, 0), this.scaler, editorTop);\n  }\n  forEachLine(from, to, f, editorTop) {\n    editorTop += this.paddingTop;\n    return this.heightMap.forEachLine(from, to, this.state.doc, editorTop, 0, this.scaler.scale == 1 ? f : b => f(scaleBlock(b, this.scaler, editorTop)));\n  }\n  get contentHeight() {\n    return this.domHeight + this.paddingTop + this.paddingBottom;\n  }\n  get domHeight() {\n    return this.scaler.toDOM(this.heightMap.height, this.paddingTop);\n  }\n}\nclass Viewport {\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n  }\n  eq(b) {\n    return this.from == b.from && this.to == b.to;\n  }\n}\nfunction lineStructure(from, to, state) {\n  let ranges = [], pos = from, total = 0;\n  rangeset_1.RangeSet.spans(state.facet(decorations), from, to, {\n    span() {},\n    point(from, to) {\n      if (from > pos) {\n        ranges.push({\n          from: pos,\n          to: from\n        });\n        total += from - pos;\n      }\n      pos = to;\n    }\n  }, 20);\n  if (pos < to) {\n    ranges.push({\n      from: pos,\n      to\n    });\n    total += to - pos;\n  }\n  return {\n    total,\n    ranges\n  };\n}\nfunction findPosition({total, ranges}, ratio) {\n  if (ratio <= 0) return ranges[0].from;\n  if (ratio >= 1) return ranges[ranges.length - 1].to;\n  let dist = Math.floor(total * ratio);\n  for (let i = 0; ; i++) {\n    let {from, to} = ranges[i], size = to - from;\n    if (dist <= size) return from + dist;\n    dist -= size;\n  }\n}\nfunction findFraction(structure, pos) {\n  let counted = 0;\n  for (let {from, to} of structure.ranges) {\n    if (pos <= to) {\n      counted += pos - from;\n      break;\n    }\n    counted += to - from;\n  }\n  return counted / structure.total;\n}\nfunction find(array, f) {\n  for (let val of array) if (f(val)) return val;\n  return undefined;\n}\nconst IdScaler = {\n  toDOM(n) {\n    return n;\n  },\n  fromDOM(n) {\n    return n;\n  },\n  scale: 1\n};\nclass BigScaler {\n  constructor(doc, heightMap, viewports) {\n    let vpHeight = 0, base = 0, domBase = 0;\n    this.viewports = viewports.map(({from, to}) => {\n      let top = heightMap.lineAt(from, QueryType.ByPos, doc, 0, 0).top;\n      let bottom = heightMap.lineAt(to, QueryType.ByPos, doc, 0, 0).bottom;\n      vpHeight += bottom - top;\n      return {\n        from,\n        to,\n        top,\n        bottom,\n        domTop: 0,\n        domBottom: 0\n      };\n    });\n    this.scale = (7000000 - vpHeight) / (heightMap.height - vpHeight);\n    for (let obj of this.viewports) {\n      obj.domTop = domBase + (obj.top - base) * this.scale;\n      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n      base = obj.bottom;\n    }\n  }\n  toDOM(n, top) {\n    n -= top;\n    for (let i = 0, base = 0, domBase = 0; ; i++) {\n      let vp = i < this.viewports.length ? this.viewports[i] : null;\n      if (!vp || n < vp.top) return domBase + (n - base) * this.scale + top;\n      if (n <= vp.bottom) return vp.domTop + (n - vp.top) + top;\n      base = vp.bottom;\n      domBase = vp.domBottom;\n    }\n  }\n  fromDOM(n, top) {\n    n -= top;\n    for (let i = 0, base = 0, domBase = 0; ; i++) {\n      let vp = i < this.viewports.length ? this.viewports[i] : null;\n      if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale + top;\n      if (n <= vp.domBottom) return vp.top + (n - vp.domTop) + top;\n      base = vp.bottom;\n      domBase = vp.domBottom;\n    }\n  }\n}\nfunction scaleBlock(block, scaler, top) {\n  if (scaler.scale == 1) return block;\n  let bTop = scaler.toDOM(block.top, top), bBottom = scaler.toDOM(block.bottom, top);\n  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map(b => scaleBlock(b, scaler, top)) : block.type);\n}\nconst theme = state_1.Facet.define({\n  combine: strs => strs.join(\" \")\n});\nconst darkTheme = state_1.Facet.define({\n  combine: values => values.indexOf(true) > -1\n});\nconst baseThemeID = style_mod_1.StyleModule.newName(), baseLightID = style_mod_1.StyleModule.newName(), baseDarkID = style_mod_1.StyleModule.newName();\nconst lightDarkIDs = {\n  \"&light\": \".\" + baseLightID,\n  \"&dark\": \".\" + baseDarkID\n};\nfunction buildTheme(main, spec, scopes) {\n  return new style_mod_1.StyleModule(spec, {\n    finish(sel) {\n      return (/&/).test(sel) ? sel.replace(/&\\w*/, m => {\n        if (m == \"&\") return main;\n        if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);\n        return scopes[m];\n      }) : main + \" \" + sel;\n    }\n  });\n}\nconst baseTheme = buildTheme(\".\" + baseThemeID, {\n  \"&\": {\n    position: \"relative !important\",\n    boxSizing: \"border-box\",\n    \"&.cm-focused\": {\n      outline_fallback: \"1px dotted #212121\",\n      outline: \"5px auto -webkit-focus-ring-color\"\n    },\n    display: \"flex !important\",\n    flexDirection: \"column\"\n  },\n  \".cm-scroller\": {\n    display: \"flex !important\",\n    alignItems: \"flex-start !important\",\n    fontFamily: \"monospace\",\n    lineHeight: 1.4,\n    height: \"100%\",\n    overflowX: \"auto\",\n    position: \"relative\",\n    zIndex: 0\n  },\n  \".cm-content\": {\n    margin: 0,\n    flexGrow: 2,\n    minHeight: \"100%\",\n    display: \"block\",\n    whiteSpace: \"pre\",\n    boxSizing: \"border-box\",\n    padding: \"4px 0\",\n    outline: \"none\"\n  },\n  \".cm-lineWrapping\": {\n    whiteSpace: \"pre-wrap\",\n    overflowWrap: \"anywhere\"\n  },\n  \"&light .cm-content\": {\n    caretColor: \"black\"\n  },\n  \"&dark .cm-content\": {\n    caretColor: \"white\"\n  },\n  \".cm-line\": {\n    display: \"block\",\n    padding: \"0 2px 0 4px\"\n  },\n  \".cm-selectionLayer\": {\n    zIndex: -1,\n    contain: \"size style\"\n  },\n  \".cm-selectionBackground\": {\n    position: \"absolute\"\n  },\n  \"&light .cm-selectionBackground\": {\n    background: \"#d9d9d9\"\n  },\n  \"&dark .cm-selectionBackground\": {\n    background: \"#222\"\n  },\n  \"&light.cm-focused .cm-selectionBackground\": {\n    background: \"#d7d4f0\"\n  },\n  \"&dark.cm-focused .cm-selectionBackground\": {\n    background: \"#233\"\n  },\n  \".cm-cursorLayer\": {\n    zIndex: 100,\n    contain: \"size style\",\n    pointerEvents: \"none\"\n  },\n  \"&.cm-focused .cm-cursorLayer\": {\n    animation: \"steps(1) cm-blink 1.2s infinite\"\n  },\n  \"@keyframes cm-blink\": {\n    \"0%\": {},\n    \"50%\": {\n      visibility: \"hidden\"\n    },\n    \"100%\": {}\n  },\n  \"@keyframes cm-blink2\": {\n    \"0%\": {},\n    \"50%\": {\n      visibility: \"hidden\"\n    },\n    \"100%\": {}\n  },\n  \".cm-cursor\": {\n    position: \"absolute\",\n    borderLeft: \"1.2px solid black\",\n    marginLeft: \"-0.6px\",\n    pointerEvents: \"none\",\n    display: \"none\"\n  },\n  \"&dark .cm-cursor\": {\n    borderLeftColor: \"#444\"\n  },\n  \"&.cm-focused .cm-cursor\": {\n    display: \"block\"\n  },\n  \"&light .cm-activeLine\": {\n    backgroundColor: \"#f3f9ff\"\n  },\n  \"&dark .cm-activeLine\": {\n    backgroundColor: \"#223039\"\n  },\n  \"&light .cm-specialChar\": {\n    color: \"red\"\n  },\n  \"&dark .cm-specialChar\": {\n    color: \"#f78\"\n  },\n  \".cm-tab\": {\n    display: \"inline-block\",\n    overflow: \"hidden\",\n    verticalAlign: \"bottom\"\n  },\n  \".cm-placeholder\": {\n    color: \"#888\",\n    display: \"inline-block\"\n  },\n  \".cm-button\": {\n    verticalAlign: \"middle\",\n    color: \"inherit\",\n    fontSize: \"70%\",\n    padding: \".2em 1em\",\n    borderRadius: \"3px\"\n  },\n  \"&light .cm-button\": {\n    backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n    border: \"1px solid #888\",\n    \"&:active\": {\n      backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n    }\n  },\n  \"&dark .cm-button\": {\n    backgroundImage: \"linear-gradient(#393939, #111)\",\n    border: \"1px solid #888\",\n    \"&:active\": {\n      backgroundImage: \"linear-gradient(#111, #333)\"\n    }\n  },\n  \".cm-textfield\": {\n    verticalAlign: \"middle\",\n    color: \"inherit\",\n    fontSize: \"70%\",\n    border: \"1px solid silver\",\n    padding: \".2em .5em\"\n  },\n  \"&light .cm-textfield\": {\n    backgroundColor: \"white\"\n  },\n  \"&dark .cm-textfield\": {\n    border: \"1px solid #555\",\n    backgroundColor: \"inherit\"\n  }\n}, lightDarkIDs);\nconst observeOptions = {\n  childList: true,\n  characterData: true,\n  subtree: true,\n  characterDataOldValue: true\n};\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n  constructor(view, onChange, onScrollChanged) {\n    this.view = view;\n    this.onChange = onChange;\n    this.onScrollChanged = onScrollChanged;\n    this.active = false;\n    this.ignoreSelection = new DOMSelection();\n    this.delayedFlush = -1;\n    this.queue = [];\n    this.scrollTargets = [];\n    this.intersection = null;\n    this.intersecting = false;\n    this.parentCheck = -1;\n    this.dom = view.contentDOM;\n    this.observer = new MutationObserver(mutations => {\n      for (let mut of mutations) this.queue.push(mut);\n      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some(m => m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon(); else this.flush();\n    });\n    if (useCharData) this.onCharData = event => {\n      this.queue.push({\n        target: event.target,\n        type: \"characterData\",\n        oldValue: event.prevValue\n      });\n      this.flushSoon();\n    };\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.start();\n    this.onScroll = this.onScroll.bind(this);\n    window.addEventListener(\"scroll\", this.onScroll);\n    if (typeof IntersectionObserver == \"function\") {\n      this.intersection = new IntersectionObserver(entries => {\n        if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n        if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n          this.intersecting = !this.intersecting;\n          this.onScrollChanged(document.createEvent(\"Event\"));\n        }\n      }, {});\n      this.intersection.observe(this.dom);\n    }\n    this.listenForScroll();\n  }\n  onScroll(e) {\n    if (this.intersecting) {\n      this.flush();\n      this.onScrollChanged(e);\n    }\n  }\n  onSelectionChange(event) {\n    let {view} = this, sel = getSelection(view.root);\n    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;\n    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n    if (context && context.ignoreEvent(event)) return;\n    if (browser.ie && browser.ie_version <= 11 && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon(); else this.flush();\n  }\n  listenForScroll() {\n    this.parentCheck = -1;\n    let i = 0, changed = null;\n    for (let dom = this.dom; dom; ) {\n      if (dom.nodeType == 1) {\n        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++; else if (!changed) changed = this.scrollTargets.slice(0, i);\n        if (changed) changed.push(dom);\n        dom = dom.parentNode;\n      } else if (dom.nodeType == 11) {\n        dom = dom.host;\n      } else {\n        break;\n      }\n    }\n    if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);\n    if (changed) {\n      for (let dom of this.scrollTargets) dom.removeEventListener(\"scroll\", this.onScroll);\n      for (let dom of this.scrollTargets = changed) dom.addEventListener(\"scroll\", this.onScroll);\n    }\n  }\n  ignore(f) {\n    if (!this.active) return f();\n    try {\n      this.stop();\n      return f();\n    } finally {\n      this.start();\n      this.clear();\n    }\n  }\n  start() {\n    if (this.active) return;\n    this.observer.observe(this.dom, observeOptions);\n    this.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    if (useCharData) this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    this.active = true;\n  }\n  stop() {\n    if (!this.active) return;\n    this.active = false;\n    this.observer.disconnect();\n    this.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    if (useCharData) this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n  }\n  clearSelection() {\n    this.ignoreSelection.set(getSelection(this.view.root));\n  }\n  clear() {\n    this.observer.takeRecords();\n    this.queue.length = 0;\n    this.clearSelection();\n  }\n  flushSoon() {\n    if (this.delayedFlush < 0) this.delayedFlush = window.setTimeout(() => {\n      this.delayedFlush = -1;\n      this.flush();\n    }, 20);\n  }\n  forceFlush() {\n    if (this.delayedFlush >= 0) {\n      window.clearTimeout(this.delayedFlush);\n      this.delayedFlush = -1;\n      this.flush();\n    }\n  }\n  flush() {\n    if (this.delayedFlush >= 0) return;\n    let records = this.queue;\n    for (let mut of this.observer.takeRecords()) records.push(mut);\n    if (records.length) this.queue = [];\n    let selection = getSelection(this.view.root);\n    let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);\n    if (records.length == 0 && !newSel) return;\n    let from = -1, to = -1, typeOver = false;\n    for (let record of records) {\n      let range = this.readMutation(record);\n      if (!range) continue;\n      if (range.typeOver) typeOver = true;\n      if (from == -1) {\n        ({from, to} = range);\n      } else {\n        from = Math.min(range.from, from);\n        to = Math.max(range.to, to);\n      }\n    }\n    let startState = this.view.state;\n    if (from > -1 || newSel) this.onChange(from, to, typeOver);\n    if (this.view.state == startState) {\n      if (this.view.docView.dirty) {\n        this.ignore(() => this.view.docView.sync());\n        this.view.docView.dirty = 0;\n      }\n      this.view.docView.updateSelection();\n    }\n    this.clearSelection();\n  }\n  readMutation(rec) {\n    let cView = this.view.docView.nearest(rec.target);\n    if (!cView || cView.ignoreMutation(rec)) return null;\n    cView.markDirty();\n    if (rec.type == \"childList\") {\n      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n      return {\n        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,\n        typeOver: false\n      };\n    } else {\n      return {\n        from: cView.posAtStart,\n        to: cView.posAtEnd,\n        typeOver: rec.target.nodeValue == rec.oldValue\n      };\n    }\n  }\n  destroy() {\n    this.stop();\n    if (this.intersection) this.intersection.disconnect();\n    for (let dom of this.scrollTargets) dom.removeEventListener(\"scroll\", this.onScroll);\n    window.removeEventListener(\"scroll\", this.onScroll);\n    clearTimeout(this.parentCheck);\n  }\n}\nfunction findChild(cView, dom, dir) {\n  while (dom) {\n    let curView = ContentView.get(dom);\n    if (curView && curView.parent == cView) return curView;\n    let parent = dom.parentNode;\n    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n  }\n  return null;\n}\nfunction applyDOMChange(view, start, end, typeOver) {\n  let change, newSel;\n  let sel = view.state.selection.main, bounds;\n  if (start > -1 && (bounds = view.docView.domBoundsAround(start, end, 0))) {\n    let {from, to} = bounds;\n    let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view.contentDOM, view.root);\n    let reader = new DOMReader(selPoints, view);\n    reader.readRange(bounds.startDOM, bounds.endDOM);\n    newSel = selectionFromPoints(selPoints, from);\n    let preferredPos = sel.from, preferredSide = null;\n    if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && reader.text.length < to - from) {\n      preferredPos = sel.to;\n      preferredSide = \"end\";\n    }\n    let diff = findDiff(view.state.sliceDoc(from, to), reader.text, preferredPos - from, preferredSide);\n    if (diff) change = {\n      from: from + diff.from,\n      to: from + diff.toA,\n      insert: view.state.toText(reader.text.slice(diff.from, diff.toB))\n    };\n  } else if (view.hasFocus || !view.state.facet(editable)) {\n    let domSel = getSelection(view.root);\n    let {impreciseHead: iHead, impreciseAnchor: iAnchor} = view.docView;\n    let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n    let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ? view.state.selection.main.anchor : selectionCollapsed(domSel) ? head : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n    if (head != sel.head || anchor != sel.anchor) newSel = state_1.EditorSelection.single(anchor, head);\n  }\n  if (!change && !newSel) return;\n  if (!change && typeOver && !sel.empty && newSel && newSel.main.empty) change = {\n    from: sel.from,\n    to: sel.to,\n    insert: view.state.doc.slice(sel.from, sel.to)\n  };\n  if (change) {\n    let startState = view.state;\n    if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view, \"Enter\", 10) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view, \"Backspace\", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view, \"Delete\", 46))) return;\n    let text = change.insert.toString();\n    if (view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text))) return;\n    if (view.inputState.composing >= 0) view.inputState.composing++;\n    let tr;\n    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length)) {\n      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n    } else {\n      let changes = startState.changes(change);\n      tr = {\n        changes,\n        selection: newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? startState.selection.replaceRange(newSel.main) : undefined\n      };\n    }\n    view.dispatch(tr, {\n      scrollIntoView: true,\n      annotations: state_1.Transaction.userEvent.of(\"input\")\n    });\n  } else if (newSel && !newSel.main.eq(sel)) {\n    let scrollIntoView = false, annotations;\n    if (view.inputState.lastSelectionTime > Date.now() - 50) {\n      if (view.inputState.lastSelectionOrigin == \"keyboardselection\") scrollIntoView = true; else annotations = state_1.Transaction.userEvent.of(view.inputState.lastSelectionOrigin);\n    }\n    view.dispatch({\n      selection: newSel,\n      scrollIntoView,\n      annotations\n    });\n  }\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n  let minLen = Math.min(a.length, b.length);\n  let from = 0;\n  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) from++;\n  if (from == minLen && a.length == b.length) return null;\n  let toA = a.length, toB = b.length;\n  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n    toA--;\n    toB--;\n  }\n  if (preferredSide == \"end\") {\n    let adjust = Math.max(0, from - Math.min(toA, toB));\n    preferredPos -= toA + adjust - from;\n  }\n  if (toA < from && a.length < b.length) {\n    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n    from -= move;\n    toB = from + (toB - toA);\n    toA = from;\n  } else if (toB < from) {\n    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n    from -= move;\n    toA = from + (toA - toB);\n    toB = from;\n  }\n  return {\n    from,\n    toA,\n    toB\n  };\n}\nclass DOMReader {\n  constructor(points, view) {\n    this.points = points;\n    this.view = view;\n    this.text = \"\";\n    this.lineBreak = view.state.lineBreak;\n  }\n  readRange(start, end) {\n    if (!start) return;\n    let parent = start.parentNode;\n    for (let cur = start; ; ) {\n      this.findPointBefore(parent, cur);\n      this.readNode(cur);\n      let next = cur.nextSibling;\n      if (next == end) break;\n      let view = ContentView.get(cur), nextView = ContentView.get(next);\n      if ((view ? view.breakAfter : isBlockElement(cur)) || (nextView ? nextView.breakAfter : isBlockElement(next)) && !(cur.nodeName == \"BR\" && !cur.cmIgnore)) this.text += this.lineBreak;\n      cur = next;\n    }\n    this.findPointBefore(parent, end);\n  }\n  readNode(node) {\n    if (node.cmIgnore) return;\n    let view = ContentView.get(node);\n    let fromView = view && view.overrideDOMText;\n    let text;\n    if (fromView != null) text = fromView.sliceString(0, undefined, this.lineBreak); else if (node.nodeType == 3) text = node.nodeValue; else if (node.nodeName == \"BR\") text = node.nextSibling ? this.lineBreak : \"\"; else if (node.nodeType == 1) this.readRange(node.firstChild, null);\n    if (text != null) {\n      this.findPointIn(node, text.length);\n      this.text += text;\n      if (browser.chrome && this.view.inputState.lastKeyCode == 13 && !node.nextSibling && (/\\n\\n$/).test(this.text)) this.text = this.text.slice(0, -1);\n    }\n  }\n  findPointBefore(node, next) {\n    for (let point of this.points) if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;\n  }\n  findPointIn(node, maxLen) {\n    for (let point of this.points) if (point.node == node) point.pos = this.text.length + Math.min(point.offset, maxLen);\n  }\n}\nfunction isBlockElement(node) {\n  return node.nodeType == 1 && (/^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/).test(node.nodeName);\n}\nclass DOMPoint {\n  constructor(node, offset) {\n    this.node = node;\n    this.offset = offset;\n    this.pos = -1;\n  }\n}\nfunction selectionPoints(dom, root) {\n  let result = [];\n  if (root.activeElement != dom) return result;\n  let {anchorNode, anchorOffset, focusNode, focusOffset} = getSelection(root);\n  if (anchorNode) {\n    result.push(new DOMPoint(anchorNode, anchorOffset));\n    if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));\n  }\n  return result;\n}\nfunction selectionFromPoints(points, base) {\n  if (points.length == 0) return null;\n  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n  return anchor > -1 && head > -1 ? state_1.EditorSelection.single(anchor + base, head + base) : null;\n}\nfunction dispatchKey(view, name, code) {\n  let options = {\n    key: name,\n    code: name,\n    keyCode: code,\n    which: code,\n    cancelable: true\n  };\n  let down = new KeyboardEvent(\"keydown\", options);\n  view.contentDOM.dispatchEvent(down);\n  let up = new KeyboardEvent(\"keyup\", options);\n  view.contentDOM.dispatchEvent(up);\n  return down.defaultPrevented || up.defaultPrevented;\n}\nclass EditorView {\n  constructor(config = {}) {\n    this.plugins = [];\n    this.editorAttrs = {};\n    this.contentAttrs = {};\n    this.bidiCache = [];\n    this.updateState = 2;\n    this.measureScheduled = -1;\n    this.measureRequests = [];\n    this.contentDOM = document.createElement(\"div\");\n    this.scrollDOM = document.createElement(\"div\");\n    this.scrollDOM.tabIndex = -1;\n    this.scrollDOM.className = \"cm-scroller\";\n    this.scrollDOM.appendChild(this.contentDOM);\n    this.announceDOM = document.createElement(\"div\");\n    this.announceDOM.style.cssText = \"position: absolute; top: -10000px\";\n    this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n    this.dom = document.createElement(\"div\");\n    this.dom.appendChild(this.announceDOM);\n    this.dom.appendChild(this.scrollDOM);\n    this._dispatch = config.dispatch || (tr => this.update([tr]));\n    this.dispatch = this.dispatch.bind(this);\n    this.root = config.root || document;\n    this.viewState = new ViewState(config.state || state_1.EditorState.create());\n    this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec).update(this));\n    this.observer = new DOMObserver(this, (from, to, typeOver) => {\n      applyDOMChange(this, from, to, typeOver);\n    }, event => {\n      this.inputState.runScrollHandlers(this, event);\n      this.measure();\n    });\n    this.inputState = new InputState(this);\n    this.docView = new DocView(this);\n    this.mountStyles();\n    this.updateAttrs();\n    this.updateState = 0;\n    ensureGlobalHandler();\n    this.requestMeasure();\n    if (config.parent) config.parent.appendChild(this.dom);\n  }\n  get state() {\n    return this.viewState.state;\n  }\n  get viewport() {\n    return this.viewState.viewport;\n  }\n  get visibleRanges() {\n    return this.viewState.visibleRanges;\n  }\n  get inView() {\n    return this.viewState.inView;\n  }\n  get composing() {\n    return this.inputState.composing > 0;\n  }\n  dispatch(...input) {\n    this._dispatch(input.length == 1 && input[0] instanceof state_1.Transaction ? input[0] : this.state.update(...input));\n  }\n  update(transactions) {\n    if (this.updateState != 0) throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n    let redrawn = false, update;\n    let state = this.state;\n    for (let tr of transactions) {\n      if (tr.startState != state) throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n      state = tr.state;\n    }\n    if (state.facet(state_1.EditorState.phrases) != this.state.facet(state_1.EditorState.phrases)) return this.setState(state);\n    update = new ViewUpdate(this, state, transactions);\n    try {\n      this.updateState = 2;\n      let scrollTo = transactions.some(tr => tr.scrollIntoView) ? state.selection.main : null;\n      this.viewState.update(update, scrollTo);\n      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n      if (!update.empty) this.updatePlugins(update);\n      redrawn = this.docView.update(update);\n      if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();\n      this.updateAttrs();\n      this.showAnnouncements(transactions);\n    } finally {\n      this.updateState = 0;\n    }\n    if (redrawn || scrollTo || this.viewState.mustEnforceCursorAssoc) this.requestMeasure();\n    if (!update.empty) for (let listener of this.state.facet(updateListener)) listener(update);\n  }\n  setState(newState) {\n    if (this.updateState != 0) throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n    this.updateState = 2;\n    try {\n      for (let plugin of this.plugins) plugin.destroy(this);\n      this.viewState = new ViewState(newState);\n      this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec).update(this));\n      this.docView = new DocView(this);\n      this.inputState.ensureHandlers(this);\n      this.mountStyles();\n      this.updateAttrs();\n      this.bidiCache = [];\n    } finally {\n      this.updateState = 0;\n    }\n    this.requestMeasure();\n  }\n  updatePlugins(update) {\n    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n    if (prevSpecs != specs) {\n      let newPlugins = [];\n      for (let spec of specs) {\n        let found = prevSpecs.indexOf(spec);\n        if (found < 0) {\n          newPlugins.push(new PluginInstance(spec));\n        } else {\n          let plugin = this.plugins[found];\n          plugin.mustUpdate = update;\n          newPlugins.push(plugin);\n        }\n      }\n      for (let plugin of this.plugins) if (plugin.mustUpdate != update) plugin.destroy(this);\n      this.plugins = newPlugins;\n      this.inputState.ensureHandlers(this);\n    } else {\n      for (let p of this.plugins) p.mustUpdate = update;\n    }\n    for (let i = 0; i < this.plugins.length; i++) this.plugins[i] = this.plugins[i].update(this);\n  }\n  measure() {\n    if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);\n    this.measureScheduled = -1;\n    let updated = null;\n    try {\n      for (let i = 0; ; i++) {\n        this.updateState = 1;\n        let changed = this.viewState.measure(this.docView, i > 0);\n        let measuring = this.measureRequests;\n        if (!changed && !measuring.length && this.viewState.scrollTo == null) break;\n        this.measureRequests = [];\n        if (i > 5) {\n          console.warn(\"Viewport failed to stabilize\");\n          break;\n        }\n        let measured = measuring.map(m => {\n          try {\n            return m.read(this);\n          } catch (e) {\n            logException(this.state, e);\n            return BadMeasure;\n          }\n        });\n        let update = new ViewUpdate(this, this.state);\n        update.flags |= changed;\n        if (!updated) updated = update; else updated.flags |= changed;\n        this.updateState = 2;\n        if (!update.empty) this.updatePlugins(update);\n        this.updateAttrs();\n        if (changed) this.docView.update(update);\n        for (let i = 0; i < measuring.length; i++) if (measured[i] != BadMeasure) {\n          try {\n            measuring[i].write(measured[i], this);\n          } catch (e) {\n            logException(this.state, e);\n          }\n        }\n        if (this.viewState.scrollTo) {\n          this.docView.scrollPosIntoView(this.viewState.scrollTo.head, this.viewState.scrollTo.assoc);\n          this.viewState.scrollTo = null;\n        }\n        if (!(changed & 4) && this.measureRequests.length == 0) break;\n      }\n    } finally {\n      this.updateState = 0;\n    }\n    this.measureScheduled = -1;\n    if (updated && !updated.empty) for (let listener of this.state.facet(updateListener)) listener(updated);\n  }\n  get themeClasses() {\n    return baseThemeID + \" \" + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" + this.state.facet(theme);\n  }\n  updateAttrs() {\n    let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {\n      class: \"cm-wrap\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n    });\n    updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n    this.editorAttrs = editorAttrs;\n    let contentAttrs = combineAttrs(this.state.facet(contentAttributes), {\n      spellcheck: \"false\",\n      contenteditable: String(this.state.facet(editable)),\n      class: \"cm-content\",\n      style: `${browser.tabSize}: ${this.state.tabSize}`,\n      role: \"textbox\",\n      \"aria-multiline\": \"true\"\n    });\n    updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n    this.contentAttrs = contentAttrs;\n  }\n  showAnnouncements(trs) {\n    let first = true;\n    for (let tr of trs) for (let effect of tr.effects) if (effect.is(EditorView.announce)) {\n      if (first) this.announceDOM.textContent = \"\";\n      first = false;\n      let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n      div.textContent = effect.value;\n    }\n  }\n  mountStyles() {\n    this.styleModules = this.state.facet(styleModule);\n    style_mod_1.StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());\n  }\n  readMeasured() {\n    if (this.updateState == 2) throw new Error(\"Reading the editor layout isn't allowed during an update\");\n    if (this.updateState == 0 && this.measureScheduled > -1) this.measure();\n  }\n  requestMeasure(request) {\n    if (this.measureScheduled < 0) this.measureScheduled = requestAnimationFrame(() => this.measure());\n    if (request) {\n      if (request.key != null) for (let i = 0; i < this.measureRequests.length; i++) {\n        if (this.measureRequests[i].key === request.key) {\n          this.measureRequests[i] = request;\n          return;\n        }\n      }\n      this.measureRequests.push(request);\n    }\n  }\n  pluginField(field) {\n    let result = [];\n    for (let plugin of this.plugins) plugin.update(this).takeField(field, result);\n    return result;\n  }\n  plugin(plugin) {\n    for (let inst of this.plugins) if (inst.spec == plugin) return inst.update(this).value;\n    return null;\n  }\n  blockAtHeight(height, editorTop) {\n    this.readMeasured();\n    return this.viewState.blockAtHeight(height, ensureTop(editorTop, this.contentDOM));\n  }\n  visualLineAtHeight(height, editorTop) {\n    this.readMeasured();\n    return this.viewState.lineAtHeight(height, ensureTop(editorTop, this.contentDOM));\n  }\n  viewportLines(f, editorTop) {\n    let {from, to} = this.viewport;\n    this.viewState.forEachLine(from, to, f, ensureTop(editorTop, this.contentDOM));\n  }\n  visualLineAt(pos, editorTop = 0) {\n    return this.viewState.lineAt(pos, editorTop);\n  }\n  get contentHeight() {\n    return this.viewState.contentHeight;\n  }\n  moveByChar(start, forward, by) {\n    return moveByChar(this, start, forward, by);\n  }\n  moveByGroup(start, forward) {\n    return moveByChar(this, start, forward, initial => byGroup(this, start.head, initial));\n  }\n  moveToLineBoundary(start, forward, includeWrap = true) {\n    return moveToLineBoundary(this, start, forward, includeWrap);\n  }\n  moveVertically(start, forward, distance) {\n    return moveVertically(this, start, forward, distance);\n  }\n  scrollPosIntoView(pos) {\n    this.viewState.scrollTo = state_1.EditorSelection.cursor(pos);\n    this.requestMeasure();\n  }\n  domAtPos(pos) {\n    return this.docView.domAtPos(pos);\n  }\n  posAtDOM(node, offset = 0) {\n    return this.docView.posFromDOM(node, offset);\n  }\n  posAtCoords(coords) {\n    this.readMeasured();\n    return posAtCoords(this, coords);\n  }\n  coordsAtPos(pos, side = 1) {\n    this.readMeasured();\n    let rect = this.docView.coordsAt(pos, side);\n    if (!rect || rect.left == rect.right) return rect;\n    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n    return flattenRect(rect, span.dir == Direction.LTR == side > 0);\n  }\n  get defaultCharacterWidth() {\n    return this.viewState.heightOracle.charWidth;\n  }\n  get defaultLineHeight() {\n    return this.viewState.heightOracle.lineHeight;\n  }\n  get textDirection() {\n    return this.viewState.heightOracle.direction;\n  }\n  get lineWrapping() {\n    return this.viewState.heightOracle.lineWrapping;\n  }\n  bidiSpans(line) {\n    if (line.length > MaxBidiLine) return trivialOrder(line.length);\n    let dir = this.textDirection;\n    for (let entry of this.bidiCache) if (entry.from == line.from && entry.dir == dir) return entry.order;\n    let order = computeOrder(line.text, this.textDirection);\n    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));\n    return order;\n  }\n  get hasFocus() {\n    return document.hasFocus() && this.root.activeElement == this.contentDOM;\n  }\n  focus() {\n    this.observer.ignore(() => {\n      focusPreventScroll(this.contentDOM);\n      this.docView.updateSelection();\n    });\n  }\n  destroy() {\n    for (let plugin of this.plugins) plugin.destroy(this);\n    this.inputState.destroy();\n    this.dom.remove();\n    this.observer.destroy();\n    if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);\n  }\n  static domEventHandlers(handlers) {\n    return ViewPlugin.define(() => ({}), {\n      eventHandlers: handlers\n    });\n  }\n  static theme(spec, options) {\n    let prefix = style_mod_1.StyleModule.newName();\n    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];\n    if (options && options.dark) result.push(darkTheme.of(true));\n    return result;\n  }\n  static baseTheme(spec) {\n    return state_1.Prec.fallback(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n  }\n}\nEditorView.styleModule = styleModule;\nEditorView.inputHandler = inputHandler;\nEditorView.exceptionSink = exceptionSink;\nEditorView.updateListener = updateListener;\nEditorView.editable = editable;\nEditorView.mouseSelectionStyle = mouseSelectionStyle;\nEditorView.dragMovesSelection = dragMovesSelection$1;\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\nEditorView.decorations = decorations;\nEditorView.contentAttributes = contentAttributes;\nEditorView.editorAttributes = editorAttributes;\nEditorView.lineWrapping = EditorView.contentAttributes.of({\n  \"class\": \"cm-lineWrapping\"\n});\nEditorView.announce = state_1.StateEffect.define();\nconst MaxBidiLine = 4096;\nfunction ensureTop(given, dom) {\n  return given == null ? dom.getBoundingClientRect().top : given;\n}\nlet resizeDebounce = -1;\nfunction ensureGlobalHandler() {\n  window.addEventListener(\"resize\", () => {\n    if (resizeDebounce == -1) resizeDebounce = setTimeout(handleResize, 50);\n  });\n}\nfunction handleResize() {\n  resizeDebounce = -1;\n  let found = document.querySelectorAll(\".cm-content\");\n  for (let i = 0; i < found.length; i++) {\n    let docView = ContentView.get(found[i]);\n    if (docView) docView.editorView.requestMeasure();\n  }\n}\nconst BadMeasure = {};\nclass CachedOrder {\n  constructor(from, to, dir, order) {\n    this.from = from;\n    this.to = to;\n    this.dir = dir;\n    this.order = order;\n  }\n  static update(cache, changes) {\n    if (changes.empty) return cache;\n    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {\n      let entry = cache[i];\n      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));\n    }\n    return result;\n  }\n}\nconst currentPlatform = typeof navigator == \"undefined\" ? \"key\" : (/Mac/).test(navigator.platform) ? \"mac\" : (/Win/).test(navigator.platform) ? \"win\" : (/Linux|X11/).test(navigator.platform) ? \"linux\" : \"key\";\nfunction normalizeKeyName(name, platform) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result == \"Space\") result = \" \";\n  let alt, ctrl, shift, meta;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const mod = parts[i];\n    if ((/^(cmd|meta|m)$/i).test(mod)) meta = true; else if ((/^a(lt)?$/i).test(mod)) alt = true; else if ((/^(c|ctrl|control)$/i).test(mod)) ctrl = true; else if ((/^s(hift)?$/i).test(mod)) shift = true; else if ((/^mod$/i).test(mod)) {\n      if (platform == \"mac\") meta = true; else ctrl = true;\n    } else throw new Error(\"Unrecognized modifier name: \" + mod);\n  }\n  if (alt) result = \"Alt-\" + result;\n  if (ctrl) result = \"Ctrl-\" + result;\n  if (meta) result = \"Meta-\" + result;\n  if (shift) result = \"Shift-\" + result;\n  return result;\n}\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name;\n  if (event.ctrlKey) name = \"Ctrl-\" + name;\n  if (event.metaKey) name = \"Meta-\" + name;\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n  return name;\n}\nconst handleKeyEvents = EditorView.domEventHandlers({\n  keydown(event, view) {\n    return runHandlers(getKeymap(view.state), event, view, \"editor\");\n  }\n});\nconst keymap = state_1.Facet.define({\n  enables: handleKeyEvents\n});\nconst Keymaps = new WeakMap();\nfunction getKeymap(state) {\n  let bindings = state.facet(keymap);\n  let map = Keymaps.get(bindings);\n  if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));\n  return map;\n}\nfunction runScopeHandlers(view, event, scope) {\n  return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n  let bound = Object.create(null);\n  let isPrefix = Object.create(null);\n  let checkPrefix = (name, is) => {\n    let current = isPrefix[name];\n    if (current == null) isPrefix[name] = is; else if (current != is) throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n  };\n  let add = (scope, key, command, preventDefault) => {\n    let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n    let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));\n    for (let i = 1; i < parts.length; i++) {\n      let prefix = parts.slice(0, i).join(\" \");\n      checkPrefix(prefix, true);\n      if (!scopeObj[prefix]) scopeObj[prefix] = {\n        preventDefault: true,\n        commands: [view => {\n          let ourObj = storedPrefix = {\n            view,\n            prefix,\n            scope\n          };\n          setTimeout(() => {\n            if (storedPrefix == ourObj) storedPrefix = null;\n          }, PrefixTimeout);\n          return true;\n        }]\n      };\n    }\n    let full = parts.join(\" \");\n    checkPrefix(full, false);\n    let binding = scopeObj[full] || (scopeObj[full] = {\n      preventDefault: false,\n      commands: []\n    });\n    binding.commands.push(command);\n    if (preventDefault) binding.preventDefault = true;\n  };\n  for (let b of bindings) {\n    let name = b[platform] || b.key;\n    if (!name) continue;\n    for (let scope of b.scope ? b.scope.split(\" \") : [\"editor\"]) {\n      add(scope, name, b.run, b.preventDefault);\n      if (b.shift) add(scope, \"Shift-\" + name, b.shift, b.preventDefault);\n    }\n  }\n  return bound;\n}\nfunction runHandlers(map, event, view, scope) {\n  let name = w3c_keyname_1.keyName(event), isChar = name.length == 1 && name != \" \";\n  let prefix = \"\", fallthrough = false;\n  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n    prefix = storedPrefix.prefix + \" \";\n    if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0) storedPrefix = null;\n  }\n  let runFor = binding => {\n    if (binding) {\n      for (let cmd of binding.commands) if (cmd(view)) return true;\n      if (binding.preventDefault) fallthrough = true;\n    }\n    return false;\n  };\n  let scopeObj = map[scope], baseName;\n  if (scopeObj) {\n    if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) return true;\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = w3c_keyname_1.base[event.keyCode]) && baseName != name) {\n      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) return true;\n    } else if (isChar && event.shiftKey) {\n      if (runFor(scopeObj[prefix + modifiers(name, event, true)])) return true;\n    }\n  }\n  return fallthrough;\n}\nconst CanHidePrimary = !browser.ios;\nconst selectionConfig = state_1.Facet.define({\n  combine(configs) {\n    return state_1.combineConfig(configs, {\n      cursorBlinkRate: 1200,\n      drawRangeCursor: true\n    }, {\n      cursorBlinkRate: (a, b) => Math.min(a, b),\n      drawRangeCursor: (a, b) => a || b\n    });\n  }\n});\nfunction drawSelection(config = {}) {\n  return [selectionConfig.of(config), drawSelectionPlugin, hideNativeSelection];\n}\nclass Piece {\n  constructor(left, top, width, height, className) {\n    this.left = left;\n    this.top = top;\n    this.width = width;\n    this.height = height;\n    this.className = className;\n  }\n  draw() {\n    let elt = document.createElement(\"div\");\n    elt.className = this.className;\n    this.adjust(elt);\n    return elt;\n  }\n  adjust(elt) {\n    elt.style.left = this.left + \"px\";\n    elt.style.top = this.top + \"px\";\n    if (this.width >= 0) elt.style.width = this.width + \"px\";\n    elt.style.height = this.height + \"px\";\n  }\n  eq(p) {\n    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;\n  }\n}\nconst drawSelectionPlugin = ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.rangePieces = [];\n    this.cursors = [];\n    this.measureReq = {\n      read: this.readPos.bind(this),\n      write: this.drawSel.bind(this)\n    };\n    this.selectionLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n    this.selectionLayer.className = \"cm-selectionLayer\";\n    this.selectionLayer.setAttribute(\"aria-hidden\", \"true\");\n    this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n    this.cursorLayer.className = \"cm-cursorLayer\";\n    this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n    view.requestMeasure(this.measureReq);\n    this.setBlinkRate();\n  }\n  setBlinkRate() {\n    this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n  }\n  update(update) {\n    let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n    if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged) this.view.requestMeasure(this.measureReq);\n    if (update.transactions.some(tr => tr.scrollIntoView)) this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n    if (confChanged) this.setBlinkRate();\n  }\n  readPos() {\n    let {state} = this.view, conf = state.facet(selectionConfig);\n    let rangePieces = state.selection.ranges.map(r => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));\n    let cursors = [];\n    for (let r of state.selection.ranges) {\n      let prim = r == state.selection.main;\n      if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n        let piece = measureCursor(this.view, r, prim);\n        if (piece) cursors.push(piece);\n      }\n    }\n    return {\n      rangePieces,\n      cursors\n    };\n  }\n  drawSel({rangePieces, cursors}) {\n    if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {\n      this.selectionLayer.textContent = \"\";\n      for (let p of rangePieces) this.selectionLayer.appendChild(p.draw());\n      this.rangePieces = rangePieces;\n    }\n    if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {\n      let oldCursors = this.cursorLayer.children;\n      if (oldCursors.length !== cursors.length) {\n        this.cursorLayer.textContent = \"\";\n        for (const c of cursors) this.cursorLayer.appendChild(c.draw());\n      } else {\n        cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));\n      }\n      this.cursors = cursors;\n    }\n  }\n  destroy() {\n    this.selectionLayer.remove();\n    this.cursorLayer.remove();\n  }\n});\nconst themeSpec = {\n  \".cm-line\": {\n    \"& ::selection\": {\n      backgroundColor: \"transparent !important\"\n    },\n    \"&::selection\": {\n      backgroundColor: \"transparent !important\"\n    }\n  }\n};\nif (CanHidePrimary) themeSpec[\".cm-line\"].caretColor = \"transparent !important\";\nconst hideNativeSelection = state_1.Prec.override(EditorView.theme(themeSpec));\nfunction getBase(view) {\n  let rect = view.scrollDOM.getBoundingClientRect();\n  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\n  return {\n    left: left - view.scrollDOM.scrollLeft,\n    top: rect.top - view.scrollDOM.scrollTop\n  };\n}\nfunction wrappedLine(view, pos, inside) {\n  let range = state_1.EditorSelection.cursor(pos);\n  return {\n    from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n    to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from)\n  };\n}\nfunction measureRange(view, range) {\n  if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];\n  let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n  let ltr = view.textDirection == Direction.LTR;\n  let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n  let lineStyle = window.getComputedStyle(content.firstChild);\n  let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft);\n  let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);\n  let visualStart = view.visualLineAt(from);\n  let visualEnd = view.visualLineAt(to);\n  if (view.lineWrapping) {\n    visualStart = wrappedLine(view, from, visualStart);\n    visualEnd = wrappedLine(view, to, visualEnd);\n  }\n  if (visualStart.from == visualEnd.from) {\n    return pieces(drawForLine(range.from, range.to, visualStart));\n  } else {\n    let top = drawForLine(range.from, null, visualStart);\n    let bottom = drawForLine(null, range.to, visualEnd);\n    let between = [];\n    if (visualStart.to < visualEnd.from - 1) between.push(piece(leftSide, top.bottom, rightSide, bottom.top)); else if (top.bottom < bottom.top && bottom.top - top.bottom < 4) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n    return pieces(top).concat(between).concat(pieces(bottom));\n  }\n  function piece(left, top, right, bottom) {\n    return new Piece(left - base.left, top - base.top, right - left, bottom - top, \"cm-selectionBackground\");\n  }\n  function pieces({top, bottom, horizontal}) {\n    let pieces = [];\n    for (let i = 0; i < horizontal.length; i += 2) pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n    return pieces;\n  }\n  function drawForLine(from, to, line) {\n    let top = 1e9, bottom = -1e9, horizontal = [];\n    function addSpan(from, fromOpen, to, toOpen, dir) {\n      let fromCoords = view.coordsAtPos(from, from == line.to ? -1 : 1);\n      let toCoords = view.coordsAtPos(to, to == line.from ? 1 : -1);\n      top = Math.min(fromCoords.top, toCoords.top, top);\n      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n      if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right); else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n    }\n    let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;\n    for (let r of view.visibleRanges) if (r.to > start && r.from < end) {\n      for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {\n        let docLine = view.state.doc.lineAt(pos);\n        for (let span of view.bidiSpans(docLine)) {\n          let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n          if (spanFrom >= endPos) break;\n          if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n        }\n        pos = docLine.to + 1;\n        if (pos >= endPos) break;\n      }\n    }\n    if (horizontal.length == 0) {\n      let coords = view.coordsAtPos(start, -1);\n      top = Math.min(coords.top, top);\n      bottom = Math.max(coords.bottom, bottom);\n    }\n    return {\n      top,\n      bottom,\n      horizontal\n    };\n  }\n}\nfunction measureCursor(view, cursor, primary) {\n  let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);\n  if (!pos) return null;\n  let base = getBase(view);\n  return new Piece(pos.left - base.left, pos.top - base.top, -1, pos.bottom - pos.top, primary ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\");\n}\nfunction iterMatches(doc, re, from, to, f) {\n  re.lastIndex = 0;\n  for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {\n    if (!cursor.lineBreak) while (m = re.exec(cursor.value)) f(pos + m.index, pos + m.index + m[0].length, m);\n  }\n}\nclass MatchDecorator {\n  constructor(config) {\n    let {regexp, decoration, boundary} = config;\n    if (!regexp.global) throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n    this.regexp = regexp;\n    this.getDeco = typeof decoration == \"function\" ? decoration : () => decoration;\n    this.boundary = boundary;\n  }\n  createDeco(view) {\n    let build = new rangeset_1.RangeSetBuilder();\n    for (let {from, to} of view.visibleRanges) iterMatches(view.state.doc, this.regexp, from, to, (a, b, m) => build.add(a, b, this.getDeco(m, view, a)));\n    return build.finish();\n  }\n  updateDeco(update, deco) {\n    let changeFrom = 1e9, changeTo = -1;\n    if (update.docChanged) update.changes.iterChanges((_f, _t, from, to) => {\n      if (to > update.view.viewport.from && from < update.view.viewport.to) {\n        changeFrom = Math.min(from, changeFrom);\n        changeTo = Math.max(to, changeTo);\n      }\n    });\n    if (update.viewportChanged || changeTo - changeFrom > 1000) return this.createDeco(update.view);\n    if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n    return deco;\n  }\n  updateRange(view, deco, updateFrom, updateTo) {\n    for (let r of view.visibleRanges) {\n      let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);\n      if (to > from) {\n        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n        let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);\n        if (this.boundary) {\n          for (; from > fromLine.from; from--) if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n            start = from;\n            break;\n          }\n          for (; to < toLine.to; to++) if (this.boundary.test(toLine.text[to - toLine.from])) {\n            end = to;\n            break;\n          }\n        }\n        let ranges = [], m;\n        if (fromLine == toLine) {\n          this.regexp.lastIndex = start - fromLine.from;\n          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) {\n            let pos = m.index + fromLine.from;\n            ranges.push(this.getDeco(m, view, pos).range(pos, pos + m[0].length));\n          }\n        } else {\n          iterMatches(view.state.doc, this.regexp, start, end, (from, to, m) => ranges.push(this.getDeco(m, view, from).range(from, to)));\n        }\n        deco = deco.update({\n          filterFrom: start,\n          filterTo: end,\n          filter: () => false,\n          add: ranges\n        });\n      }\n    }\n    return deco;\n  }\n}\nconst UnicodeRegexpSupport = (/x/).unicode != null ? \"gu\" : \"g\";\nconst Specials = new RegExp(\"[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]\", UnicodeRegexpSupport);\nconst Names = {\n  0: \"null\",\n  7: \"bell\",\n  8: \"backspace\",\n  10: \"newline\",\n  11: \"vertical tab\",\n  13: \"carriage return\",\n  27: \"escape\",\n  8203: \"zero width space\",\n  8204: \"zero width non-joiner\",\n  8205: \"zero width joiner\",\n  8206: \"left-to-right mark\",\n  8207: \"right-to-left mark\",\n  8232: \"line separator\",\n  8233: \"paragraph separator\",\n  65279: \"zero width no-break space\",\n  65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n  if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n    let styles = document.body.style;\n    _supportsTabSize = (styles.tabSize || styles.MozTabSize) != null;\n  }\n  return _supportsTabSize || false;\n}\nconst specialCharConfig = state_1.Facet.define({\n  combine(configs) {\n    let config = state_1.combineConfig(configs, {\n      render: null,\n      specialChars: Specials,\n      addSpecialChars: null\n    });\n    if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp(\"\\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n    if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n    return config;\n  }\n});\nfunction highlightSpecialChars(config = {}) {\n  return [specialCharConfig.of(config), specialCharPlugin()];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n  return _plugin || (_plugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.view = view;\n      this.decorations = Decoration.none;\n      this.decorationCache = Object.create(null);\n      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n      this.decorations = this.decorator.createDeco(view);\n    }\n    makeDecorator(conf) {\n      return new MatchDecorator({\n        regexp: conf.specialChars,\n        decoration: (m, view, pos) => {\n          let {doc} = view.state;\n          let code = text_1.codePointAt(m[0], 0);\n          if (code == 9) {\n            let line = doc.lineAt(pos);\n            let size = view.state.tabSize, col = text_1.countColumn(doc.sliceString(line.from, pos), 0, size);\n            return Decoration.replace({\n              widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth)\n            });\n          }\n          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({\n            widget: new SpecialCharWidget(conf, code)\n          }));\n        },\n        boundary: conf.replaceTabs ? undefined : /[^]/\n      });\n    }\n    update(update) {\n      let conf = update.state.facet(specialCharConfig);\n      if (update.startState.facet(specialCharConfig) != conf) {\n        this.decorator = this.makeDecorator(conf);\n        this.decorations = this.decorator.createDeco(update.view);\n      } else {\n        this.decorations = this.decorator.updateDeco(update, this.decorations);\n      }\n    }\n  }, {\n    decorations: v => v.decorations\n  }));\n}\nconst DefaultPlaceholder = \"\\u2022\";\nfunction placeholder$1(code) {\n  if (code >= 32) return DefaultPlaceholder;\n  if (code == 10) return \"\\u2424\";\n  return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n  constructor(options, code) {\n    super();\n    this.options = options;\n    this.code = code;\n  }\n  eq(other) {\n    return other.code == this.code;\n  }\n  toDOM(view) {\n    let ph = placeholder$1(this.code);\n    let desc = view.state.phrase(\"Control character \") + (Names[this.code] || \"0x\" + this.code.toString(16));\n    let custom = this.options.render && this.options.render(this.code, desc, ph);\n    if (custom) return custom;\n    let span = document.createElement(\"span\");\n    span.textContent = ph;\n    span.title = desc;\n    span.setAttribute(\"aria-label\", desc);\n    span.className = \"cm-specialChar\";\n    return span;\n  }\n  ignoreEvent() {\n    return false;\n  }\n}\nclass TabWidget extends WidgetType {\n  constructor(width) {\n    super();\n    this.width = width;\n  }\n  eq(other) {\n    return other.width == this.width;\n  }\n  toDOM() {\n    let span = document.createElement(\"span\");\n    span.textContent = \"\\t\";\n    span.className = \"cm-tab\";\n    span.style.width = this.width + \"px\";\n    return span;\n  }\n  ignoreEvent() {\n    return false;\n  }\n}\nfunction highlightActiveLine() {\n  return activeLineHighlighter;\n}\nconst lineDeco = Decoration.line({\n  attributes: {\n    class: \"cm-activeLine\"\n  }\n});\nconst activeLineHighlighter = ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.decorations = this.getDeco(view);\n  }\n  update(update) {\n    if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);\n  }\n  getDeco(view) {\n    let lastLineStart = -1, deco = [];\n    for (let r of view.state.selection.ranges) {\n      if (!r.empty) continue;\n      let line = view.visualLineAt(r.head);\n      if (line.from > lastLineStart) {\n        deco.push(lineDeco.range(line.from));\n        lastLineStart = line.from;\n      }\n    }\n    return Decoration.set(deco);\n  }\n}, {\n  decorations: v => v.decorations\n});\nclass Placeholder extends WidgetType {\n  constructor(content) {\n    super();\n    this.content = content;\n  }\n  toDOM() {\n    let wrap = document.createElement(\"span\");\n    wrap.className = \"cm-placeholder\";\n    wrap.style.pointerEvents = \"none\";\n    wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n    if (typeof this.content == \"string\") wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content); else wrap.setAttribute(\"aria-hidden\", \"true\");\n    return wrap;\n  }\n  ignoreEvent() {\n    return false;\n  }\n}\nfunction placeholder(content) {\n  return ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.view = view;\n      this.placeholder = Decoration.set([Decoration.widget({\n        widget: new Placeholder(content),\n        side: 1\n      }).range(0)]);\n    }\n    get decorations() {\n      return this.view.state.doc.length ? Decoration.none : this.placeholder;\n    }\n  }, {\n    decorations: v => v.decorations\n  });\n}\nconst __test = {\n  HeightMap,\n  HeightOracle,\n  MeasuredHeights,\n  QueryType,\n  ChangedRange,\n  computeOrder,\n  moveVisually\n};\nexports.BidiSpan = BidiSpan;\nexports.BlockInfo = BlockInfo;\nexports.BlockType = BlockType;\nexports.Decoration = Decoration;\nexports.Direction = Direction;\nexports.EditorView = EditorView;\nexports.MatchDecorator = MatchDecorator;\nexports.PluginField = PluginField;\nexports.PluginFieldProvider = PluginFieldProvider;\nexports.ViewPlugin = ViewPlugin;\nexports.ViewUpdate = ViewUpdate;\nexports.WidgetType = WidgetType;\nexports.__test = __test;\nexports.drawSelection = drawSelection;\nexports.highlightActiveLine = highlightActiveLine;\nexports.highlightSpecialChars = highlightSpecialChars;\nexports.keymap = keymap;\nexports.logException = logException;\nexports.placeholder = placeholder;\nexports.runScopeHandlers = runScopeHandlers;\n"}