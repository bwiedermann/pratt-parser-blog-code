{"contents":"exports.__esModule = true;\nvar lezer_json_1 = __fusereq(48);\nvar language_1 = __fusereq(17);\nvar highlight_1 = __fusereq(26);\nconst jsonParseLinter = () => view => {\n  try {\n    JSON.parse(view.state.doc.toString());\n  } catch (e) {\n    if (!(e instanceof SyntaxError)) throw e;\n    const pos = getErrorPosition(e, view.state.doc);\n    return [{\n      from: pos,\n      message: e.message,\n      severity: 'error',\n      to: pos\n    }];\n  }\n  return [];\n};\nfunction getErrorPosition(error, doc) {\n  let m;\n  if (m = error.message.match(/at position (\\d+)/)) return Math.min(+m[1], doc.length);\n  if (m = error.message.match(/at line (\\d+) column (\\d+)/)) return Math.min(doc.line(+m[1]).from + +m[2] - 1, doc.length);\n  return 0;\n}\nconst jsonLanguage = language_1.LezerLanguage.define({\n  parser: lezer_json_1.parser.configure({\n    props: [language_1.indentNodeProp.add({\n      Object: language_1.continuedIndent({\n        except: /^\\s*\\}/\n      }),\n      Array: language_1.continuedIndent({\n        except: /^\\s*\\]/\n      })\n    }), language_1.foldNodeProp.add({\n      \"Object Array\": language_1.foldInside\n    }), highlight_1.styleTags({\n      String: highlight_1.tags.string,\n      Number: highlight_1.tags.number,\n      \"True False\": highlight_1.tags.bool,\n      PropertyName: highlight_1.tags.propertyName,\n      null: highlight_1.tags.null,\n      \",\": highlight_1.tags.separator,\n      \"[ ]\": highlight_1.tags.squareBracket,\n      \"{ }\": highlight_1.tags.brace\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"[\", \"{\", '\"']\n    },\n    indentOnInput: /^\\s*[\\}\\]]$/\n  }\n});\nfunction json() {\n  return new language_1.LanguageSupport(jsonLanguage);\n}\nexports.json = json;\nexports.jsonLanguage = jsonLanguage;\nexports.jsonParseLinter = jsonParseLinter;\n"}