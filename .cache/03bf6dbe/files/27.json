{"contents":"exports.__esModule = true;\nvar view_1 = __fusereq(13);\nvar state_1 = __fusereq(14);\nconst ios = typeof navigator != \"undefined\" && !(/Edge\\/(\\d+)/).exec(navigator.userAgent) && (/Apple Computer/).test(navigator.vendor) && ((/Mobile\\/\\w+/).test(navigator.userAgent) || navigator.maxTouchPoints > 2);\nconst Outside = \"-10000px\";\nconst tooltipPlugin = view_1.ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.inView = true;\n    this.measureReq = {\n      read: this.readMeasure.bind(this),\n      write: this.writeMeasure.bind(this),\n      key: this\n    };\n    this.input = view.state.facet(showTooltip);\n    this.tooltips = this.input.filter(t => t);\n    this.tooltipViews = this.tooltips.map(tp => this.createTooltip(tp));\n  }\n  update(update) {\n    let input = update.state.facet(showTooltip);\n    if (input == this.input) {\n      for (let t of this.tooltipViews) if (t.update) t.update(update);\n    } else {\n      let tooltips = input.filter(x => x);\n      let views = [];\n      for (let i = 0; i < tooltips.length; i++) {\n        let tip = tooltips[i], known = -1;\n        if (!tip) continue;\n        for (let i = 0; i < this.tooltips.length; i++) {\n          let other = this.tooltips[i];\n          if (other && other.create == tip.create) known = i;\n        }\n        if (known < 0) {\n          views[i] = this.createTooltip(tip);\n        } else {\n          let tooltipView = views[i] = this.tooltipViews[known];\n          if (tooltipView.update) tooltipView.update(update);\n        }\n      }\n      for (let t of this.tooltipViews) if (views.indexOf(t) < 0) t.dom.remove();\n      this.input = input;\n      this.tooltips = tooltips;\n      this.tooltipViews = views;\n      this.maybeMeasure();\n    }\n  }\n  createTooltip(tooltip) {\n    let tooltipView = tooltip.create(this.view);\n    tooltipView.dom.classList.add(\"cm-tooltip\");\n    if (tooltip.class) tooltipView.dom.classList.add(tooltip.class);\n    tooltipView.dom.style.top = Outside;\n    this.view.dom.appendChild(tooltipView.dom);\n    if (tooltipView.mount) tooltipView.mount(this.view);\n    return tooltipView;\n  }\n  destroy() {\n    for (let {dom} of this.tooltipViews) dom.remove();\n  }\n  readMeasure() {\n    return {\n      editor: this.view.dom.getBoundingClientRect(),\n      pos: this.tooltips.map(t => this.view.coordsAtPos(t.pos)),\n      size: this.tooltipViews.map(({dom}) => dom.getBoundingClientRect()),\n      innerWidth: window.innerWidth,\n      innerHeight: window.innerHeight\n    };\n  }\n  writeMeasure(measured) {\n    let {editor} = measured;\n    for (let i = 0; i < this.tooltipViews.length; i++) {\n      let tooltip = this.tooltips[i], tView = this.tooltipViews[i], {dom} = tView;\n      let pos = measured.pos[i], size = measured.size[i];\n      if (!pos || pos.bottom <= editor.top || pos.top >= editor.bottom || pos.right <= editor.left || pos.left >= editor.right) {\n        dom.style.top = Outside;\n        continue;\n      }\n      let width = size.right - size.left, height = size.bottom - size.top;\n      let left = this.view.textDirection == view_1.Direction.LTR ? Math.min(pos.left, measured.innerWidth - width) : Math.max(0, pos.left - width);\n      let above = !!tooltip.above;\n      if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight)) above = !above;\n      if (ios) {\n        dom.style.top = (above ? pos.top - height : pos.bottom) - editor.top + \"px\";\n        dom.style.left = left - editor.left + \"px\";\n        dom.style.position = \"absolute\";\n      } else {\n        dom.style.top = (above ? pos.top - height : pos.bottom) + \"px\";\n        dom.style.left = left + \"px\";\n      }\n      dom.classList.toggle(\"cm-tooltip-above\", above);\n      dom.classList.toggle(\"cm-tooltip-below\", !above);\n      if (tView.positioned) tView.positioned();\n    }\n  }\n  maybeMeasure() {\n    if (this.tooltips.length) {\n      if (this.view.inView || this.inView) this.view.requestMeasure(this.measureReq);\n      this.inView = this.view.inView;\n    }\n  }\n}, {\n  eventHandlers: {\n    scroll() {\n      this.maybeMeasure();\n    }\n  }\n});\nconst baseTheme = view_1.EditorView.baseTheme({\n  \".cm-tooltip\": {\n    position: \"fixed\",\n    zIndex: 100\n  },\n  \"&light .cm-tooltip\": {\n    border: \"1px solid #ddd\",\n    backgroundColor: \"#f5f5f5\"\n  },\n  \"&dark .cm-tooltip\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  }\n});\nfunction tooltips() {\n  return [];\n}\nconst showTooltip = state_1.Facet.define({\n  enables: [tooltipPlugin, baseTheme]\n});\nconst HoverTime = 750, HoverMaxDist = 6;\nclass HoverPlugin {\n  constructor(view, source, field, setHover) {\n    this.view = view;\n    this.source = source;\n    this.field = field;\n    this.setHover = setHover;\n    this.lastMouseMove = null;\n    this.hoverTimeout = -1;\n    this.restartTimeout = -1;\n    this.pending = null;\n    this.checkHover = this.checkHover.bind(this);\n    view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n    view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n  }\n  update() {\n    if (this.pending) {\n      this.pending = null;\n      clearTimeout(this.restartTimeout);\n      this.restartTimeout = setTimeout(() => this.startHover(), 20);\n    }\n  }\n  get active() {\n    return this.view.state.field(this.field);\n  }\n  checkHover() {\n    this.hoverTimeout = -1;\n    if (this.active) return;\n    let now = Date.now(), lastMove = this.lastMouseMove;\n    if (now - lastMove.timeStamp < HoverTime) this.hoverTimeout = setTimeout(this.checkHover, HoverTime - (now - lastMove.timeStamp)); else this.startHover();\n  }\n  startHover() {\n    var _a;\n    clearTimeout(this.restartTimeout);\n    let lastMove = this.lastMouseMove;\n    let coords = {\n      x: lastMove.clientX,\n      y: lastMove.clientY\n    };\n    let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(coords) : null;\n    if (pos == null) return;\n    let posCoords = this.view.coordsAtPos(pos);\n    if (posCoords == null || coords.y < posCoords.top || coords.y > posCoords.bottom || coords.x < posCoords.left - this.view.defaultCharacterWidth || coords.x > posCoords.right + this.view.defaultCharacterWidth) return;\n    let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);\n    let rtl = bidi && bidi.dir == view_1.Direction.RTL ? -1 : 1;\n    let open = this.source(this.view, pos, coords.x < posCoords.left ? -rtl : rtl);\n    if ((_a = open) === null || _a === void 0 ? void 0 : _a.then) {\n      let pending = this.pending = {\n        pos\n      };\n      open.then(result => {\n        if (this.pending == pending) {\n          this.pending = null;\n          if (result) this.view.dispatch({\n            effects: this.setHover.of(result)\n          });\n        }\n      }, e => view_1.logException(this.view.state, e, \"hover tooltip\"));\n    } else if (open) {\n      this.view.dispatch({\n        effects: this.setHover.of(open)\n      });\n    }\n  }\n  mousemove(event) {\n    var _a;\n    this.lastMouseMove = event;\n    if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, HoverTime);\n    let tooltip = this.active;\n    if (tooltip && !isInTooltip(event.target) || this.pending) {\n      let {pos} = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;\n      if (pos == end ? this.view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n      }) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, HoverMaxDist)) {\n        this.view.dispatch({\n          effects: this.setHover.of(null)\n        });\n        this.pending = null;\n      }\n    }\n  }\n  mouseleave() {\n    clearTimeout(this.hoverTimeout);\n    this.hoverTimeout = -1;\n    if (this.active) this.view.dispatch({\n      effects: this.setHover.of(null)\n    });\n  }\n  destroy() {\n    clearTimeout(this.hoverTimeout);\n    this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n    this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n  }\n}\nfunction isInTooltip(elt) {\n  for (let cur = elt; cur; cur = cur.parentNode) if (cur.nodeType == 1 && cur.classList.contains(\"cm-tooltip\")) return true;\n  return false;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n  let range = document.createRange();\n  let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);\n  range.setEnd(toDOM.node, toDOM.offset);\n  range.setStart(fromDOM.node, fromDOM.offset);\n  let rects = range.getClientRects();\n  range.detach();\n  for (let i = 0; i < rects.length; i++) {\n    let rect = rects[i];\n    let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);\n    if (dist <= margin) return true;\n  }\n  return false;\n}\nfunction hoverTooltip(source, options = {}) {\n  const setHover = state_1.StateEffect.define();\n  const hoverState = state_1.StateField.define({\n    create() {\n      return null;\n    },\n    update(value, tr) {\n      if (value && (options.hideOnChange && (tr.docChanged || tr.selection))) return null;\n      for (let effect of tr.effects) if (effect.is(setHover)) return effect.value;\n      if (value && tr.docChanged) {\n        let newPos = tr.changes.mapPos(value.pos, -1, state_1.MapMode.TrackDel);\n        if (newPos == null) return null;\n        let copy = Object.assign(Object.create(null), value);\n        copy.pos = newPos;\n        if (value.end != null) copy.end = tr.changes.mapPos(value.end);\n        return copy;\n      }\n      return value;\n    },\n    provide: f => showTooltip.from(f)\n  });\n  return [hoverState, view_1.ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover))];\n}\nexports.hoverTooltip = hoverTooltip;\nexports.showTooltip = showTooltip;\nexports.tooltips = tooltips;\n"}