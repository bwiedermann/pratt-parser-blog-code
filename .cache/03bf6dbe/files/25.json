{"contents":"exports.__esModule = true;\nvar state_1 = __fusereq(14);\nvar view_1 = __fusereq(13);\nvar text_1 = __fusereq(31);\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n  let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n  let ranges = [];\n  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n    let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n    for (let i = startLine; i <= endLine; i++) {\n      let line = state.doc.line(i);\n      if (line.length <= endOff) ranges.push(state_1.EditorSelection.range(line.from + startOff, line.to + endOff));\n    }\n  } else {\n    let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n    for (let i = startLine; i <= endLine; i++) {\n      let line = state.doc.line(i), str = line.length > MaxOff ? line.text.slice(0, 2 * endCol) : line.text;\n      let start = text_1.findColumn(str, 0, startCol, state.tabSize), end = text_1.findColumn(str, 0, endCol, state.tabSize);\n      if (!start.leftOver) ranges.push(state_1.EditorSelection.range(line.from + start.offset, line.from + end.offset));\n    }\n  }\n  return ranges;\n}\nfunction absoluteColumn(view, x) {\n  let ref = view.coordsAtPos(view.viewport.from);\n  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n  let offset = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  });\n  if (offset == null) return null;\n  let line = view.state.doc.lineAt(offset), off = offset - line.from;\n  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : text_1.countColumn(line.text.slice(0, offset - line.from), 0, view.state.tabSize);\n  return {\n    line: line.number,\n    col,\n    off\n  };\n}\nfunction rectangleSelectionStyle(view, event) {\n  let start = getPos(view, event), startSel = view.state.selection;\n  if (!start) return null;\n  return {\n    update(update) {\n      if (update.docChanged) {\n        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n        let newLine = update.state.doc.lineAt(newStart);\n        start = {\n          line: newLine.number,\n          col: start.col,\n          off: Math.min(start.off, newLine.length)\n        };\n        startSel = startSel.map(update.changes);\n      }\n    },\n    get(event, _extend, multiple) {\n      let cur = getPos(view, event);\n      if (!cur) return startSel;\n      let ranges = rectangleFor(view.state, start, cur);\n      if (!ranges.length) return startSel;\n      if (multiple) return state_1.EditorSelection.create(ranges.concat(startSel.ranges)); else return state_1.EditorSelection.create(ranges);\n    }\n  };\n}\nfunction rectangularSelection(options) {\n  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\n  return view_1.EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\nexports.rectangularSelection = rectangularSelection;\n"}