{"contents":"exports.__esModule = true;\nvar state_1 = __fusereq(14);\nvar parser_1 = __fusereq(35);\nexports.parseResults = state_1.StateField.define({\n  create() {\n    return emptyParseResults;\n  },\n  update(value, tr) {\n    return tr.docChanged ? parseProgram(tr) : value;\n  }\n});\nfunction parseProgram(tr) {\n  const contents = tr.state.doc.toString();\n  let varMap = {};\n  let registeredNodes = {};\n  let dependsMap = {};\n  const ast = parser_1.parse(contents, varMap, registeredNodes, dependsMap);\n  return {\n    nodes: ast.nodes,\n    parseErrors: ast.errors,\n    varMap: varMap,\n    registeredNodes: registeredNodes,\n    dependsMap: dependsMap\n  };\n}\nconst emptyParseResults = {\n  nodes: [],\n  parseErrors: [],\n  varMap: {},\n  registeredNodes: {},\n  dependsMap: {}\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/parseResults.ts\"],\"names\":[\"state_1\",\"define\",\"create\",\"emptyParseResults\",\"update\",\"value\",\"tr\",\"docChanged\",\"parseProgram\",\"contents\",\"state\",\"doc\",\"toString\",\"varMap\",\"registeredNodes\",\"dependsMap\",\"ast\",\"parser_1\",\"nodes\",\"parseErrors\",\"errors\"],\"mappings\":\";;;uBASsDA,mBAAWC;EAC/DC;WAAkBC;;EAClBC,OAAOC,OAAOC;WAAaA,GAAGC,aAAaC,aAAaF,MAAMD;;;AAMhE,sBAAsBC;QACdG,WAAWH,GAAGI,MAAMC,IAAIC;MAE1BC;MACAC;MACAC;QACEC,MAAMC,eAAMR,UAAUI,QAAQC,iBAAiBC;;IAGnDG,OAAOF,IAAIE;IACXC,aAAaH,IAAII;IACjBP,QAAQA;IACRC,iBAAiBA;IACjBC,YAAYA;;;MAkBVZ;EACJe;EACAC;EACAN;EACAC;EACAC\",\"sourcesContent\":[\"import {StateField} from \\\"@codemirror/state\\\"\\r\\nimport {Transaction} from \\\"@codemirror/state\\\"\\r\\nimport * as AST from './ast';\\r\\nimport {parse} from './parser';\\r\\nimport {ParseError} from './position';\\r\\n\\r\\n/**\\r\\n * A State field that holds the results of parsing\\r\\n */\\r\\nexport const parseResults: StateField<ParseResults> = StateField.define({\\r\\n  create() { return emptyParseResults },\\r\\n  update(value, tr) { return tr.docChanged ? parseProgram(tr) : value }\\r\\n})\\r\\n\\r\\n/**\\r\\n * Parse the program created from a transaction, returning a ParseResults object\\r\\n */\\r\\nfunction parseProgram(tr: Transaction) : ParseResults {\\r\\n  const contents = tr.state.doc.toString()\\r\\n\\r\\n  let varMap: {[key: string]: string} = {}\\r\\n  let registeredNodes: {[key: string]: AST.Node} = {}\\r\\n  let dependsMap: {[key: string]: string[]} = {}\\r\\n  const ast = parse(contents, varMap, registeredNodes, dependsMap)\\r\\n\\r\\n  return {\\r\\n    nodes: ast.nodes,\\r\\n    parseErrors: ast.errors,\\r\\n    varMap: varMap,\\r\\n    registeredNodes: registeredNodes,\\r\\n    dependsMap: dependsMap\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Type that describes the results of parsing\\r\\n */\\r\\nexport type ParseResults = {\\r\\n  nodes: AST.Node[];\\r\\n  parseErrors: ParseError[];\\r\\n  varMap: {[key: string]: string};\\r\\n  registeredNodes: {[key: string]: AST.Node};\\r\\n  dependsMap: {[key: string]: string[]};\\r\\n}\\r\\n\\r\\n/**\\r\\n * Can be used as the initial results of parsing\\r\\n */\\r\\nconst emptyParseResults: ParseResults = {\\r\\n  nodes: [],\\r\\n  parseErrors: [],\\r\\n  varMap: {},\\r\\n  registeredNodes: {},\\r\\n  dependsMap: {}\\r\\n}\\r\\n\"]}"}