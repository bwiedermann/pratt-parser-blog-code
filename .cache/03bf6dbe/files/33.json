{"contents":"var _1_, _2_;\nvar _3_, _4_;\nvar _5_, _6_;\nvar _7_, _8_;\nvar _9_, _10_;\nvar _11_, _12_;\nvar _13_, _14_;\nvar _15_, _16_;\nvar _17_, _18_;\nvar _19_, _20_;\nvar _21_, _22_;\nvar _23_, _24_;\nfunction typecheck(nodes, registeredNodes) {\n  const errors = nodes.map(n => typecheckNode(n, registeredNodes));\n  return [].concat(...errors);\n}\nexports.typecheck = typecheck;\nfunction typecheckNode(node, registeredNodes) {\n  return checkerMap[node.nodeType].check(node, registeredNodes);\n}\nclass TypeError {\n  constructor(message, position) {\n    this.message = message;\n    this.position = position;\n  }\n}\nexports.TypeError = TypeError;\nclass CheckNumber {\n  check(node) {\n    return [];\n  }\n}\nclass CheckBoolean {\n  check(node) {\n    return [];\n  }\n}\nclass CheckBinary {\n  check(node, registeredNodes) {\n    const errors = typecheckNode(node.left, registeredNodes).concat(typecheckNode(node.right, registeredNodes));\n    if (((_2_ = (_1_ = node.left) === null || _1_ === void 0 ? void 0 : _1_.outputType) === null || _2_ === void 0 ? void 0 : _2_.valueType) != ((_4_ = (_3_ = node.right) === null || _3_ === void 0 ? void 0 : _3_.outputType) === null || _4_ === void 0 ? void 0 : _4_.valueType)) {\n      errors.push(new TypeError(\"incompatible types for binary operator\", node.pos));\n    } else if (((_6_ = (_5_ = node.right) === null || _5_ === void 0 ? void 0 : _5_.outputType) === null || _6_ === void 0 ? void 0 : _6_.valueType) == 'boolean' && (node.operator != \"|\" && node.operator != '&')) {\n      errors.push(new TypeError(\"incompatible operation for boolean operands\", node.pos));\n    } else if (((_8_ = (_7_ = node.right) === null || _7_ === void 0 ? void 0 : _7_.outputType) === null || _8_ === void 0 ? void 0 : _8_.valueType) == 'number' && (node.operator == \"|\" || node.operator == '&')) {\n      errors.push(new TypeError(\"incompatible operation for number operands\", node.pos));\n    }\n    node.outputType.valueType = (_10_ = (_9_ = node.left) === null || _9_ === void 0 ? void 0 : _9_.outputType) === null || _10_ === void 0 ? void 0 : _10_.valueType;\n    return errors;\n  }\n}\nclass CheckFunction {\n  check(node, registeredNodes) {\n    let errors = [];\n    const arg1Errors = typecheckNode(node.args[0], registeredNodes);\n    errors = errors.concat(arg1Errors);\n    if (node.args.length > 1) {\n      const arg2Errors = typecheckNode(node.args[1], registeredNodes);\n      errors = errors.concat(arg2Errors);\n      if (((_12_ = (_11_ = node.args[0]) === null || _11_ === void 0 ? void 0 : _11_.outputType) === null || _12_ === void 0 ? void 0 : _12_.valueType) != ((_14_ = (_13_ = node.args[1]) === null || _13_ === void 0 ? void 0 : _13_.outputType) === null || _14_ === void 0 ? void 0 : _14_.valueType)) {\n        errors.push(new TypeError(\"arguments must have same type\", node.args[0].pos));\n      }\n    }\n    const functionName = node.name;\n    const argType = builtins[functionName].inputType;\n    if (argType) {\n      if (argType != 'any' && ((_16_ = (_15_ = node.args[0]) === null || _15_ === void 0 ? void 0 : _15_.outputType) === null || _16_ === void 0 ? void 0 : _16_.valueType) != argType) {\n        errors.push(new TypeError(\"incompatible argument type for \" + functionName, node.pos));\n      }\n    } else {\n      errors.push(new TypeError(\"unknown function\", node.pos));\n    }\n    return errors;\n  }\n}\nclass CheckChoose {\n  check(node, registeredNodes) {\n    let errors = [];\n    const predicate = node.case.predicate;\n    const consequent = node.case.consequent;\n    const otherwise = node.otherwise;\n    const predErrors = typecheckNode(predicate, registeredNodes);\n    const consErrors = typecheckNode(consequent, registeredNodes);\n    const otherErrors = typecheckNode(otherwise, registeredNodes);\n    errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\n    if (((_18_ = (_17_ = consequent) === null || _17_ === void 0 ? void 0 : _17_.outputType) === null || _18_ === void 0 ? void 0 : _18_.valueType) != ((_20_ = (_19_ = otherwise) === null || _19_ === void 0 ? void 0 : _19_.outputType) === null || _20_ === void 0 ? void 0 : _20_.valueType)) {\n      errors.push(new TypeError(\"Return types are not the same for both cases\", consequent.pos));\n      errors.push(new TypeError(\"Return types are not the same for both cases\", otherwise.pos));\n    }\n    if (predicate.outputType.valueType != 'boolean') {\n      errors.push(new TypeError(\"Predicate must return a boolean\", predicate.pos));\n    }\n    node.outputType.valueType = (_22_ = (_21_ = consequent) === null || _21_ === void 0 ? void 0 : _21_.outputType) === null || _22_ === void 0 ? void 0 : _22_.valueType;\n    return errors;\n  }\n}\nclass CheckVariable {\n  check(node, registeredNodes) {\n    let errors = [];\n    const assignmentErrors = typecheckNode(node.assignment, registeredNodes);\n    errors = errors.concat(assignmentErrors);\n    node.outputType.valueType = (_24_ = (_23_ = node.assignment) === null || _23_ === void 0 ? void 0 : _23_.outputType) === null || _24_ === void 0 ? void 0 : _24_.valueType;\n    return errors;\n  }\n}\nclass CheckIdentifier {\n  check(node, registeredNodes) {\n    let errors = [];\n    let valueNode = registeredNodes[node.assignmentId].assignment;\n    if (valueNode == undefined) {\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\n    }\n    node.outputType.valueType = valueNode.outputType.valueType;\n    return errors;\n  }\n}\nconst builtins = {\n  \"IsDefined\": {\n    inputType: 'any',\n    resultType: 'boolean'\n  },\n  \"Inverse\": {\n    inputType: 'number',\n    resultType: 'number'\n  },\n  \"Input\": {\n    inputType: 'number',\n    resultType: 'number'\n  },\n  \"Sink\": {\n    inputType: 'any',\n    resultType: 'any'\n  },\n  \"RandomChoice\": {\n    inputType: 'number',\n    resultType: 'number'\n  },\n  \"TestConstant\": {\n    inputType: 'any',\n    resultType: 'any'\n  },\n  \"ParseOrderedPair\": {\n    inputType: 'number',\n    resultType: 'pair'\n  },\n  \"X\": {\n    inputType: 'pair',\n    resultType: 'number'\n  },\n  \"Y\": {\n    inputType: 'pair',\n    resultType: 'number'\n  }\n};\nconst checkerMap = {\n  'Number': new CheckNumber(),\n  'Boolean': new CheckBoolean(),\n  'BinaryOperation': new CheckBinary(),\n  'Function': new CheckFunction(),\n  'Choose': new CheckChoose(),\n  'VariableAssignment': new CheckVariable(),\n  'Identifier': new CheckIdentifier()\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/typechecker.ts\"],\"names\":[\"nodes\",\"registeredNodes\",\"errors\",\"map\",\"n\",\"typecheckNode\",\"concat\",\"node\",\"checkerMap\",\"nodeType\",\"check\",\"constructor\",\"message\",\"position\",\"left\",\"right\",\"outputType\",\"valueType\",\"push\",\"TypeError\",\"pos\",\"operator\",\"arg1Errors\",\"args\",\"length\",\"arg2Errors\",\"functionName\",\"name\",\"argType\",\"builtins\",\"inputType\",\"predicate\",\"case\",\"consequent\",\"otherwise\",\"predErrors\",\"consErrors\",\"otherErrors\",\"assignmentErrors\",\"assignment\",\"valueNode\",\"assignmentId\",\"undefined\",\"resultType\",\"CheckNumber\",\"CheckBoolean\",\"CheckBinary\",\"CheckFunction\",\"CheckChoose\",\"CheckVariable\",\"CheckIdentifier\"],\"mappings\":\"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\",\"sourcesContent\":[\"import {Position} from './position';\\r\\nimport * as AST from './ast';\\r\\nimport {equals} from './equals';\\r\\n\\r\\n/***** ITERATION: change all outputType.valueType to simply outputType *****/\\r\\n\\r\\nexport function typecheck(nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n  const errors = nodes.map(n => typecheckNode(n, registeredNodes));\\r\\n  return ([] as TypeError[]).concat(...errors);\\r\\n}\\r\\n\\r\\nfunction typecheckNode(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n  return checkerMap[node.nodeType].check(node, registeredNodes);\\r\\n}\\r\\n\\r\\nexport class TypeError {\\r\\n  constructor(public message: string, public position: Position) {}\\r\\n}\\r\\n\\r\\nexport interface TypeChecker {\\r\\n  check(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[];\\r\\n}\\r\\n\\r\\nclass CheckNumber implements TypeChecker {\\r\\n  check(node: AST.NumberNode): TypeError[] {\\r\\n    return [];\\r\\n  }\\r\\n}\\r\\n\\r\\nclass CheckBoolean implements TypeChecker {\\r\\n  check(node: AST.BooleanNode): TypeError[] {\\r\\n    return [];\\r\\n  }\\r\\n}\\r\\n\\r\\nclass CheckBinary implements TypeChecker {\\r\\n  check(node: AST.BinaryOperationNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n    const errors: TypeError[] = typecheckNode(node.left, registeredNodes).concat(typecheckNode(node.right, registeredNodes));\\r\\n    \\r\\n    // Check if same operand type (both numbers, both booleans)\\r\\n    if (node.left?.outputType?.valueType != node.right?.outputType?.valueType) {\\r\\n      errors.push(new TypeError(\\\"incompatible types for binary operator\\\", node.pos));\\r\\n    }\\r\\n    // Check if incorrect combination of operator and operands\\r\\n    else if (node.right?.outputType?.valueType == 'boolean' && (node.operator != \\\"|\\\" && node.operator != '&')) {\\r\\n      errors.push(new TypeError(\\\"incompatible operation for boolean operands\\\", node.pos));\\r\\n    }\\r\\n    else if (node.right?.outputType?.valueType == 'number' && (node.operator == \\\"|\\\" || node.operator == '&')) {\\r\\n      errors.push(new TypeError(\\\"incompatible operation for number operands\\\", node.pos));\\r\\n    }\\r\\n\\r\\n    node.outputType!.valueType = node.left?.outputType?.valueType;\\r\\n\\r\\n    return errors;\\r\\n  }\\r\\n}\\r\\n\\r\\nclass CheckFunction implements TypeChecker {\\r\\n  check(node: AST.FunctionNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n    let errors: TypeError[] = [];\\r\\n\\r\\n    // First typecheck the argument\\r\\n    const arg1Errors = typecheckNode(node.args[0], registeredNodes);\\r\\n    errors = errors.concat(arg1Errors);\\r\\n    if (node.args.length > 1) {\\r\\n      const arg2Errors = typecheckNode(node.args[1], registeredNodes);\\r\\n      errors = errors.concat(arg2Errors);\\r\\n      if (node.args[0]?.outputType?.valueType != node.args[1]?.outputType?.valueType) {\\r\\n        errors.push(new TypeError(\\\"arguments must have same type\\\", node.args[0].pos));\\r\\n      }\\r\\n    }\\r\\n\\r\\n    const functionName = node.name\\r\\n    const argType = builtins[functionName].inputType;\\r\\n\\r\\n    // we found a builtin function\\r\\n    if (argType) {\\r\\n\\r\\n      // typecheck the argument\\r\\n      // Assume both arguments are the same type (see error produced above)\\r\\n      if (argType != 'any' && node.args[0]?.outputType?.valueType != argType) {\\r\\n        errors.push(new TypeError(\\\"incompatible argument type for \\\" + functionName, node.pos));\\r\\n      }\\r\\n    }\\r\\n  \\r\\n    // this is not a known, builtin function\\r\\n    else {\\r\\n      errors.push(new TypeError(\\\"unknown function\\\", node.pos));\\r\\n    }    \\r\\n\\r\\n    return errors;\\r\\n  }\\r\\n}\\r\\n\\r\\nclass CheckChoose implements TypeChecker {\\r\\n  check(node: AST.ChooseNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n    let errors: TypeError[] = [];\\r\\n\\r\\n    const predicate = node.case.predicate;\\r\\n    const consequent = node.case.consequent;\\r\\n    const otherwise = node.otherwise;\\r\\n\\r\\n    // First typecheck the inner nodes\\r\\n    const predErrors = typecheckNode(predicate, registeredNodes);\\r\\n    const consErrors = typecheckNode(consequent, registeredNodes);\\r\\n    const otherErrors = typecheckNode(otherwise, registeredNodes);\\r\\n    errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\\r\\n\\r\\n    // check return types are the same for both cases\\r\\n    if (consequent?.outputType?.valueType != otherwise?.outputType?.valueType) {\\r\\n      errors.push(new TypeError(\\\"Return types are not the same for both cases\\\", consequent.pos));\\r\\n      errors.push(new TypeError(\\\"Return types are not the same for both cases\\\", otherwise.pos));\\r\\n    }\\r\\n\\r\\n    // check that the predicate returns a boolean\\r\\n    if (predicate.outputType.valueType != 'boolean') {\\r\\n      errors.push(new TypeError(\\\"Predicate must return a boolean\\\", predicate.pos));\\r\\n    }\\r\\n\\r\\n    node.outputType.valueType = consequent?.outputType?.valueType;\\r\\n\\r\\n    return errors;\\r\\n  }\\r\\n}\\r\\n\\r\\nclass CheckVariable implements TypeChecker {\\r\\n  check(node: AST.VariableAssignmentNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n    let errors: TypeError[] = [];\\r\\n    // First typecheck the assignment node\\r\\n    const assignmentErrors = typecheckNode(node.assignment, registeredNodes);\\r\\n    errors = errors.concat(assignmentErrors);\\r\\n\\r\\n    node.outputType.valueType = node.assignment?.outputType?.valueType;\\r\\n\\r\\n    return errors;\\r\\n  }\\r\\n}\\r\\n\\r\\nclass CheckIdentifier implements TypeChecker {\\r\\n  check(node: AST.IdentifierNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n    let errors: TypeError[] = [];\\r\\n\\r\\n    // Maybe make assigmentId be valueId?\\r\\n    let valueNode = registeredNodes[node.assignmentId].assignment;\\r\\n\\r\\n    // If this assignmentId is not found in the AST, throw an error\\r\\n    if (valueNode == undefined) {\\r\\n      errors.push(new TypeError(\\\"This variable doesn't have a value\\\", node.pos));\\r\\n    }\\r\\n\\r\\n    node.outputType.valueType = valueNode.outputType.valueType;\\r\\n\\r\\n    return errors;\\r\\n  }\\r\\n}\\r\\n\\r\\n// Dictionary of builtin functions that maps a function name to the type of its argument\\r\\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType} } = {\\r\\n  \\\"IsDefined\\\": {inputType: 'any', resultType: 'boolean'},\\r\\n  \\\"Inverse\\\": {inputType: 'number', resultType: 'number'},\\r\\n  \\\"Input\\\": {inputType: 'number', resultType: 'number'},\\r\\n  \\\"Sink\\\": {inputType: 'any', resultType: 'any'},\\r\\n  \\\"RandomChoice\\\": {inputType: 'number', resultType: 'number'},\\r\\n  \\\"TestConstant\\\": {inputType: 'any', resultType: 'any'},\\r\\n  \\\"ParseOrderedPair\\\": {inputType: 'number', resultType: 'pair'},\\r\\n  \\\"X\\\": {inputType: 'pair', resultType: 'number'},\\r\\n  \\\"Y\\\": {inputType: 'pair', resultType: 'number'}\\r\\n}\\r\\n\\r\\nconst checkerMap: Partial<{[K in AST.NodeType]: TypeChecker}> = {\\r\\n  'Number' : new CheckNumber(),\\r\\n  'Boolean' : new CheckBoolean(),\\r\\n  'BinaryOperation' : new CheckBinary(),\\r\\n  'Function' : new CheckFunction(),\\r\\n  'Choose': new CheckChoose(),\\r\\n  'VariableAssignment': new CheckVariable(),\\r\\n  'Identifier': new CheckIdentifier()\\r\\n}\"]}"}