{"contents":"exports.__esModule = true;\nvar lexer_1 = __fusereq(32);\nvar typechecker_1 = __fusereq(33);\nvar mudChecker_1 = __fusereq(34);\nvar darChecker_1 = __fusereq(190);\nvar parseResults_1 = __fusereq(7);\nexports.miniCL = {\n  startState: function () {\n    return {\n      line: 1,\n      stack: ['default']\n    };\n  },\n  token: function (stream, state) {\n    if (stream.eatSpace()) return null;\n    return token2tag(lexer_1.getDefaultToken(stream, state));\n  }\n};\nexports.miniCLLinter = () => view => {\n  const results = view.state.field(parseResults_1.parseResults);\n  let assertMap = [];\n  const mudErrors = mudChecker_1.mudCheck(results.nodes, results.registeredNodes, results.dependsMap, assertMap);\n  const typeErrors = typechecker_1.typecheck(results.nodes, results.registeredNodes);\n  const darErrors = darChecker_1.darCheck(results.nodes, results.registeredNodes);\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\n  const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\n  const darDiagnostics = darErrors.map(makeDiagnostic(view, 'warning'));\n  return parseDiagnostics.concat(typeDiagnostics).concat(darDiagnostics);\n};\nconst makeDiagnostic = (view, severity = 'error') => error => {\n  return {\n    from: firstLine(view, error) + error.position.first_column,\n    to: lastLine(view, error) + error.position.last_column,\n    message: error.message,\n    severity: severity\n  };\n};\nfunction firstLine(view, error) {\n  return view.state.doc.line(error.position.first_line).from;\n}\nfunction lastLine(view, error) {\n  return view.state.doc.line(error.position.last_line).from;\n}\nfunction token2tag(token) {\n  switch (token) {\n    case 'NUMBER':\n      return 'number';\n    case 'TRUE':\n      return 'boolean';\n    case 'FALSE':\n      return 'boolean';\n    case '(':\n    case ')':\n      return 'bracket';\n    case '+':\n    case '-':\n    case '*':\n    case '/':\n    case '|':\n    case '&':\n    case '=':\n      return 'operator';\n    case 'COMMENT':\n      return 'comment';\n    case 'CHOOSE1':\n    case 'CHOOSE2':\n      return 'choose';\n    case 'FUNCTION':\n      return 'function';\n    case 'IDENTIFIER':\n      return 'variable';\n    case 'ERROR':\n      return 'error';\n    default:\n      return undefined;\n  }\n}\n","sourceMap":"{\"version\":3,\"sources\":[\"src/miniCL.ts\"],\"names\":[\"startState\",\"line\",\"stack\",\"token\",\"stream\",\"state\",\"eatSpace\",\"token2tag\",\"lexer_1\",\"view\",\"results\",\"field\",\"parseResults_1\",\"assertMap\",\"mudErrors\",\"mudChecker_1\",\"nodes\",\"registeredNodes\",\"dependsMap\",\"typeErrors\",\"typechecker_1\",\"darErrors\",\"darChecker_1\",\"parseDiagnostics\",\"parseErrors\",\"map\",\"makeDiagnostic\",\"typeDiagnostics\",\"mudDiagnostics\",\"darDiagnostics\",\"concat\",\"severity\",\"error\",\"from\",\"firstLine\",\"position\",\"first_column\",\"to\",\"lastLine\",\"last_column\",\"message\",\"doc\",\"first_line\",\"last_line\",\"undefined\"],\"mappings\":\";;;;;;;EAcEA,YAAY;;MACFC,MAAM;MAAGC,QAAQ;;;EAE3BC,OAAO,UAAUC,QAAsBC;QACjCD,OAAOE,mBAAmB;WACvBC,UAAUC,wBAAgBJ,QAAQC;;;uBAOhB,MAAM,AAACI;QAG5BC,UAAUD,KAAKJ,MAAMM,MAAMC;MAG7BC;QACEC,YAAYC,sBAASL,QAAQM,OAAON,QAAQO,iBAAiBP,QAAQQ,YAAYL;QACjFM,aAAaC,wBAAUV,QAAQM,OAAON,QAAQO;QAC9CI,YAAYC,sBAASZ,QAAQM,OAAON,QAAQO;QAG5CM,mBAAmBb,QAAQc,YAAYC,IAAIC,eAAejB;QAC1DkB,kBAAkBR,WAAWM,IAAIC,eAAejB;QAChDmB,iBAAiBd,UAAUW,IAAIC,eAAejB,MAAM;QACpDoB,iBAAiBR,UAAUI,IAAIC,eAAejB,MAAM;SAEnDc,iBAAiBO,OAAOH,iBAAiBG,OAAOD;;MAMnDH,iBAAiB,CAACjB,MAAkBsB,WAAyC,YACjF,AAACC;;IAEGC,MAAMC,UAAUzB,MAAMuB,SAASA,MAAMG,SAASC;IAC9CC,IAAIC,SAAS7B,MAAMuB,SAASA,MAAMG,SAASI;IAC3CC,SAASR,MAAMQ;IACfT,UAAUA;;;AAOhB,mBAAmBtB,MAAkBuB;SAC5BvB,KAAKJ,MAAMoC,IAAIxC,KAAK+B,MAAMG,SAASO,YAAYT;;AAMxD,kBAAmBxB,MAAkBuB;SAC5BvB,KAAKJ,MAAMoC,IAAIxC,KAAK+B,MAAMG,SAASQ,WAAWV;;AAMvD,mBAAmB9B;UACTA;SACD;aACI;SAEJ;aACI;SAEJ;aACI;SAEJ;SACA;aACI;SAEJ;SACA;SACA;SACA;SACA;SACA;SACA;aACI;SAEJ;aACI;SAEJ;SACA;aACI;SAEJ;aACI;SAEJ;aACI;SAEJ;aACI;;aAGAyC\",\"sourcesContent\":[\"import {StreamParser, StringStream} from \\\"@codemirror/stream-parser\\\"\\r\\nimport {Diagnostic} from \\\"@codemirror/lint\\\"\\r\\nimport {EditorView} from \\\"@codemirror/view\\\"\\r\\nimport {State, getDefaultToken} from './lexer'\\r\\nimport {ParseError} from './position'\\r\\nimport {typecheck} from './typechecker';\\r\\nimport {mudCheck} from './mudChecker';\\r\\nimport {darCheck} from './darChecker';\\r\\nimport {parseResults} from './parseResults';\\r\\n\\r\\n/**\\r\\n * The extension for our language\\r\\n */\\r\\nexport const miniCL: StreamParser<State> = {\\r\\n  startState: function (): State {\\r\\n    return {line: 1, stack: ['default']};\\r\\n  },\\r\\n  token: function (stream: StringStream, state: State): string | undefined {\\r\\n    if (stream.eatSpace()) return null;\\r\\n    return token2tag(getDefaultToken(stream, state));\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * The linter for our language\\r\\n */\\r\\n export const miniCLLinter = () => (view: EditorView): Diagnostic[] => {\\r\\n\\r\\n  // Get the result types\\r\\n  const results = view.state.field(parseResults);\\r\\n\\r\\n  // Error checking\\r\\n  let assertMap: string[] = [];\\r\\n  const mudErrors = mudCheck(results.nodes, results.registeredNodes, results.dependsMap, assertMap);\\r\\n  const typeErrors = typecheck(results.nodes, results.registeredNodes);\\r\\n  const darErrors = darCheck(results.nodes, results.registeredNodes);\\r\\n\\r\\n  // Create a diagnostic for each kind of error\\r\\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\\r\\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\\r\\n  const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\\r\\n  const darDiagnostics = darErrors.map(makeDiagnostic(view, 'warning'));\\r\\n\\r\\n  return parseDiagnostics.concat(typeDiagnostics).concat(darDiagnostics);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Create a diagnostic from an error\\r\\n */\\r\\nconst makeDiagnostic = (view: EditorView, severity: 'error' | 'info' | 'warning' = 'error') => \\r\\n  (error): Diagnostic => {\\r\\n    return {\\r\\n      from: firstLine(view, error) + error.position.first_column,\\r\\n      to: lastLine(view, error) + error.position.last_column,\\r\\n      message: error.message,\\r\\n      severity: severity\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @returns the line number for the start of the error\\r\\n */\\r\\nfunction firstLine(view: EditorView, error: ParseError) {\\r\\n  return view.state.doc.line(error.position.first_line).from;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @returns the line number for the end of the error\\r\\n */\\r\\nfunction lastLine (view: EditorView, error: ParseError) {\\r\\n  return view.state.doc.line(error.position.last_line).from;    \\r\\n}\\r\\n\\r\\n/**\\r\\n * Convert our bespoke parser Token type to a token type that is recognized by CodeMirror\\r\\n */\\r\\nfunction token2tag(token: string): string | undefined {\\r\\n  switch (token) {\\r\\n    case 'NUMBER':\\r\\n      return 'number';\\r\\n\\r\\n    case 'TRUE':\\r\\n      return 'boolean';\\r\\n\\r\\n    case 'FALSE':\\r\\n      return 'boolean';\\r\\n\\r\\n    case '(':\\r\\n    case ')':\\r\\n      return 'bracket';\\r\\n\\r\\n    case '+':\\r\\n    case '-':\\r\\n    case '*':\\r\\n    case '/':\\r\\n    case '|':\\r\\n    case '&':\\r\\n    case '=':\\r\\n      return 'operator';\\r\\n\\r\\n    case 'COMMENT':\\r\\n      return 'comment';\\r\\n\\r\\n    case 'CHOOSE1':\\r\\n    case 'CHOOSE2':\\r\\n      return 'choose';\\r\\n\\r\\n    case 'FUNCTION':\\r\\n      return 'function';\\r\\n\\r\\n    case 'IDENTIFIER':\\r\\n      return 'variable';\\r\\n\\r\\n    case 'ERROR':\\r\\n      return 'error';\\r\\n\\r\\n    default:\\r\\n      return undefined;\\r\\n  }\\r\\n}\\r\\n\"]}"}