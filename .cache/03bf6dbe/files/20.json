{"contents":"exports.__esModule = true;\nvar state_1 = __fusereq(14);\nvar language_1 = __fusereq(17);\nvar view_1 = __fusereq(13);\nvar lezer_tree_1 = __fusereq(30);\nconst baseTheme = view_1.EditorView.baseTheme({\n  \".cm-matchingBracket\": {\n    color: \"#0b0\"\n  },\n  \".cm-nonmatchingBracket\": {\n    color: \"#a22\"\n  }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = state_1.Facet.define({\n  combine(configs) {\n    return state_1.combineConfig(configs, {\n      afterCursor: true,\n      brackets: DefaultBrackets,\n      maxScanDistance: DefaultScanDist\n    });\n  }\n});\nconst matchingMark = view_1.Decoration.mark({\n  class: \"cm-matchingBracket\"\n}), nonmatchingMark = view_1.Decoration.mark({\n  class: \"cm-nonmatchingBracket\"\n});\nconst bracketMatchingState = state_1.StateField.define({\n  create() {\n    return view_1.Decoration.none;\n  },\n  update(deco, tr) {\n    if (!tr.docChanged && !tr.selection) return deco;\n    let decorations = [];\n    let config = tr.state.facet(bracketMatchingConfig);\n    for (let range of tr.state.selection.ranges) {\n      if (!range.empty) continue;\n      let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n      if (!match) continue;\n      let mark = match.matched ? matchingMark : nonmatchingMark;\n      decorations.push(mark.range(match.start.from, match.start.to));\n      if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n    }\n    return view_1.Decoration.set(decorations, true);\n  },\n  provide: f => view_1.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [bracketMatchingState, baseTheme];\nfunction bracketMatching(config = {}) {\n  return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n  let byProp = node.prop(dir < 0 ? lezer_tree_1.NodeProp.openedBy : lezer_tree_1.NodeProp.closedBy);\n  if (byProp) return byProp;\n  if (node.name.length == 1) {\n    let index = brackets.indexOf(node.name);\n    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];\n  }\n  return null;\n}\nfunction matchBrackets(state, pos, dir, config = {}) {\n  let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n  let tree = language_1.syntaxTree(state), sub = tree.resolve(pos, dir), matches;\n  if (matches = matchingNodes(sub.type, dir, brackets)) return matchMarkedBrackets(state, pos, dir, sub, matches, brackets); else return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n  let parent = token.parent, firstToken = {\n    from: token.from,\n    to: token.to\n  };\n  let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n      if (depth == 0 && matching.indexOf(cursor.type.name) > -1) {\n        return {\n          start: firstToken,\n          end: {\n            from: cursor.from,\n            to: cursor.to\n          },\n          matched: true\n        };\n      } else if (matchingNodes(cursor.type, dir, brackets)) {\n        depth++;\n      } else if (matchingNodes(cursor.type, -dir, brackets)) {\n        depth--;\n        if (depth == 0) return {\n          start: firstToken,\n          end: {\n            from: cursor.from,\n            to: cursor.to\n          },\n          matched: false\n        };\n      }\n    }\n  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n  return {\n    start: firstToken,\n    matched: false\n  };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n  let bracket = brackets.indexOf(startCh);\n  if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n  let startToken = {\n    from: dir < 0 ? pos - 1 : pos,\n    to: dir > 0 ? pos + 1 : pos\n  };\n  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {\n    let text = iter.value;\n    if (dir < 0) distance += text.length;\n    let basePos = pos + distance * dir;\n    for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n      let found = brackets.indexOf(text[pos]);\n      if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType) continue;\n      if (found % 2 == 0 == dir > 0) {\n        depth++;\n      } else if (depth == 1) {\n        return {\n          start: startToken,\n          end: {\n            from: basePos + pos,\n            to: basePos + pos + 1\n          },\n          matched: found >> 1 == bracket >> 1\n        };\n      } else {\n        depth--;\n      }\n    }\n    if (dir > 0) distance += text.length;\n  }\n  return iter.done ? {\n    start: startToken,\n    matched: false\n  } : null;\n}\nexports.bracketMatching = bracketMatching;\nexports.matchBrackets = matchBrackets;\n"}