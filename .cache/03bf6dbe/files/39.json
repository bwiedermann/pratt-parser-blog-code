{"contents":"exports.__esModule = true;\nvar state_1 = __fusereq(14);\nclass RangeValue {\n  eq(other) {\n    return this == other;\n  }\n  range(from, to = from) {\n    return new Range(from, to, this);\n  }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = state_1.MapMode.TrackDel;\nclass Range {\n  constructor(from, to, value) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n  }\n}\nfunction cmpRange(a, b) {\n  return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n  constructor(from, to, value, maxPoint) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n    this.maxPoint = maxPoint;\n  }\n  get length() {\n    return this.to[this.to.length - 1];\n  }\n  findIndex(pos, end, side = end * 1000000000, startAt = 0) {\n    if (pos <= 0) return startAt;\n    let arr = end < 0 ? this.to : this.from;\n    for (let lo = startAt, hi = arr.length; ; ) {\n      if (lo == hi) return lo;\n      let mid = lo + hi >> 1;\n      let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n      if (mid == lo) return diff >= 0 ? lo : hi;\n      if (diff >= 0) hi = mid; else lo = mid + 1;\n    }\n  }\n  between(offset, from, to, f) {\n    for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++) if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n  }\n  map(offset, changes) {\n    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n    for (let i = 0; i < this.value.length; i++) {\n      let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n      if (curFrom == curTo) {\n        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n        if (mapped == null) continue;\n        newFrom = newTo = mapped;\n      } else {\n        newFrom = changes.mapPos(curFrom, val.startSide);\n        newTo = changes.mapPos(curTo, val.endSide);\n        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n      }\n      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n      if (newPos < 0) newPos = newFrom;\n      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n      value.push(val);\n      from.push(newFrom - newPos);\n      to.push(newTo - newPos);\n    }\n    return {\n      mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n      pos: newPos\n    };\n  }\n}\nclass RangeSet {\n  constructor(chunkPos, chunk, nextLayer = RangeSet.empty, maxPoint) {\n    this.chunkPos = chunkPos;\n    this.chunk = chunk;\n    this.nextLayer = nextLayer;\n    this.maxPoint = maxPoint;\n  }\n  get length() {\n    let last = this.chunk.length - 1;\n    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n  }\n  get size() {\n    if (this == RangeSet.empty) return 0;\n    let size = this.nextLayer.size;\n    for (let chunk of this.chunk) size += chunk.value.length;\n    return size;\n  }\n  chunkEnd(index) {\n    return this.chunkPos[index] + this.chunk[index].length;\n  }\n  update(updateSpec) {\n    let {add = [], sort = false, filterFrom = 0, filterTo = this.length} = updateSpec;\n    let filter = updateSpec.filter;\n    if (add.length == 0 && !filter) return this;\n    if (sort) add.slice().sort(cmpRange);\n    if (this == RangeSet.empty) return add.length ? RangeSet.of(add) : this;\n    let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n    let builder = new RangeSetBuilder();\n    while (cur.value || i < add.length) {\n      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n        let range = add[i++];\n        if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n        cur.nextChunk();\n      } else {\n        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n          if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(new Range(cur.from, cur.to, cur.value));\n        }\n        cur.next();\n      }\n    }\n    return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n      add: spill,\n      filter,\n      filterFrom,\n      filterTo\n    }));\n  }\n  map(changes) {\n    if (changes.length == 0 || this == RangeSet.empty) return this;\n    let chunks = [], chunkPos = [], maxPoint = -1;\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i], chunk = this.chunk[i];\n      let touch = changes.touchesRange(start, start + chunk.length);\n      if (touch === false) {\n        maxPoint = Math.max(maxPoint, chunk.maxPoint);\n        chunks.push(chunk);\n        chunkPos.push(changes.mapPos(start));\n      } else if (touch === true) {\n        let {mapped, pos} = chunk.map(start, changes);\n        if (mapped) {\n          maxPoint = Math.max(maxPoint, mapped.maxPoint);\n          chunks.push(mapped);\n          chunkPos.push(pos);\n        }\n      }\n    }\n    let next = this.nextLayer.map(changes);\n    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n  }\n  between(from, to, f) {\n    if (this == RangeSet.empty) return;\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i], chunk = this.chunk[i];\n      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n    }\n    this.nextLayer.between(from, to, f);\n  }\n  iter(from = 0) {\n    return HeapCursor.from([this]).goto(from);\n  }\n  static iter(sets, from = 0) {\n    return HeapCursor.from(sets).goto(from);\n  }\n  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {\n    let a = oldSets.filter(set => set.maxPoint >= 500 || set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n    let b = newSets.filter(set => set.maxPoint >= 500 || set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n    let sharedChunks = findSharedChunks(a, b);\n    let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n    let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n    if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n  }\n  static spans(sets, from, to, iterator, minPointSize = -1) {\n    let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n    let open = cursor.openStart;\n    for (; ; ) {\n      let curTo = Math.min(cursor.to, to);\n      if (cursor.point) {\n        iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n        open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n      } else if (curTo > pos) {\n        iterator.span(pos, curTo, cursor.active, open);\n        open = cursor.openEnd(curTo);\n      }\n      if (cursor.to > to) break;\n      pos = cursor.to;\n      cursor.next();\n    }\n    return open;\n  }\n  static of(ranges, sort = false) {\n    let build = new RangeSetBuilder();\n    for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges) build.add(range.from, range.to, range.value);\n    return build.finish();\n  }\n}\nRangeSet.empty = new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\nclass RangeSetBuilder {\n  constructor() {\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunkStart = -1;\n    this.last = null;\n    this.lastFrom = -1000000000;\n    this.lastTo = -1000000000;\n    this.from = [];\n    this.to = [];\n    this.value = [];\n    this.maxPoint = -1;\n    this.setMaxPoint = -1;\n    this.nextLayer = null;\n  }\n  finishChunk(newArrays) {\n    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n    this.chunkPos.push(this.chunkStart);\n    this.chunkStart = -1;\n    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n    this.maxPoint = -1;\n    if (newArrays) {\n      this.from = [];\n      this.to = [];\n      this.value = [];\n    }\n  }\n  add(from, to, value) {\n    if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);\n  }\n  addInner(from, to, value) {\n    let diff = from - this.lastTo || value.startSide - this.last.endSide;\n    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n    if (diff < 0) return false;\n    if (this.from.length == 250) this.finishChunk(true);\n    if (this.chunkStart < 0) this.chunkStart = from;\n    this.from.push(from - this.chunkStart);\n    this.to.push(to - this.chunkStart);\n    this.last = value;\n    this.lastFrom = from;\n    this.lastTo = to;\n    this.value.push(value);\n    if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n    return true;\n  }\n  addChunk(from, chunk) {\n    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n    if (this.from.length) this.finishChunk(true);\n    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n    this.chunks.push(chunk);\n    this.chunkPos.push(from);\n    let last = chunk.value.length - 1;\n    this.last = chunk.value[last];\n    this.lastFrom = chunk.from[last] + from;\n    this.lastTo = chunk.to[last] + from;\n    return true;\n  }\n  finish() {\n    return this.finishInner(RangeSet.empty);\n  }\n  finishInner(next) {\n    if (this.from.length) this.finishChunk(false);\n    if (this.chunks.length == 0) return next;\n    let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n    this.from = null;\n    return result;\n  }\n}\nfunction findSharedChunks(a, b) {\n  let inA = new Map();\n  for (let set of a) for (let i = 0; i < set.chunk.length; i++) if (set.chunk[i].maxPoint < 500) inA.set(set.chunk[i], set.chunkPos[i]);\n  let shared = new Set();\n  for (let set of b) for (let i = 0; i < set.chunk.length; i++) if (inA.get(set.chunk[i]) == set.chunkPos[i]) shared.add(set.chunk[i]);\n  return shared;\n}\nclass LayerCursor {\n  constructor(layer, skip, minPoint, rank = 0) {\n    this.layer = layer;\n    this.skip = skip;\n    this.minPoint = minPoint;\n    this.rank = rank;\n  }\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n  get endSide() {\n    return this.value ? this.value.endSide : 0;\n  }\n  goto(pos, side = -1000000000) {\n    this.chunkIndex = this.rangeIndex = 0;\n    this.gotoInner(pos, side, false);\n    return this;\n  }\n  gotoInner(pos, side, forward) {\n    while (this.chunkIndex < this.layer.chunk.length) {\n      let next = this.layer.chunk[this.chunkIndex];\n      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n      this.chunkIndex++;\n      forward = false;\n    }\n    let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0 : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n    if (!forward || this.rangeIndex < rangeIndex) this.rangeIndex = rangeIndex;\n    this.next();\n  }\n  forward(pos, side) {\n    if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n  }\n  next() {\n    for (; ; ) {\n      if (this.chunkIndex == this.layer.chunk.length) {\n        this.from = this.to = 1000000000;\n        this.value = null;\n        break;\n      } else {\n        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n        let from = chunkPos + chunk.from[this.rangeIndex];\n        this.from = from;\n        this.to = chunkPos + chunk.to[this.rangeIndex];\n        this.value = chunk.value[this.rangeIndex];\n        if (++this.rangeIndex == chunk.value.length) {\n          this.chunkIndex++;\n          if (this.skip) {\n            while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;\n          }\n          this.rangeIndex = 0;\n        }\n        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n      }\n    }\n  }\n  nextChunk() {\n    this.chunkIndex++;\n    this.rangeIndex = 0;\n    this.next();\n  }\n  compare(other) {\n    return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n  }\n}\nclass HeapCursor {\n  constructor(heap) {\n    this.heap = heap;\n  }\n  static from(sets, skip = null, minPoint = -1) {\n    let heap = [];\n    for (let i = 0; i < sets.length; i++) {\n      for (let cur = sets[i]; cur != RangeSet.empty; cur = cur.nextLayer) {\n        if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n      }\n    }\n    return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n  }\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n  goto(pos, side = -1000000000) {\n    for (let cur of this.heap) cur.goto(pos, side);\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n    this.next();\n    return this;\n  }\n  forward(pos, side) {\n    for (let cur of this.heap) cur.forward(pos, side);\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n    if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n  }\n  next() {\n    if (this.heap.length == 0) {\n      this.from = this.to = 1000000000;\n      this.value = null;\n      this.rank = -1;\n    } else {\n      let top = this.heap[0];\n      this.from = top.from;\n      this.to = top.to;\n      this.value = top.value;\n      this.rank = top.rank;\n      if (top.value) top.next();\n      heapBubble(this.heap, 0);\n    }\n  }\n}\nfunction heapBubble(heap, index) {\n  for (let cur = heap[index]; ; ) {\n    let childIndex = (index << 1) + 1;\n    if (childIndex >= heap.length) break;\n    let child = heap[childIndex];\n    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n      child = heap[childIndex + 1];\n      childIndex++;\n    }\n    if (cur.compare(child) < 0) break;\n    heap[childIndex] = cur;\n    heap[index] = child;\n    index = childIndex;\n  }\n}\nclass SpanCursor {\n  constructor(sets, skip, minPoint) {\n    this.minPoint = minPoint;\n    this.active = [];\n    this.activeTo = [];\n    this.activeRank = [];\n    this.minActive = -1;\n    this.point = null;\n    this.pointFrom = 0;\n    this.pointRank = 0;\n    this.to = -1000000000;\n    this.endSide = 0;\n    this.openStart = -1;\n    this.cursor = HeapCursor.from(sets, skip, minPoint);\n  }\n  goto(pos, side = -1000000000) {\n    this.cursor.goto(pos, side);\n    this.active.length = this.activeTo.length = this.activeRank.length = 0;\n    this.minActive = -1;\n    this.to = pos;\n    this.endSide = side;\n    this.openStart = -1;\n    this.next();\n    return this;\n  }\n  forward(pos, side) {\n    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);\n    this.cursor.forward(pos, side);\n  }\n  removeActive(index) {\n    remove(this.active, index);\n    remove(this.activeTo, index);\n    remove(this.activeRank, index);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  }\n  addActive(trackOpen) {\n    let i = 0, {value, to, rank} = this.cursor;\n    while (i < this.activeRank.length && this.activeRank[i] <= rank) i++;\n    insert(this.active, i, value);\n    insert(this.activeTo, i, to);\n    insert(this.activeRank, i, rank);\n    if (trackOpen) insert(trackOpen, i, this.cursor.from);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  }\n  next() {\n    let from = this.to;\n    this.point = null;\n    let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n    for (; ; ) {\n      let a = this.minActive;\n      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n        if (this.activeTo[a] > from) {\n          this.to = this.activeTo[a];\n          this.endSide = this.active[a].endSide;\n          break;\n        }\n        this.removeActive(a);\n        if (trackOpen) remove(trackOpen, a);\n      } else if (!this.cursor.value) {\n        this.to = this.endSide = 1000000000;\n        break;\n      } else if (this.cursor.from > from) {\n        this.to = this.cursor.from;\n        this.endSide = this.cursor.startSide;\n        break;\n      } else {\n        let nextVal = this.cursor.value;\n        if (!nextVal.point) {\n          this.addActive(trackOpen);\n          this.cursor.next();\n        } else {\n          this.point = nextVal;\n          this.pointFrom = this.cursor.from;\n          this.pointRank = this.cursor.rank;\n          this.to = this.cursor.to;\n          this.endSide = nextVal.endSide;\n          if (this.cursor.from < from) trackExtra = 1;\n          this.cursor.next();\n          if (this.to > from) this.forward(this.to, this.endSide);\n          break;\n        }\n      }\n    }\n    if (trackOpen) {\n      let openStart = 0;\n      while (openStart < trackOpen.length && trackOpen[openStart] < from) openStart++;\n      this.openStart = openStart + trackExtra;\n    }\n  }\n  activeForPoint(to) {\n    if (!this.active.length) return this.active;\n    let active = [];\n    for (let i = 0; i < this.active.length; i++) {\n      if (this.activeRank[i] > this.pointRank) break;\n      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide) active.push(this.active[i]);\n    }\n    return active;\n  }\n  openEnd(to) {\n    let open = 0;\n    while (open < this.activeTo.length && this.activeTo[open] > to) open++;\n    return open;\n  }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n  a.goto(startA);\n  b.goto(startB);\n  let endB = startB + length;\n  let pos = startB, dPos = startB - startA;\n  for (; ; ) {\n    let diff = a.to + dPos - b.to || a.endSide - b.endSide;\n    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n    if (a.point || b.point) {\n      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n    } else {\n      if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n    }\n    if (end > endB) break;\n    pos = end;\n    if (diff <= 0) a.next();\n    if (diff >= 0) b.next();\n  }\n}\nfunction sameValues(a, b) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n  return true;\n}\nfunction remove(array, index) {\n  for (let i = index, e = array.length - 1; i < e; i++) array[i] = array[i + 1];\n  array.pop();\n}\nfunction insert(array, index, value) {\n  for (let i = array.length - 1; i >= index; i--) array[i + 1] = array[i];\n  array[index] = value;\n}\nfunction findMinIndex(value, array) {\n  let found = -1, foundPos = 1000000000;\n  for (let i = 0; i < array.length; i++) if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n    found = i;\n    foundPos = array[i];\n  }\n  return found;\n}\nexports.Range = Range;\nexports.RangeSet = RangeSet;\nexports.RangeSetBuilder = RangeSetBuilder;\nexports.RangeValue = RangeValue;\n"}