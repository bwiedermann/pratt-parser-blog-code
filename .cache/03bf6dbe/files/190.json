{"contents":"var _1_;\nvar _2_;\nvar _3_;\nvar _4_;\nlet duChain = new Map();\nfunction darCheck(nodes, registeredNodes) {\n  const errors = nodes.map(n => darCheckNode(n, nodes, registeredNodes));\n  return [].concat(...errors);\n}\nexports.darCheck = darCheck;\nfunction darCheckNode(node, nodes, registeredNodes) {\n  return darCheckerMap[node.nodeType].darCheck(node, nodes, registeredNodes);\n}\nclass TypeError {\n  constructor(message, position) {\n    this.message = message;\n    this.position = position;\n  }\n}\nexports.TypeError = TypeError;\nclass DarCheckNumber {\n  darCheck(node) {\n    return [];\n  }\n}\nclass DarCheckFunction {\n  darCheck(node, nodes, registeredNodes) {\n    if (node.name == \"RandomChoice\") {\n      throw 'This is Random Choice';\n    } else if (node.name == \"Input\") {\n      console.log(node.outputType);\n      node.outputType = {\n        valueType = 'number',\n        status\n      };\n      node.outputType.isConstant = false;\n    }\n    return [];\n  }\n}\nclass DarCheckBinary {\n  isConstantOperation(topNode) {\n    if (topNode == undefined) {\n      return false;\n    }\n    if (topNode.nodeType == 'Number') {\n      return false;\n    } else if (topNode.nodeType == 'BinaryOperation') {\n      return this.isConstantOperation(topNode.left) && this.isConstantOperation(topNode.right);\n    } else if (topNode.nodeType == 'Function') {\n      return false;\n    } else {}\n  }\n  darCheck(node, nodes, registeredNodes) {\n    const errors = darCheckNode(node.left, nodes, registeredNodes).concat(darCheckNode(node.right, nodes, registeredNodes));\n    if (this.isConstantOperation(node)) {} else {}\n    return errors;\n  }\n}\nclass DarCheckVariable {\n  darCheck(node, nodes, registeredNodes) {\n    duChain.set(node.nodeId, []);\n    darCheckNode(node.assignment, nodes, registeredNodes);\n    return [];\n  }\n}\nclass DarCheckIdentifier {\n  getOutputType(node, registeredNodes) {\n    if (((_1_ = node) === null || _1_ === void 0 ? void 0 : _1_.outputType) != undefined && node.outputType.valueType != undefined) {\n      return node.outputType;\n    } else if (((_2_ = node) === null || _2_ === void 0 ? void 0 : _2_.nodeType) == \"Identifier\") {\n      return this.getOutputType(registeredNodes[node.assignmentId], registeredNodes);\n    } else if (((_3_ = node) === null || _3_ === void 0 ? void 0 : _3_.nodeType) == \"VariableAssignment\") {\n      return this.getOutputType(node.assignment, registeredNodes);\n    } else {\n      console.log(\"No output type for node \", (_4_ = node) === null || _4_ === void 0 ? void 0 : _4_.nodeType);\n      return undefined;\n    }\n  }\n  darCheck(node, nodes, registeredNodes) {\n    let oldChain = duChain.get(node.assignmentId);\n    if (oldChain == undefined) {\n      oldChain = [];\n    }\n    duChain.set(node.assignmentId, oldChain.concat([node.nodeId]));\n    console.log(\"Output Type:\", this.getOutputType(node, registeredNodes));\n    return [];\n  }\n}\nconst darCheckerMap = {\n  'Number': new DarCheckNumber(),\n  'BinaryOperation': new DarCheckBinary(),\n  'Function': new DarCheckFunction(),\n  'VariableAssignment': new DarCheckVariable(),\n  'Identifier': new DarCheckIdentifier()\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/darChecker.ts\"],\"names\":[\"duChain\",\"Map\",\"nodes\",\"registeredNodes\",\"errors\",\"map\",\"n\",\"darCheckNode\",\"concat\",\"node\",\"darCheckerMap\",\"nodeType\",\"darCheck\",\"constructor\",\"message\",\"position\",\"name\",\"console\",\"log\",\"outputType\",\"valueType\",\"status\",\"isConstant\",\"isConstantOperation\",\"topNode\",\"undefined\",\"left\",\"right\",\"set\",\"nodeId\",\"assignment\",\"getOutputType\",\"assignmentId\",\"oldChain\",\"get\",\"DarCheckNumber\",\"DarCheckBinary\",\"DarCheckFunction\",\"DarCheckVariable\",\"DarCheckIdentifier\"],\"mappings\":\";;;;IAOIA,cAAsCC;AAGnC,kBAAkBC,OAAoBC;QACnCC,SAASF,MAAMG,IAAI,AAAAC,KAAKC,aAAaD,GAAGJ,OAAOC;YAC1BK,UAAUJ;;;AAGzC,sBAAsBK,MAAgBP,OAAmBC;SAC9CO,cAAcD,KAAKE,UAAUC,SAASH,MAAMP,OAAOC;;AAGvD;EACHU,YAAmBC,SAAwBC;SAAxBD;SAAwBC;;;;AAU/C;EACIH,SAASH;;;;AAMX;EACIG,SAASH,MAAwBP,OAAmBC;QAG9CM,KAAKO,QAAQ;YACP;eAEDP,KAAKO,QAAQ;MAClBC,QAAQC,IAAIT,KAAKU;MAEjBV,KAAKU;QACDC,YAAY;QACZC;;MAEJZ,KAAKU,WAAWG,aAAa;;;;;AAOzC;EACIC,oBAAoBC;QACZA,WAAWC;aACJ;;QAGPD,QAAQb,YAAY;aACb;eAEFa,QAAQb,YAAY;aAClB,KAAKY,oBAAoBC,QAAQE,SAAS,KAAKH,oBAAoBC,QAAQG;eAE7EH,QAAQb,YAAY;aAElB;;;EAMfC,SAASH,MAA+BP,OAAmBC;UACjDC,SAAsBG,aAAaE,KAAKiB,MAAMxB,OAAOC,iBAAiBK,OAAOD,aAAaE,KAAKkB,OAAOzB,OAAOC;QAG/G,KAAKoB,oBAAoBd;WAMtBL;;;AAIf;EACIQ,SAASH,MAAkCP,OAAmBC;IAK1DH,QAAQ4B,IAAInB,KAAKoB;IAGjBtB,aAAaE,KAAKqB,YAAY5B,OAAOC;;;;AAO7C;EACI4B,cAActB,MAAgBN;gBAEtBM,gDAAMU,eAAcM,aAAahB,KAAKU,WAAWC,aAAaK;aACvDhB,KAAKU;uBACLV,gDAAME,aAAY;aAClB,KAAKoB,cAAc5B,gBAAgBM,KAAMuB,eAAe7B;uBACxDM,gDAAME,aAAY;aAElB,KAAKoB,cAActB,KAAKqB,YAAY3B;;MAG3Cc,QAAQC,IAAI,mCAA4BT,gDAAME;aACvCc;;;EAGfb,SAASH,MAA0BP,OAAmBC;QAG9C8B,WAAWjC,QAAQkC,IAAIzB,KAAKuB;QAC5BC,YAAYR;MACZQ;;IAEJjC,QAAQ4B,IAAInB,KAAKuB,cAAcC,SAASzB,QAAQC,KAAKoB;IAErDZ,QAAQC,IAAI,gBAAgB,KAAKa,cAActB,MAAMN;;;;MAQvDO;EACN,cAAeyB;EAEf,uBAAwBC;EACxB,gBAAiBC;EAEjB,0BAA0BC;EAC1B,kBAAkBC\",\"sourcesContent\":[\"import {Position} from './position';\\r\\nimport * as AST from './ast';\\r\\nimport {equals} from './equals';\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nlet duChain : Map<string, string[]> = new Map();\\r\\n\\r\\n\\r\\nexport function darCheck(nodes: AST.Node[],  registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n    const errors = nodes.map(n => darCheckNode(n, nodes, registeredNodes));\\r\\n    return ([] as TypeError[]).concat(...errors);\\r\\n}\\r\\n\\r\\nfunction darCheckNode(node: AST.Node, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n    return darCheckerMap[node.nodeType].darCheck(node, nodes, registeredNodes);\\r\\n}\\r\\n\\r\\nexport class TypeError {\\r\\n    constructor(public message: string, public position: Position) {}\\r\\n  }\\r\\n\\r\\nexport interface DarChecker {\\r\\n\\r\\n    darCheck(node: AST.Node,\\r\\n            nodes: AST.Node[], \\r\\n            registeredNodes: {[key: string]: AST.Node},): TypeError[];\\r\\n  }\\r\\n\\r\\nclass DarCheckNumber implements DarChecker {\\r\\n    darCheck(node: AST.NumberNode): TypeError[] {\\r\\n        return [];\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n  class DarCheckFunction implements DarChecker{\\r\\n      darCheck(node: AST.FunctionNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}) : TypeError[]{\\r\\n          \\r\\n        \\r\\n        if (node.name == \\\"RandomChoice\\\"){\\r\\n            throw('This is Random Choice')\\r\\n        } \\r\\n        else if (node.name == \\\"Input\\\"){\\r\\n            console.log(node.outputType);\\r\\n\\r\\n            node.outputType = {\\r\\n                valueType = 'number',\\r\\n                status\\r\\n            }\\r\\n            node.outputType.isConstant = false; //set isConstant to false, because inputs are not constant\\r\\n        }\\r\\n        \\r\\n        return []\\r\\n      }\\r\\n  }\\r\\n\\r\\nclass DarCheckBinary implements DarChecker {\\r\\n    isConstantOperation(topNode : AST.Node) : boolean {\\r\\n        if (topNode == undefined ){\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        if (topNode.nodeType == 'Number'){\\r\\n            return false;\\r\\n        }\\r\\n        else if (topNode.nodeType == 'BinaryOperation'){\\r\\n            return this.isConstantOperation(topNode.left) && this.isConstantOperation(topNode.right);\\r\\n        }\\r\\n        else if (topNode.nodeType == 'Function'){\\r\\n            //TODO: false always here is temp, function result not always non-constant\\r\\n            return false;\\r\\n        }\\r\\n        else {\\r\\n            //throw('Incompatable Node type');\\r\\n        }\\r\\n    }\\r\\n    darCheck(node: AST.BinaryOperationNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n        const errors: TypeError[] = darCheckNode(node.left, nodes, registeredNodes).concat(darCheckNode(node.right, nodes, registeredNodes));\\r\\n        \\r\\n\\r\\n        if (this.isConstantOperation(node)){\\r\\n        //errors.push(new TypeError(\\\"Is Constant Operation!\\\", node.pos));\\r\\n        } else {\\r\\n        //errors.push(new TypeError(\\\"Non constant operation\\\", node.pos));\\r\\n        }\\r\\n        \\r\\n        return errors;\\r\\n    }\\r\\n}\\r\\n\\r\\nclass DarCheckVariable implements DarChecker {\\r\\n    darCheck(node: AST.VariableAssignmentNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n\\r\\n\\r\\n\\r\\n        //new assignment, update def-use chain to hold new def\\r\\n        duChain.set(node.nodeId, []);\\r\\n\\r\\n        //make sure the identifier is resolved as a use\\r\\n        darCheckNode(node.assignment, nodes, registeredNodes);\\r\\n\\r\\n\\r\\n        return [];\\r\\n    }\\r\\n}\\r\\n\\r\\nclass DarCheckIdentifier implements DarChecker {\\r\\n    getOutputType(node: AST.Node, registeredNodes: {[key: string]: AST.Node}) : AST.Possible<AST.ValueType> | undefined{\\r\\n\\r\\n        if (node?.outputType != undefined && node.outputType.valueType != undefined){\\r\\n            return node.outputType;\\r\\n        } else if (node?.nodeType == \\\"Identifier\\\"){\\r\\n            return this.getOutputType(registeredNodes[node!.assignmentId], registeredNodes);\\r\\n        } else if (node?.nodeType == \\\"VariableAssignment\\\"){\\r\\n\\r\\n            return this.getOutputType(node.assignment, registeredNodes);\\r\\n        }\\r\\n        else {\\r\\n            console.log(\\\"No output type for node \\\", node?.nodeType);\\r\\n            return undefined;\\r\\n        }\\r\\n    }\\r\\n    darCheck(node: AST.IdentifierNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n\\r\\n        //new use, update def-use chain to hold new use\\r\\n        let oldChain = duChain.get(node.assignmentId); //assignmentId corresponds to the node id of the identifiers VariableAssignment\\r\\n        if (oldChain == undefined){\\r\\n            oldChain = [];\\r\\n        }\\r\\n        duChain.set(node.assignmentId, oldChain.concat([node.nodeId]) );\\r\\n        \\r\\n        console.log(\\\"Output Type:\\\", this.getOutputType(node, registeredNodes));\\r\\n\\r\\n        return [];\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n\\r\\nconst darCheckerMap: Partial<{[K in AST.NodeType]: DarChecker}> = {\\r\\n'Number' : new DarCheckNumber(),\\r\\n//'Boolean' : new CheckBoolean(),\\r\\n'BinaryOperation' : new DarCheckBinary(),\\r\\n'Function' : new DarCheckFunction(),\\r\\n//'Choose': new CheckChoose(),\\r\\n'VariableAssignment': new DarCheckVariable(),\\r\\n'Identifier': new DarCheckIdentifier()\\r\\n}\"]}"}