{"contents":"exports.__esModule = true;\nvar state_1 = __fusereq(14);\nconst toggleComment = target => {\n  let config = getConfig(target.state);\n  return config.line ? toggleLineComment(target) : config.block ? toggleBlockComment(target) : false;\n};\nfunction command(f, option) {\n  return ({state, dispatch}) => {\n    let tr = f(option, state.selection.ranges, state);\n    if (!tr) return false;\n    dispatch(state.update(tr));\n    return true;\n  };\n}\nconst toggleLineComment = command(changeLineComment, 0);\nconst lineComment = command(changeLineComment, 1);\nconst lineUncomment = command(changeLineComment, 2);\nconst toggleBlockComment = command(changeBlockComment, 0);\nconst blockComment = command(changeBlockComment, 1);\nconst blockUncomment = command(changeBlockComment, 2);\nconst commentKeymap = [{\n  key: \"Mod-/\",\n  run: toggleComment\n}, {\n  key: \"Alt-A\",\n  run: toggleBlockComment\n}];\nfunction getConfig(state, pos = state.selection.main.head) {\n  let data = state.languageDataAt(\"commentTokens\", pos);\n  return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\nfunction findBlockComment(state, {open, close}, from, to) {\n  let textBefore = state.sliceDoc(from - SearchMargin, from);\n  let textAfter = state.sliceDoc(to, to + SearchMargin);\n  let spaceBefore = (/\\s*$/).exec(textBefore)[0].length, spaceAfter = (/^\\s*/).exec(textAfter)[0].length;\n  let beforeOff = textBefore.length - spaceBefore;\n  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n    return {\n      open: {\n        pos: from - spaceBefore,\n        margin: spaceBefore && 1\n      },\n      close: {\n        pos: to + spaceAfter,\n        margin: spaceAfter && 1\n      }\n    };\n  }\n  let startText, endText;\n  if (to - from <= 2 * SearchMargin) {\n    startText = endText = state.sliceDoc(from, to);\n  } else {\n    startText = state.sliceDoc(from, from + SearchMargin);\n    endText = state.sliceDoc(to - SearchMargin, to);\n  }\n  let startSpace = (/^\\s*/).exec(startText)[0].length, endSpace = (/\\s*$/).exec(endText)[0].length;\n  let endOff = endText.length - endSpace - close.length;\n  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n    return {\n      open: {\n        pos: from + startSpace + open.length,\n        margin: (/\\s/).test(startText.charAt(startSpace + open.length)) ? 1 : 0\n      },\n      close: {\n        pos: to - endSpace - close.length,\n        margin: (/\\s/).test(endText.charAt(endOff - 1)) ? 1 : 0\n      }\n    };\n  }\n  return null;\n}\nfunction changeBlockComment(option, ranges, state) {\n  let tokens = ranges.map(r => getConfig(state, r.from).block);\n  if (!tokens.every(c => c)) return null;\n  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n  if (option != 2 && !comments.every(c => c)) {\n    let index = 0;\n    return state.changeByRange(range => {\n      let {open, close} = tokens[index++];\n      if (comments[index]) return {\n        range\n      };\n      let shift = open.length + 1;\n      return {\n        changes: [{\n          from: range.from,\n          insert: open + \" \"\n        }, {\n          from: range.to,\n          insert: \" \" + close\n        }],\n        range: state_1.EditorSelection.range(range.anchor + shift, range.head + shift)\n      };\n    });\n  } else if (option != 1 && comments.some(c => c)) {\n    let changes = [];\n    for (let i = 0, comment; i < comments.length; i++) if (comment = comments[i]) {\n      let token = tokens[i], {open, close} = comment;\n      changes.push({\n        from: open.pos - token.open.length,\n        to: open.pos + open.margin\n      }, {\n        from: close.pos - close.margin,\n        to: close.pos + token.close.length\n      });\n    }\n    return {\n      changes\n    };\n  }\n  return null;\n}\nfunction changeLineComment(option, ranges, state) {\n  let lines = [];\n  let prevLine = -1;\n  for (let {from, to} of ranges) {\n    let startI = lines.length, minIndent = 1e9;\n    for (let pos = from; pos <= to; ) {\n      let line = state.doc.lineAt(pos);\n      if (line.from > prevLine && (from == to || to > line.from)) {\n        prevLine = line.from;\n        let token = getConfig(state, pos).line;\n        if (!token) continue;\n        let indent = (/^\\s*/).exec(line.text)[0].length;\n        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n        if (indent < line.text.length && indent < minIndent) minIndent = indent;\n        lines.push({\n          line,\n          comment,\n          token,\n          indent,\n          single: false\n        });\n      }\n      pos = line.to + 1;\n    }\n    if (minIndent < 1e9) for (let i = startI; i < lines.length; i++) if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n    if (lines.length == startI + 1) lines[startI].single = true;\n  }\n  if (option != 1 && lines.some(l => l.comment >= 0)) {\n    let changes = [];\n    for (let {line, comment, token} of lines) if (comment >= 0) {\n      let from = line.from + comment, to = from + token.length;\n      if (line.text[to - line.from] == \" \") to++;\n      changes.push({\n        from,\n        to\n      });\n    }\n    return {\n      changes\n    };\n  } else if (option != 2 && lines.some(l => l.comment < 0)) {\n    let changes = [];\n    for (let {line, comment, token, indent, single} of lines) if (comment != indent && (single || (/\\S/).test(line.text))) changes.push({\n      from: line.from + indent,\n      insert: token + \" \"\n    });\n    let changeSet = state.changes(changes);\n    return {\n      changes: changeSet,\n      selection: state.selection.map(changeSet, 1)\n    };\n  }\n  return null;\n}\nexports.blockComment = blockComment;\nexports.blockUncomment = blockUncomment;\nexports.commentKeymap = commentKeymap;\nexports.lineComment = lineComment;\nexports.lineUncomment = lineUncomment;\nexports.toggleBlockComment = toggleBlockComment;\nexports.toggleComment = toggleComment;\nexports.toggleLineComment = toggleLineComment;\n"}