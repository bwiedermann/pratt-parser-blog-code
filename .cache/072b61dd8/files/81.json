{"contents":"exports.__esModule = true;\nvar d3_path_1 = __fusereq(178);\nvar constant_js_1 = __fusereq(180);\nvar constant_js_1d = __fuse.dt(constant_js_1);\nvar math_js_1 = __fusereq(182);\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\nfunction arcPadAngle(d) {\n  return d && d.padAngle;\n}\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;\n  if (t * t < math_js_1.epsilon) return;\n  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;\n  return [x0 + t * x10, y0 + t * y10];\n}\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / math_js_1.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * math_js_1.sqrt(math_js_1.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) (cx0 = cx1, cy0 = cy1);\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\nfunction __DefaultExport__() {\n  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_js_1d.default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;\n  function arc() {\n    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - math_js_1.halfPi, a1 = endAngle.apply(this, arguments) - math_js_1.halfPi, da = math_js_1.abs(a1 - a0), cw = a1 > a0;\n    if (!context) context = buffer = d3_path_1.path();\n    if (r1 < r0) (r = r1, r1 = r0, r0 = r);\n    if (!(r1 > math_js_1.epsilon)) context.moveTo(0, 0); else if (da > math_js_1.tau - math_js_1.epsilon) {\n      context.moveTo(r1 * math_js_1.cos(a0), r1 * math_js_1.sin(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > math_js_1.epsilon) {\n        context.moveTo(r0 * math_js_1.cos(a1), r0 * math_js_1.sin(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    } else {\n      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > math_js_1.epsilon && (padRadius ? +padRadius.apply(this, arguments) : math_js_1.sqrt(r0 * r0 + r1 * r1)), rc = math_js_1.min(math_js_1.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;\n      if (rp > math_js_1.epsilon) {\n        var p0 = math_js_1.asin(rp / r0 * math_js_1.sin(ap)), p1 = math_js_1.asin(rp / r1 * math_js_1.sin(ap));\n        if ((da0 -= p0 * 2) > math_js_1.epsilon) (p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0); else (da0 = 0, a00 = a10 = (a0 + a1) / 2);\n        if ((da1 -= p1 * 2) > math_js_1.epsilon) (p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1); else (da1 = 0, a01 = a11 = (a0 + a1) / 2);\n      }\n      var x01 = r1 * math_js_1.cos(a01), y01 = r1 * math_js_1.sin(a01), x10 = r0 * math_js_1.cos(a10), y10 = r0 * math_js_1.sin(a10);\n      if (rc > math_js_1.epsilon) {\n        var x11 = r1 * math_js_1.cos(a11), y11 = r1 * math_js_1.sin(a11), x00 = r0 * math_js_1.cos(a00), y00 = r0 * math_js_1.sin(a00), oc;\n        if (da < math_js_1.pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {\n          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / math_js_1.sin(math_js_1.acos((ax * bx + ay * by) / (math_js_1.sqrt(ax * ax + ay * ay) * math_js_1.sqrt(bx * bx + by * by))) / 2), lc = math_js_1.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = math_js_1.min(rc, (r0 - lc) / (kc - 1));\n          rc1 = math_js_1.min(rc, (r1 - lc) / (kc + 1));\n        }\n      }\n      if (!(da1 > math_js_1.epsilon)) context.moveTo(x01, y01); else if (rc1 > math_js_1.epsilon) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, math_js_1.atan2(t0.y01, t0.x01), math_js_1.atan2(t1.y01, t1.x01), !cw); else {\n          context.arc(t0.cx, t0.cy, rc1, math_js_1.atan2(t0.y01, t0.x01), math_js_1.atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, math_js_1.atan2(t0.cy + t0.y11, t0.cx + t0.x11), math_js_1.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, math_js_1.atan2(t1.y11, t1.x11), math_js_1.atan2(t1.y01, t1.x01), !cw);\n        }\n      } else (context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw));\n      if (!(r0 > math_js_1.epsilon) || !(da0 > math_js_1.epsilon)) context.lineTo(x10, y10); else if (rc0 > math_js_1.epsilon) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, math_js_1.atan2(t0.y01, t0.x01), math_js_1.atan2(t1.y01, t1.x01), !cw); else {\n          context.arc(t0.cx, t0.cy, rc0, math_js_1.atan2(t0.y01, t0.x01), math_js_1.atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, math_js_1.atan2(t0.cy + t0.y11, t0.cx + t0.x11), math_js_1.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, math_js_1.atan2(t1.y11, t1.x11), math_js_1.atan2(t1.y01, t1.x01), !cw);\n        }\n      } else context.arc(0, 0, r0, a10, a00, cw);\n    }\n    context.closePath();\n    if (buffer) return (context = null, buffer + \"\" || null);\n  }\n  arc.centroid = function () {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - math_js_1.pi / 2;\n    return [math_js_1.cos(a) * r, math_js_1.sin(a) * r];\n  };\n  arc.innerRadius = function (_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant_js_1d.default(+_), arc) : innerRadius;\n  };\n  arc.outerRadius = function (_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant_js_1d.default(+_), arc) : outerRadius;\n  };\n  arc.cornerRadius = function (_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant_js_1d.default(+_), arc) : cornerRadius;\n  };\n  arc.padRadius = function (_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant_js_1d.default(+_), arc) : padRadius;\n  };\n  arc.startAngle = function (_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant_js_1d.default(+_), arc) : startAngle;\n  };\n  arc.endAngle = function (_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant_js_1d.default(+_), arc) : endAngle;\n  };\n  arc.padAngle = function (_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant_js_1d.default(+_), arc) : padAngle;\n  };\n  arc.context = function (_) {\n    return arguments.length ? (context = _ == null ? null : _, arc) : context;\n  };\n  return arc;\n}\nexports.default = __DefaultExport__;\n"}