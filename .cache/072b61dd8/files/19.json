{"contents":"exports.__esModule = true;\nvar stream_parser_1 = __fusereq(7);\nfunction getTokens(text) {\n  const tokens = [];\n  const state = {\n    line: 1,\n    stack: ['default']\n  };\n  for (const line of text.split('\\n')) {\n    const stream = new stream_parser_1.StringStream();\n    stream.string = line;\n    while (!stream.eol()) {\n      const token = getToken(stream, state);\n      const emitToken = makeEmit(stream, state);\n      const fullToken = emitToken(token);\n      if (token != undefined) {\n        tokens.push(fullToken);\n      }\n      if (stream.start == stream.pos) {\n        throw new Error(`getToken failed to advance stream at position ${stream.pos} in string ${stream.string}`);\n      }\n      stream.start = stream.pos;\n    }\n    state.line += 1;\n  }\n  return tokens;\n}\nexports.getTokens = getTokens;\nfunction getToken(stream, state) {\n  switch (state.stack[state.stack.length - 1]) {\n    default:\n      return getDefaultToken(stream, state);\n  }\n}\nexports.getToken = getToken;\nfunction makeEmit(stream, state) {\n  return function emitToken(type) {\n    return {\n      type,\n      first_column: stream.start,\n      last_column: stream.pos,\n      line: state.line,\n      text: stream.current()\n    };\n  };\n}\nfunction getDefaultToken(stream, state) {\n  if (stream.eatSpace()) {\n    return undefined;\n  }\n  if (stream.match(/\\+/)) {\n    return '+';\n  }\n  if (stream.match(/\\-/)) {\n    return '-';\n  }\n  if (stream.match(/\\*/)) {\n    return '*';\n  }\n  if (stream.match(/\\//)) {\n    return '/';\n  }\n  if (stream.match(/\\|/)) {\n    return '|';\n  }\n  if (stream.match(/\\&/)) {\n    return '&';\n  }\n  if (stream.match(/\\(/)) {\n    return '(';\n  }\n  if (stream.match(/\\)/)) {\n    return ')';\n  }\n  if (stream.match(/\\[/)) {\n    return '[';\n  }\n  if (stream.match(/\\]/)) {\n    return ']';\n  }\n  if (stream.match(/\\=/)) {\n    return '=';\n  }\n  if (stream.match(/-?[0-9]+(\\.[0-9]+)?/)) {\n    return 'NUMBER';\n  }\n  if (stream.match(/True/)) {\n    return 'TRUE';\n  }\n  if (stream.match(/False/)) {\n    return 'FALSE';\n  }\n  if (stream.match(/#/)) {\n    if (!stream.match(/\\n/)) {\n      stream.match(/.*/);\n    }\n    return 'COMMENT';\n  }\n  if (stream.match(/WHEN/)) {\n    return 'CHOOSE1';\n  }\n  if (stream.match(/OTHERWISE/)) {\n    return 'CHOOSE2';\n  }\n  if (stream.match(/[A-Z]([a-z|A-Z])*/)) {\n    return 'FUNCTION';\n  }\n  if (stream.match(/[a-z]([a-z|A-Z])*/)) {\n    return 'IDENTIFIER';\n  }\n  stream.next();\n  return 'ERROR';\n}\nexports.getDefaultToken = getDefaultToken;\n","sourceMap":"{\"version\":3,\"sources\":[\"src/lexer.ts\"],\"names\":[\"text\",\"tokens\",\"state\",\"line\",\"stack\",\"split\",\"stream\",\"stream_parser_1\",\"string\",\"eol\",\"token\",\"getToken\",\"emitToken\",\"makeEmit\",\"fullToken\",\"undefined\",\"push\",\"start\",\"pos\",\"Error\",\"length\",\"getDefaultToken\",\"type\",\"first_column\",\"last_column\",\"current\",\"eatSpace\",\"match\",\"next\"],\"mappings\":\";;AAEO,mBAAmBA;QAClBC;QACAC;IAAgBC,MAAM;IAAGC,QAAQ;;aAE5BD,QAAQH,KAAKK,MAAM;UACtBC,aAAaC;IACnBD,OAAOE,SAASL;YACRG,OAAOG;YACPC,QAAQC,SAASL,QAAQJ;YACzBU,YAAYC,SAASP,QAAQJ;YAC7BY,YAAYF,UAAUF;UACxBA,SAASK;QACXd,OAAOe,KAAKF;;UAGVR,OAAOW,SAASX,OAAOY;kBACfC,uDAENb,OAAOY,iBACKZ,OAAOE;;MAGzBF,OAAOW,QAAQX,OAAOY;;IAGxBhB,MAAMC,QAAQ;;SAGTF;;;AAGF,kBACLK,QACAJ;UAIQA,MAAME,MAAMF,MAAME,MAAMgB,SAAS;;aAE9BC,gBAAgBf,QAAQJ;;;;AAIrC,kBAAkBI,QAAsBJ;SAC/B,mBAAmBoB;;MAEtBA;MACAC,cAAcjB,OAAOW;MACrBO,aAAalB,OAAOY;MACpBf,MAAMD,MAAMC;MACZH,MAAMM,OAAOmB;;;;AAKZ,yBACLnB,QACAJ;MAGII,OAAOoB;WAEFX;;MAGLT,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAILrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;SACVrB,OAAOqB,MAAM;MAEhBrB,OAAOqB,MAAM;;WAER;;MAILrB,OAAOqB,MAAM;WACR;;MAILrB,OAAOqB,MAAM;WACR;;MAGLrB,OAAOqB,MAAM;WACR;;MAMLrB,OAAOqB,MAAM;WACR;;EAITrB,OAAOsB;SACA\",\"sourcesContent\":[\"import {StringStream} from \\\"@codemirror/stream-parser\\\"\\r\\n\\r\\nexport function getTokens(text: string): Token[] {\\r\\n  const tokens: Token[] = [];\\r\\n  const state: State = {line: 1, stack: ['default']};\\r\\n\\r\\n  for (const line of text.split('\\\\n')) {\\r\\n    const stream = new StringStream();\\r\\n    stream.string = line;\\r\\n    while (!stream.eol()) {\\r\\n      const token = getToken(stream, state);\\r\\n      const emitToken = makeEmit(stream, state);\\r\\n      const fullToken = emitToken(token as TokenType);\\r\\n      if (token != undefined) {\\r\\n        tokens.push(fullToken);\\r\\n      }\\r\\n\\r\\n      if (stream.start == stream.pos) {\\r\\n        throw new Error(\\r\\n          `getToken failed to advance stream at position ${\\r\\n            stream.pos\\r\\n          } in string ${stream.string}`,\\r\\n        );\\r\\n      }\\r\\n      stream.start = stream.pos;\\r\\n    }\\r\\n\\r\\n    state.line += 1;\\r\\n  }\\r\\n\\r\\n  return tokens;\\r\\n}\\r\\n\\r\\nexport function getToken(\\r\\n  stream: StringStream,\\r\\n  state: State,\\r\\n): string | undefined {\\r\\n  //Built for codeMirror streams API\\r\\n  //State is a stack of states\\r\\n  switch (state.stack[state.stack.length - 1]) {\\r\\n    default:\\r\\n      return getDefaultToken(stream, state);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction makeEmit(stream: StringStream, state: State) {\\r\\n  return function emitToken(type: TokenType): Token {\\r\\n    return {\\r\\n      type,\\r\\n      first_column: stream.start,\\r\\n      last_column: stream.pos,\\r\\n      line: state.line,\\r\\n      text: stream.current(),\\r\\n    };\\r\\n  };\\r\\n}\\r\\n\\r\\nexport function getDefaultToken(\\r\\n  stream: StringStream,\\r\\n  state: State,\\r\\n): string | undefined {\\r\\n  // const emitToken = makeEmit(stream, state);\\r\\n  if (stream.eatSpace()) {\\r\\n    // skip whitespace\\r\\n    return undefined;\\r\\n  }\\r\\n\\r\\n  if (stream.match(/\\\\+/)) {\\r\\n    return '+';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/\\\\-/)) {\\r\\n    return '-';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/\\\\*/)) {\\r\\n    return '*';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/\\\\//)) {\\r\\n    return '/';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/\\\\|/)) {\\r\\n    return '|';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/\\\\&/)) {\\r\\n    return '&';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/\\\\(/)) {\\r\\n    return '(';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/\\\\)/)) {\\r\\n    return ')';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/\\\\[/)) {\\r\\n    return '[';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/\\\\]/)) {\\r\\n    return ']';\\r\\n  }\\r\\n\\r\\n  // adding an equals operator\\r\\n  if (stream.match(/\\\\=/)) {\\r\\n    return '=';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/-?[0-9]+(\\\\.[0-9]+)?/)) {\\r\\n    return 'NUMBER';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/True/)) {\\r\\n    return 'TRUE';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/False/)) {\\r\\n    return 'FALSE';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/#/)) {\\r\\n    if (!stream.match(/\\\\n/)) {\\r\\n      // comment lasts till end of line\\r\\n      stream.match(/.*/); // if no eol encountered, comment lasts till end of file\\r\\n    }\\r\\n    return 'COMMENT';\\r\\n  }\\r\\n\\r\\n  // hardcode when to be a choose node not an identifier to get around parsing\\r\\n  if (stream.match(/WHEN/)) {\\r\\n    return 'CHOOSE1';\\r\\n  }\\r\\n\\r\\n  // Remove otherwise clause for now\\r\\n  if (stream.match(/OTHERWISE/)) {\\r\\n    return 'CHOOSE2';\\r\\n  }\\r\\n\\r\\n  if (stream.match(/[A-Z]([a-z|A-Z])*/)) {\\r\\n    return 'FUNCTION';\\r\\n  }\\r\\n\\r\\n  // Identifiers\\r\\n  // For now, the form of a valid identifier is: a lower-case alphabetic character,\\r\\n  // followed by zero or more alpha characters.\\r\\n  if (stream.match(/[a-z]([a-z|A-Z])*/)) {\\r\\n    return 'IDENTIFIER';\\r\\n  }\\r\\n  \\r\\n\\r\\n  stream.next();\\r\\n  return 'ERROR';\\r\\n}\\r\\n\\r\\nexport type BinaryOperationTokenType =\\r\\n  | '+'\\r\\n  | '-'\\r\\n  | '*'\\r\\n  | '/'\\r\\n  | '|' // this is an or\\r\\n  | '&' // this is an and\\r\\n\\r\\nexport type TokenType =\\r\\n  | BinaryOperationTokenType\\r\\n  | 'NUM'\\r\\n  | 'TRUE'\\r\\n  | 'FALSE'\\r\\n  | '('\\r\\n  | ')'\\r\\n  | 'COMMENT'\\r\\n  | 'ERROR'\\r\\n  | 'FUNCTION'\\r\\n  | 'IDENTIFIER'\\r\\n  | 'CHOOSE1'\\r\\n  | 'CHOOSE2'\\r\\n  | '='\\r\\n  | 'RANGE'\\r\\n  | '['\\r\\n  | ']'\\r\\n\\r\\nexport interface Token<T extends TokenType = TokenType> {\\r\\n  type: T;\\r\\n  text: string;\\r\\n  line: number;\\r\\n  first_column: number;\\r\\n  last_column: number;\\r\\n}\\r\\n\\r\\ntype Mode = 'default';\\r\\n\\r\\nexport interface State {\\r\\n  stack: Mode[];\\r\\n  line: number;\\r\\n}\\r\\n\"]}"}