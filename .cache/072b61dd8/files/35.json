{"contents":"exports.__esModule = true;\nvar view_1 = __fusereq(14);\nvar state_1 = __fusereq(15);\nvar panel_1 = __fusereq(17);\nvar rangeset_1 = __fusereq(42);\nvar crelt_1 = __fusereq(18);\nvar crelt_1d = __fuse.dt(crelt_1);\nvar text_1 = __fusereq(26);\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? x => x.normalize(\"NFKD\") : x => x;\nclass SearchCursor {\n  constructor(text, query, from = 0, to = text.length, normalize) {\n    this.value = {\n      from: 0,\n      to: 0\n    };\n    this.done = false;\n    this.matches = [];\n    this.buffer = \"\";\n    this.bufferPos = 0;\n    this.iter = text.iterRange(from, to);\n    this.bufferStart = from;\n    this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n    this.query = this.normalize(query);\n  }\n  peek() {\n    if (this.bufferPos == this.buffer.length) {\n      this.bufferStart += this.buffer.length;\n      this.iter.next();\n      if (this.iter.done) return -1;\n      this.bufferPos = 0;\n      this.buffer = this.iter.value;\n    }\n    return this.buffer.charCodeAt(this.bufferPos);\n  }\n  next() {\n    for (; ; ) {\n      let next = this.peek();\n      if (next < 0) {\n        this.done = true;\n        return this;\n      }\n      let str = String.fromCharCode(next), start = this.bufferStart + this.bufferPos;\n      this.bufferPos++;\n      for (; ; ) {\n        let peek = this.peek();\n        if (peek < 0xDC00 || peek >= 0xE000) break;\n        this.bufferPos++;\n        str += String.fromCharCode(peek);\n      }\n      let norm = this.normalize(str);\n      for (let i = 0, pos = start; ; i++) {\n        let code = norm.charCodeAt(i);\n        let match = this.match(code, pos);\n        if (match) {\n          this.value = match;\n          return this;\n        }\n        if (i == norm.length - 1) break;\n        if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n      }\n    }\n  }\n  match(code, pos) {\n    let match = null;\n    for (let i = 0; i < this.matches.length; i += 2) {\n      let index = this.matches[i], keep = false;\n      if (this.query.charCodeAt(index) == code) {\n        if (index == this.query.length - 1) {\n          match = {\n            from: this.matches[i + 1],\n            to: pos + 1\n          };\n        } else {\n          this.matches[i]++;\n          keep = true;\n        }\n      }\n      if (!keep) {\n        this.matches.splice(i, 2);\n        i -= 2;\n      }\n    }\n    if (this.query.charCodeAt(0) == code) {\n      if (this.query.length == 1) match = {\n        from: pos,\n        to: pos + 1\n      }; else this.matches.push(1, pos);\n    }\n    return match;\n  }\n}\nfunction createLineDialog(view) {\n  let input = crelt_1d.default(\"input\", {\n    class: \"cm-textfield\",\n    name: \"line\"\n  });\n  let dom = crelt_1d.default(\"form\", {\n    class: \"cm-gotoLine\",\n    onkeydown: event => {\n      if (event.keyCode == 27) {\n        event.preventDefault();\n        view.dispatch({\n          effects: dialogEffect.of(false)\n        });\n        view.focus();\n      } else if (event.keyCode == 13) {\n        event.preventDefault();\n        go();\n      }\n    },\n    onsubmit: event => {\n      event.preventDefault();\n      go();\n    }\n  }, crelt_1d.default(\"label\", view.state.phrase(\"Go to line:\"), \" \", input), \" \", crelt_1d.default(\"button\", {\n    class: \"cm-button\",\n    type: \"submit\"\n  }, view.state.phrase(\"go\")));\n  function go() {\n    let match = (/^([+-])?(\\d+)?(:\\d+)?(%)?$/).exec(input.value);\n    if (!match) return;\n    let {state} = view, startLine = state.doc.lineAt(state.selection.main.head);\n    let [, sign, ln, cl, percent] = match;\n    let col = cl ? +cl.slice(1) : 0;\n    let line = ln ? +ln : startLine.number;\n    if (ln && percent) {\n      let pc = line / 100;\n      if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n      line = Math.round(state.doc.lines * pc);\n    } else if (ln && sign) {\n      line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n    }\n    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n    view.dispatch({\n      effects: dialogEffect.of(false),\n      selection: state_1.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n      scrollIntoView: true\n    });\n    view.focus();\n  }\n  return {\n    dom,\n    pos: -10\n  };\n}\nconst dialogEffect = state_1.StateEffect.define();\nconst dialogField = state_1.StateField.define({\n  create() {\n    return true;\n  },\n  update(value, tr) {\n    for (let e of tr.effects) if (e.is(dialogEffect)) value = e.value;\n    return value;\n  },\n  provide: f => panel_1.showPanel.from(f, val => val ? createLineDialog : null)\n});\nconst gotoLine = view => {\n  let panel = panel_1.getPanel(view, createLineDialog);\n  if (!panel) {\n    let effects = [dialogEffect.of(true)];\n    if (view.state.field(dialogField, false) == null) effects.push(state_1.StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n    view.dispatch({\n      effects\n    });\n    panel = panel_1.getPanel(view, createLineDialog);\n  }\n  if (panel) panel.dom.querySelector(\"input\").focus();\n  return true;\n};\nconst baseTheme$1 = view_1.EditorView.baseTheme({\n  \".cm-panel.cm-gotoLine\": {\n    padding: \"2px 6px 4px\",\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  }\n});\nconst defaultHighlightOptions = {\n  highlightWordAroundCursor: false,\n  minSelectionLength: 1,\n  maxMatches: 100\n};\nconst highlightConfig = state_1.Facet.define({\n  combine(options) {\n    return state_1.combineConfig(options, defaultHighlightOptions, {\n      highlightWordAroundCursor: (a, b) => a || b,\n      minSelectionLength: Math.min,\n      maxMatches: Math.min\n    });\n  }\n});\nfunction highlightSelectionMatches(options) {\n  let ext = [defaultTheme, matchHighlighter];\n  if (options) ext.push(highlightConfig.of(options));\n  return ext;\n}\nfunction wordAt(doc, pos, check) {\n  let line = doc.lineAt(pos);\n  let from = pos - line.from, to = pos - line.from;\n  while (from > 0) {\n    let prev = text_1.findClusterBreak(line.text, from, false);\n    if (check(line.text.slice(prev, from)) != state_1.CharCategory.Word) break;\n    from = prev;\n  }\n  while (to < line.length) {\n    let next = text_1.findClusterBreak(line.text, to);\n    if (check(line.text.slice(to, next)) != state_1.CharCategory.Word) break;\n    to = next;\n  }\n  return from == to ? null : line.text.slice(from, to);\n}\nconst matchDeco = view_1.Decoration.mark({\n  class: \"cm-selectionMatch\"\n});\nconst mainMatchDeco = view_1.Decoration.mark({\n  class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\nconst matchHighlighter = view_1.ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.decorations = this.getDeco(view);\n  }\n  update(update) {\n    if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);\n  }\n  getDeco(view) {\n    let conf = view.state.facet(highlightConfig);\n    let {state} = view, sel = state.selection;\n    if (sel.ranges.length > 1) return view_1.Decoration.none;\n    let range = sel.main, query, check = null;\n    if (range.empty) {\n      if (!conf.highlightWordAroundCursor) return view_1.Decoration.none;\n      check = state.charCategorizer(range.head);\n      query = wordAt(state.doc, range.head, check);\n      if (!query) return view_1.Decoration.none;\n    } else {\n      let len = range.to - range.from;\n      if (len < conf.minSelectionLength || len > 200) return view_1.Decoration.none;\n      query = state.sliceDoc(range.from, range.to).trim();\n      if (!query) return view_1.Decoration.none;\n    }\n    let deco = [];\n    for (let part of view.visibleRanges) {\n      let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n      while (!cursor.next().done) {\n        let {from, to} = cursor.value;\n        if (!check || (from == 0 || check(state.sliceDoc(from - 1, from)) != state_1.CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != state_1.CharCategory.Word)) {\n          if (check && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to)); else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n          if (deco.length > conf.maxMatches) return view_1.Decoration.none;\n        }\n      }\n    }\n    return view_1.Decoration.set(deco);\n  }\n}, {\n  decorations: v => v.decorations\n});\nconst defaultTheme = view_1.EditorView.baseTheme({\n  \".cm-selectionMatch\": {\n    backgroundColor: \"#99ff7780\"\n  },\n  \".cm-searchMatch .cm-selectionMatch\": {\n    backgroundColor: \"transparent\"\n  }\n});\nclass Query {\n  constructor(search, replace, caseInsensitive) {\n    this.search = search;\n    this.replace = replace;\n    this.caseInsensitive = caseInsensitive;\n  }\n  eq(other) {\n    return this.search == other.search && this.replace == other.replace && this.caseInsensitive == other.caseInsensitive;\n  }\n  cursor(doc, from = 0, to = doc.length) {\n    return new SearchCursor(doc, this.search, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);\n  }\n  get valid() {\n    return !!this.search;\n  }\n}\nconst setQuery = state_1.StateEffect.define();\nconst togglePanel = state_1.StateEffect.define();\nconst searchState = state_1.StateField.define({\n  create() {\n    return new SearchState(new Query(\"\", \"\", false), null);\n  },\n  update(value, tr) {\n    for (let effect of tr.effects) {\n      if (effect.is(setQuery)) value = new SearchState(effect.value, value.panel); else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n    }\n    return value;\n  },\n  provide: f => panel_1.showPanel.from(f, val => val.panel)\n});\nclass SearchState {\n  constructor(query, panel) {\n    this.query = query;\n    this.panel = panel;\n  }\n}\nconst matchMark = view_1.Decoration.mark({\n  class: \"cm-searchMatch\"\n}), selectedMatchMark = view_1.Decoration.mark({\n  class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nconst searchHighlighter = view_1.ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.decorations = this.highlight(view.state.field(searchState));\n  }\n  update(update) {\n    let state = update.state.field(searchState);\n    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet) this.decorations = this.highlight(state);\n  }\n  highlight({query, panel}) {\n    if (!panel || !query.valid) return view_1.Decoration.none;\n    let state = this.view.state, viewport = this.view.viewport;\n    let cursor = query.cursor(state.doc, Math.max(0, viewport.from - query.search.length), Math.min(viewport.to + query.search.length, state.doc.length));\n    let builder = new rangeset_1.RangeSetBuilder();\n    while (!cursor.next().done) {\n      let {from, to} = cursor.value;\n      let selected = state.selection.ranges.some(r => r.from == from && r.to == to);\n      builder.add(from, to, selected ? selectedMatchMark : matchMark);\n    }\n    return builder.finish();\n  }\n}, {\n  decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n  return view => {\n    let state = view.state.field(searchState, false);\n    return state && state.query.valid ? f(view, state) : openSearchPanel(view);\n  };\n}\nfunction findNextMatch(doc, from, query) {\n  let cursor = query.cursor(doc, from).next();\n  if (cursor.done) {\n    cursor = query.cursor(doc, 0, from + query.search.length - 1).next();\n    if (cursor.done) return null;\n  }\n  return cursor.value;\n}\nconst findNext = searchCommand((view, state) => {\n  let {from, to} = view.state.selection.main;\n  let next = findNextMatch(view.state.doc, view.state.selection.main.from + 1, state.query);\n  if (!next || next.from == from && next.to == to) return false;\n  view.dispatch({\n    selection: {\n      anchor: next.from,\n      head: next.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, next)\n  });\n  return true;\n});\nconst FindPrevChunkSize = 10000;\nfunction findPrevInRange(query, doc, from, to) {\n  for (let pos = to; ; ) {\n    let start = Math.max(from, pos - FindPrevChunkSize - query.search.length);\n    let cursor = query.cursor(doc, start, pos), range = null;\n    while (!cursor.next().done) range = cursor.value;\n    if (range) return range;\n    if (start == from) return null;\n    pos -= FindPrevChunkSize;\n  }\n}\nconst findPrevious = searchCommand((view, {query}) => {\n  let {state} = view;\n  let range = findPrevInRange(query, state.doc, 0, state.selection.main.to - 1) || findPrevInRange(query, state.doc, state.selection.main.from + 1, state.doc.length);\n  if (!range) return false;\n  view.dispatch({\n    selection: {\n      anchor: range.from,\n      head: range.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, range)\n  });\n  return true;\n});\nconst selectMatches = searchCommand((view, {query}) => {\n  let cursor = query.cursor(view.state.doc), ranges = [];\n  while (!cursor.next().done) ranges.push(state_1.EditorSelection.range(cursor.value.from, cursor.value.to));\n  if (!ranges.length) return false;\n  view.dispatch({\n    selection: state_1.EditorSelection.create(ranges)\n  });\n  return true;\n});\nconst selectSelectionMatches = ({state, dispatch}) => {\n  let sel = state.selection;\n  if (sel.ranges.length > 1 || sel.main.empty) return false;\n  let {from, to} = sel.main;\n  let ranges = [], main = 0;\n  for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done; ) {\n    if (ranges.length > 1000) return false;\n    if (cur.value.from == from) main = ranges.length;\n    ranges.push(state_1.EditorSelection.range(cur.value.from, cur.value.to));\n  }\n  dispatch(state.update({\n    selection: state_1.EditorSelection.create(ranges, main)\n  }));\n  return true;\n};\nconst replaceNext = searchCommand((view, {query}) => {\n  let {state} = view, next = findNextMatch(state.doc, state.selection.main.from, query);\n  if (!next) return false;\n  let {from, to} = state.selection.main, changes = [], selection;\n  if (next.from == from && next.to == to) {\n    changes.push({\n      from: next.from,\n      to: next.to,\n      insert: query.replace\n    });\n    next = findNextMatch(state.doc, next.to, query);\n  }\n  if (next) {\n    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - query.replace.length;\n    selection = {\n      anchor: next.from - off,\n      head: next.to - off\n    };\n  }\n  view.dispatch({\n    changes,\n    selection,\n    scrollIntoView: !!selection,\n    effects: next ? announceMatch(view, next) : undefined\n  });\n  return true;\n});\nconst replaceAll = searchCommand((view, {query}) => {\n  let cursor = query.cursor(view.state.doc), changes = [];\n  while (!cursor.next().done) {\n    let {from, to} = cursor.value;\n    changes.push({\n      from,\n      to,\n      insert: query.replace\n    });\n  }\n  if (!changes.length) return false;\n  view.dispatch({\n    changes\n  });\n  return true;\n});\nfunction createSearchPanel(view) {\n  let {query} = view.state.field(searchState);\n  return {\n    dom: buildPanel({\n      view,\n      query,\n      updateQuery(q) {\n        if (!query.eq(q)) {\n          query = q;\n          view.dispatch({\n            effects: setQuery.of(query)\n          });\n        }\n      }\n    }),\n    mount() {\n      this.dom.querySelector(\"[name=search]\").select();\n    },\n    pos: 80\n  };\n}\nconst openSearchPanel = view => {\n  let state = view.state.field(searchState, false);\n  if (state && state.panel) {\n    let panel = panel_1.getPanel(view, createSearchPanel);\n    if (!panel) return false;\n    panel.dom.querySelector(\"[name=search]\").focus();\n  } else {\n    view.dispatch({\n      effects: [togglePanel.of(true), ...state ? [] : [state_1.StateEffect.appendConfig.of(searchExtensions)]]\n    });\n  }\n  return true;\n};\nconst closeSearchPanel = view => {\n  let state = view.state.field(searchState, false);\n  if (!state || !state.panel) return false;\n  let panel = panel_1.getPanel(view, createSearchPanel);\n  if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n  view.dispatch({\n    effects: togglePanel.of(false)\n  });\n  return true;\n};\nconst searchKeymap = [{\n  key: \"Mod-f\",\n  run: openSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"F3\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-g\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Escape\",\n  run: closeSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-Shift-l\",\n  run: selectSelectionMatches\n}, {\n  key: \"Alt-g\",\n  run: gotoLine\n}];\nfunction buildPanel(conf) {\n  function p(phrase) {\n    return conf.view.state.phrase(phrase);\n  }\n  let searchField = crelt_1d.default(\"input\", {\n    value: conf.query.search,\n    placeholder: p(\"Find\"),\n    \"aria-label\": p(\"Find\"),\n    class: \"cm-textfield\",\n    name: \"search\",\n    onchange: update,\n    onkeyup: update\n  });\n  let replaceField = crelt_1d.default(\"input\", {\n    value: conf.query.replace,\n    placeholder: p(\"Replace\"),\n    \"aria-label\": p(\"Replace\"),\n    class: \"cm-textfield\",\n    name: \"replace\",\n    onchange: update,\n    onkeyup: update\n  });\n  let caseField = crelt_1d.default(\"input\", {\n    type: \"checkbox\",\n    name: \"case\",\n    checked: !conf.query.caseInsensitive,\n    onchange: update\n  });\n  function update() {\n    conf.updateQuery(new Query(searchField.value, replaceField.value, !caseField.checked));\n  }\n  function keydown(e) {\n    if (view_1.runScopeHandlers(conf.view, e, \"search-panel\")) {\n      e.preventDefault();\n    } else if (e.keyCode == 13 && e.target == searchField) {\n      e.preventDefault();\n      (e.shiftKey ? findPrevious : findNext)(conf.view);\n    } else if (e.keyCode == 13 && e.target == replaceField) {\n      e.preventDefault();\n      replaceNext(conf.view);\n    }\n  }\n  function button(name, onclick, content) {\n    return crelt_1d.default(\"button\", {\n      class: \"cm-button\",\n      name,\n      onclick\n    }, content);\n  }\n  let panel = crelt_1d.default(\"div\", {\n    onkeydown: keydown,\n    class: \"cm-search\"\n  }, [searchField, button(\"next\", () => findNext(conf.view), [p(\"next\")]), button(\"prev\", () => findPrevious(conf.view), [p(\"previous\")]), button(\"select\", () => selectMatches(conf.view), [p(\"all\")]), crelt_1d.default(\"label\", null, [caseField, \"match case\"]), crelt_1d.default(\"br\"), replaceField, button(\"replace\", () => replaceNext(conf.view), [p(\"replace\")]), button(\"replaceAll\", () => replaceAll(conf.view), [p(\"replace all\")]), crelt_1d.default(\"button\", {\n    name: \"close\",\n    onclick: () => closeSearchPanel(conf.view),\n    \"aria-label\": p(\"close\")\n  }, [\"×\"])]);\n  return panel;\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, {from, to}) {\n  if (view.hasFocus) return undefined;\n  let lineStart = view.state.doc.lineAt(from).from, lineEnd = view.state.doc.lineAt(to).to;\n  let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n  let text = view.state.sliceDoc(start, end);\n  if (start != lineStart) {\n    for (let i = 0; i < AnnounceMargin; i++) if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n      text = text.slice(i);\n      break;\n    }\n  }\n  if (end != lineEnd) {\n    for (let i = text.length - 1; i > text.length - AnnounceMargin; i--) if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n      text = text.slice(0, i);\n      break;\n    }\n  }\n  return view_1.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${view.state.doc.lineAt(from).number}`);\n}\nconst baseTheme = view_1.EditorView.baseTheme({\n  \".cm-panel.cm-search\": {\n    padding: \"2px 6px 4px\",\n    position: \"relative\",\n    \"& [name=close]\": {\n      position: \"absolute\",\n      top: \"0\",\n      right: \"4px\",\n      backgroundColor: \"inherit\",\n      border: \"none\",\n      font: \"inherit\",\n      padding: 0,\n      margin: 0\n    },\n    \"& input, & button\": {\n      margin: \".2em .5em .2em 0\"\n    },\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  },\n  \"&light .cm-searchMatch\": {\n    backgroundColor: \"#ffff0054\"\n  },\n  \"&dark .cm-searchMatch\": {\n    backgroundColor: \"#00ffff8a\"\n  },\n  \"&light .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff6a0054\"\n  },\n  \"&dark .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff00ff8a\"\n  }\n});\nconst searchExtensions = [searchState, state_1.Prec.override(searchHighlighter), baseTheme];\nexports.SearchCursor = SearchCursor;\nexports.closeSearchPanel = closeSearchPanel;\nexports.findNext = findNext;\nexports.findPrevious = findPrevious;\nexports.gotoLine = gotoLine;\nexports.highlightSelectionMatches = highlightSelectionMatches;\nexports.openSearchPanel = openSearchPanel;\nexports.replaceAll = replaceAll;\nexports.replaceNext = replaceNext;\nexports.searchKeymap = searchKeymap;\nexports.selectMatches = selectMatches;\nexports.selectSelectionMatches = selectSelectionMatches;\n"}