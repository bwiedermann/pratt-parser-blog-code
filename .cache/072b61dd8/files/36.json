{"contents":"exports.__esModule = true;\nvar state_1 = __fusereq(15);\nvar view_1 = __fusereq(14);\nvar tooltip_1 = __fusereq(16);\nvar language_1 = __fusereq(25);\nvar text_1 = __fusereq(26);\nclass CompletionContext {\n  constructor(state, pos, explicit) {\n    this.state = state;\n    this.pos = pos;\n    this.explicit = explicit;\n    this.abortListeners = [];\n  }\n  tokenBefore(types) {\n    let token = language_1.syntaxTree(this.state).resolve(this.pos, -1);\n    while (token && types.indexOf(token.name) < 0) token = token.parent;\n    return token ? {\n      from: token.from,\n      to: this.pos,\n      text: this.state.sliceDoc(token.from, this.pos),\n      type: token.type\n    } : null;\n  }\n  matchBefore(expr) {\n    let line = this.state.doc.lineAt(this.pos);\n    let start = Math.max(line.from, this.pos - 250);\n    let str = line.text.slice(start - line.from, this.pos - line.from);\n    let found = str.search(ensureAnchor(expr, false));\n    return found < 0 ? null : {\n      from: start + found,\n      to: this.pos,\n      text: str.slice(found)\n    };\n  }\n  get aborted() {\n    return this.abortListeners == null;\n  }\n  addEventListener(type, listener) {\n    if (type == \"abort\" && this.abortListeners) this.abortListeners.push(listener);\n  }\n}\nfunction toSet(chars) {\n  let flat = Object.keys(chars).join(\"\");\n  let words = (/\\w/).test(flat);\n  if (words) flat = flat.replace(/\\w/g, \"\");\n  return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n  let first = Object.create(null), rest = Object.create(null);\n  for (let {label} of options) {\n    first[label[0]] = true;\n    for (let i = 1; i < label.length; i++) rest[label[i]] = true;\n  }\n  let source = toSet(first) + toSet(rest) + \"*$\";\n  return [new RegExp(\"^\" + source), new RegExp(source)];\n}\nfunction completeFromList(list) {\n  let options = list.map(o => typeof o == \"string\" ? {\n    label: o\n  } : o);\n  let [span, match] = options.every(o => (/^\\w+$/).test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\n  return context => {\n    let token = context.matchBefore(match);\n    return token || context.explicit ? {\n      from: token ? token.from : context.pos,\n      options,\n      span\n    } : null;\n  };\n}\nfunction ifNotIn(nodes, source) {\n  return context => {\n    for (let pos = language_1.syntaxTree(context.state).resolve(context.pos, -1); pos; pos = pos.parent) if (nodes.indexOf(pos.name) > -1) return null;\n    return source(context);\n  };\n}\nclass Option {\n  constructor(completion, source, match) {\n    this.completion = completion;\n    this.source = source;\n    this.match = match;\n  }\n}\nfunction cur(state) {\n  return state.selection.main.head;\n}\nfunction ensureAnchor(expr, start) {\n  var _a;\n  let {source} = expr;\n  let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n  if (!addStart && !addEnd) return expr;\n  return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\nfunction applyCompletion(view, option) {\n  let apply = option.completion.apply || option.completion.label;\n  let result = option.source;\n  if (typeof apply == \"string\") {\n    view.dispatch({\n      changes: {\n        from: result.from,\n        to: result.to,\n        insert: apply\n      },\n      selection: {\n        anchor: result.from + apply.length\n      }\n    });\n  } else {\n    apply(view, option.completion, result.from, result.to);\n  }\n}\nconst SourceCache = new WeakMap();\nfunction asSource(source) {\n  if (!Array.isArray(source)) return source;\n  let known = SourceCache.get(source);\n  if (!known) SourceCache.set(source, known = completeFromList(source));\n  return known;\n}\nclass FuzzyMatcher {\n  constructor(pattern) {\n    this.pattern = pattern;\n    this.chars = [];\n    this.folded = [];\n    this.any = [];\n    this.precise = [];\n    this.byWord = [];\n    for (let p = 0; p < pattern.length; ) {\n      let char = text_1.codePointAt(pattern, p), size = text_1.codePointSize(char);\n      this.chars.push(char);\n      let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n      this.folded.push(text_1.codePointAt(upper == part ? part.toLowerCase() : upper, 0));\n      p += size;\n    }\n    this.astral = pattern.length != this.chars.length;\n  }\n  match(word) {\n    if (this.pattern.length == 0) return [0];\n    if (word.length < this.pattern.length) return null;\n    let {chars, folded, any, precise, byWord} = this;\n    if (chars.length == 1) {\n      let first = text_1.codePointAt(word, 0);\n      return first == chars[0] ? [0, 0, text_1.codePointSize(first)] : first == folded[0] ? [-200, 0, text_1.codePointSize(first)] : null;\n    }\n    let direct = word.indexOf(this.pattern);\n    if (direct == 0) return [0, 0, this.pattern.length];\n    let len = chars.length, anyTo = 0;\n    if (direct < 0) {\n      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {\n        let next = text_1.codePointAt(word, i);\n        if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n        i += text_1.codePointSize(next);\n      }\n      if (anyTo < len) return null;\n    }\n    let preciseTo = 0;\n    let byWordTo = 0, byWordFolded = false;\n    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n    let hasLower = (/[a-z]/).test(word);\n    for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {\n      let next = text_1.codePointAt(word, i);\n      if (direct < 0) {\n        if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i;\n        if (adjacentTo < len) {\n          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n            if (adjacentTo == 0) adjacentStart = i;\n            adjacentEnd = i;\n            adjacentTo++;\n          } else {\n            adjacentTo = 0;\n          }\n        }\n      }\n      let ch, type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = text_1.fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;\n      if ((type == 1 && hasLower || prevType == 0 && type != 0) && (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))) byWord[byWordTo++] = i;\n      prevType = type;\n      i += text_1.codePointSize(next);\n    }\n    if (byWordTo == len && byWord[0] == 0) return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);\n    if (adjacentTo == len && adjacentStart == 0) return [-200, 0, adjacentEnd];\n    if (direct > -1) return [-700, direct, direct + this.pattern.length];\n    if (adjacentTo == len) return [-200 + -700, adjacentStart, adjacentEnd];\n    if (byWordTo == len) return this.result(-100 + (byWordFolded ? -200 : 0) + -700, byWord, word);\n    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);\n  }\n  result(score, positions, word) {\n    let result = [score], i = 1;\n    for (let pos of positions) {\n      let to = pos + (this.astral ? text_1.codePointSize(text_1.codePointAt(word, pos)) : 1);\n      if (i > 1 && result[i - 1] == pos) result[i - 1] = to; else {\n        result[i++] = pos;\n        result[i++] = to;\n      }\n    }\n    return result;\n  }\n}\nconst completionConfig = state_1.Facet.define({\n  combine(configs) {\n    return state_1.combineConfig(configs, {\n      activateOnTyping: true,\n      override: null,\n      maxRenderedOptions: 100,\n      defaultKeymap: true\n    }, {\n      defaultKeymap: (a, b) => a && b\n    });\n  }\n});\nconst MaxInfoWidth = 300;\nconst baseTheme = view_1.EditorView.baseTheme({\n  \".cm-tooltip.cm-tooltip-autocomplete\": {\n    \"& > ul\": {\n      fontFamily: \"monospace\",\n      whiteSpace: \"nowrap\",\n      overflow: \"auto\",\n      maxWidth_fallback: \"700px\",\n      maxWidth: \"min(700px, 95vw)\",\n      maxHeight: \"10em\",\n      listStyle: \"none\",\n      margin: 0,\n      padding: 0,\n      \"& > li\": {\n        cursor: \"pointer\",\n        padding: \"1px 1em 1px 3px\",\n        lineHeight: 1.2\n      },\n      \"& > li[aria-selected]\": {\n        background_fallback: \"#bdf\",\n        backgroundColor: \"Highlight\",\n        color_fallback: \"white\",\n        color: \"HighlightText\"\n      }\n    }\n  },\n  \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n    content: '\"···\"',\n    opacity: 0.5,\n    display: \"block\",\n    textAlign: \"center\"\n  },\n  \".cm-tooltip.cm-completionInfo\": {\n    position: \"absolute\",\n    padding: \"3px 9px\",\n    width: \"max-content\",\n    maxWidth: MaxInfoWidth + \"px\"\n  },\n  \".cm-completionInfo.cm-completionInfo-left\": {\n    right: \"100%\"\n  },\n  \".cm-completionInfo.cm-completionInfo-right\": {\n    left: \"100%\"\n  },\n  \"&light .cm-snippetField\": {\n    backgroundColor: \"#00000022\"\n  },\n  \"&dark .cm-snippetField\": {\n    backgroundColor: \"#ffffff22\"\n  },\n  \".cm-snippetFieldPosition\": {\n    verticalAlign: \"text-top\",\n    width: 0,\n    height: \"1.15em\",\n    margin: \"0 -0.7px -.7em\",\n    borderLeft: \"1.4px dotted #888\"\n  },\n  \".cm-completionMatchedText\": {\n    textDecoration: \"underline\"\n  },\n  \".cm-completionDetail\": {\n    marginLeft: \"0.5em\",\n    fontStyle: \"italic\"\n  },\n  \".cm-completionIcon\": {\n    fontSize: \"90%\",\n    width: \".8em\",\n    display: \"inline-block\",\n    textAlign: \"center\",\n    paddingRight: \".6em\",\n    opacity: \"0.6\"\n  },\n  \".cm-completionIcon-function, .cm-completionIcon-method\": {\n    \"&:after\": {\n      content: \"'ƒ'\"\n    }\n  },\n  \".cm-completionIcon-class\": {\n    \"&:after\": {\n      content: \"'○'\"\n    }\n  },\n  \".cm-completionIcon-interface\": {\n    \"&:after\": {\n      content: \"'◌'\"\n    }\n  },\n  \".cm-completionIcon-variable\": {\n    \"&:after\": {\n      content: \"'𝑥'\"\n    }\n  },\n  \".cm-completionIcon-constant\": {\n    \"&:after\": {\n      content: \"'𝐶'\"\n    }\n  },\n  \".cm-completionIcon-type\": {\n    \"&:after\": {\n      content: \"'𝑡'\"\n    }\n  },\n  \".cm-completionIcon-enum\": {\n    \"&:after\": {\n      content: \"'∪'\"\n    }\n  },\n  \".cm-completionIcon-property\": {\n    \"&:after\": {\n      content: \"'□'\"\n    }\n  },\n  \".cm-completionIcon-keyword\": {\n    \"&:after\": {\n      content: \"'🔑\\uFE0E'\"\n    }\n  },\n  \".cm-completionIcon-namespace\": {\n    \"&:after\": {\n      content: \"'▢'\"\n    }\n  },\n  \".cm-completionIcon-text\": {\n    \"&:after\": {\n      content: \"'abc'\",\n      fontSize: \"50%\",\n      verticalAlign: \"middle\"\n    }\n  }\n});\nfunction createListBox(options, id, range) {\n  const ul = document.createElement(\"ul\");\n  ul.id = id;\n  ul.setAttribute(\"role\", \"listbox\");\n  ul.setAttribute(\"aria-expanded\", \"true\");\n  for (let i = range.from; i < range.to; i++) {\n    let {completion, match} = options[i];\n    const li = ul.appendChild(document.createElement(\"li\"));\n    li.id = id + \"-\" + i;\n    let icon = li.appendChild(document.createElement(\"div\"));\n    icon.classList.add(\"cm-completionIcon\");\n    if (completion.type) icon.classList.add(\"cm-completionIcon-\" + completion.type);\n    icon.setAttribute(\"aria-hidden\", \"true\");\n    let labelElt = li.appendChild(document.createElement(\"span\"));\n    labelElt.className = \"cm-completionLabel\";\n    let {label, detail} = completion, off = 0;\n    for (let j = 1; j < match.length; ) {\n      let from = match[j++], to = match[j++];\n      if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n      let span = labelElt.appendChild(document.createElement(\"span\"));\n      span.appendChild(document.createTextNode(label.slice(from, to)));\n      span.className = \"cm-completionMatchedText\";\n      off = to;\n    }\n    if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n    if (detail) {\n      let detailElt = li.appendChild(document.createElement(\"span\"));\n      detailElt.className = \"cm-completionDetail\";\n      detailElt.textContent = detail;\n    }\n    li.setAttribute(\"role\", \"option\");\n  }\n  if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n  if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n  return ul;\n}\nfunction createInfoDialog(option, view) {\n  let dom = document.createElement(\"div\");\n  dom.className = \"cm-tooltip cm-completionInfo\";\n  let {info} = option.completion;\n  if (typeof info == \"string\") {\n    dom.textContent = info;\n  } else {\n    let content = info(option.completion);\n    if (content.then) content.then(node => dom.appendChild(node), e => view_1.logException(view.state, e, \"completion info\")); else dom.appendChild(content);\n  }\n  return dom;\n}\nfunction rangeAroundSelected(total, selected, max) {\n  if (total <= max) return {\n    from: 0,\n    to: total\n  };\n  if (selected <= total >> 1) {\n    let off = Math.floor(selected / max);\n    return {\n      from: off * max,\n      to: (off + 1) * max\n    };\n  }\n  let off = Math.floor((total - selected) / max);\n  return {\n    from: total - (off + 1) * max,\n    to: total - off * max\n  };\n}\nclass CompletionTooltip {\n  constructor(view, stateField) {\n    this.view = view;\n    this.stateField = stateField;\n    this.info = null;\n    this.placeInfo = {\n      read: () => this.measureInfo(),\n      write: pos => this.positionInfo(pos),\n      key: this\n    };\n    let cState = view.state.field(stateField);\n    let {options, selected} = cState.open;\n    let config = view.state.facet(completionConfig);\n    this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-tooltip-autocomplete\";\n    this.dom.addEventListener(\"mousedown\", e => {\n      for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\n        if (dom.nodeName == \"LI\" && (match = (/-(\\d+)$/).exec(dom.id)) && +match[1] < options.length) {\n          applyCompletion(view, options[+match[1]]);\n          e.preventDefault();\n          return;\n        }\n      }\n    });\n    this.list = this.dom.appendChild(createListBox(options, cState.id, this.range));\n    this.list.addEventListener(\"scroll\", () => {\n      if (this.info) this.view.requestMeasure(this.placeInfo);\n    });\n  }\n  mount() {\n    this.updateSel();\n  }\n  update(update) {\n    if (update.state.field(this.stateField) != update.startState.field(this.stateField)) this.updateSel();\n  }\n  positioned() {\n    if (this.info) this.view.requestMeasure(this.placeInfo);\n  }\n  updateSel() {\n    let cState = this.view.state.field(this.stateField), open = cState.open;\n    if (open.selected < this.range.from || open.selected >= this.range.to) {\n      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n      this.list.remove();\n      this.list = this.dom.appendChild(createListBox(open.options, cState.id, this.range));\n      this.list.addEventListener(\"scroll\", () => {\n        if (this.info) this.view.requestMeasure(this.placeInfo);\n      });\n    }\n    if (this.updateSelectedOption(open.selected)) {\n      if (this.info) {\n        this.info.remove();\n        this.info = null;\n      }\n      let option = open.options[open.selected];\n      if (option.completion.info) {\n        this.info = this.dom.appendChild(createInfoDialog(option, this.view));\n        this.view.requestMeasure(this.placeInfo);\n      }\n    }\n  }\n  updateSelectedOption(selected) {\n    let set = null;\n    for (let opt = this.list.firstChild, i = this.range.from; opt; (opt = opt.nextSibling, i++)) {\n      if (i == selected) {\n        if (!opt.hasAttribute(\"aria-selected\")) {\n          opt.setAttribute(\"aria-selected\", \"true\");\n          set = opt;\n        }\n      } else {\n        if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n      }\n    }\n    if (set) scrollIntoView(this.list, set);\n    return set;\n  }\n  measureInfo() {\n    let sel = this.dom.querySelector(\"[aria-selected]\");\n    if (!sel) return null;\n    let rect = this.dom.getBoundingClientRect();\n    let top = sel.getBoundingClientRect().top - rect.top;\n    if (top < 0 || top > this.list.clientHeight - 10) return null;\n    let left = this.view.textDirection == view_1.Direction.RTL;\n    let spaceLeft = rect.left, spaceRight = innerWidth - rect.right;\n    if (left && spaceLeft < Math.min(MaxInfoWidth, spaceRight)) left = false; else if (!left && spaceRight < Math.min(MaxInfoWidth, spaceLeft)) left = true;\n    return {\n      top,\n      left\n    };\n  }\n  positionInfo(pos) {\n    if (this.info && pos) {\n      this.info.style.top = pos.top + \"px\";\n      this.info.classList.toggle(\"cm-completionInfo-left\", pos.left);\n      this.info.classList.toggle(\"cm-completionInfo-right\", !pos.left);\n    }\n  }\n}\nfunction completionTooltip(stateField) {\n  return view => new CompletionTooltip(view, stateField);\n}\nfunction scrollIntoView(container, element) {\n  let parent = container.getBoundingClientRect();\n  let self = element.getBoundingClientRect();\n  if (self.top < parent.top) container.scrollTop -= parent.top - self.top; else if (self.bottom > parent.bottom) container.scrollTop += self.bottom - parent.bottom;\n}\nconst MaxOptions = 300;\nfunction score(option) {\n  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n  let options = [];\n  for (let a of active) if (a.hasResult()) {\n    let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;\n    for (let option of a.result.options) if (match = matcher.match(option.label)) {\n      if (option.boost != null) match[0] += option.boost;\n      options.push(new Option(option, a, match));\n    }\n  }\n  options.sort(cmpOption);\n  let result = [], prev = null;\n  for (let opt of options.sort(cmpOption)) {\n    if (result.length == MaxOptions) break;\n    if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail) result.push(opt); else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n    prev = opt.completion;\n  }\n  return result;\n}\nclass CompletionDialog {\n  constructor(options, attrs, tooltip, timestamp, selected) {\n    this.options = options;\n    this.attrs = attrs;\n    this.tooltip = tooltip;\n    this.timestamp = timestamp;\n    this.selected = selected;\n  }\n  setSelected(selected, id) {\n    return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);\n  }\n  static build(active, state, id, prev) {\n    let options = sortOptions(active, state);\n    if (!options.length) return null;\n    let selected = 0;\n    if (prev && prev.selected) {\n      let selectedValue = prev.options[prev.selected].completion;\n      for (let i = 0; i < options.length && !selected; i++) {\n        if (options[i].completion == selectedValue) selected = i;\n      }\n    }\n    return new CompletionDialog(options, makeAttrs(id, selected), {\n      pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n      create: completionTooltip(completionState)\n    }, prev ? prev.timestamp : Date.now(), selected);\n  }\n  map(changes) {\n    return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n      pos: changes.mapPos(this.tooltip.pos)\n    }), this.timestamp, this.selected);\n  }\n}\nclass CompletionState {\n  constructor(active, id, open) {\n    this.active = active;\n    this.id = id;\n    this.open = open;\n  }\n  static start() {\n    return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n  }\n  update(tr) {\n    let {state} = tr, conf = state.facet(completionConfig);\n    let sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n    let active = sources.map(source => {\n      let value = this.active.find(s => s.source == source) || new ActiveSource(source, 0, false);\n      return value.update(tr, conf);\n    });\n    if (active.length == this.active.length && active.every((a, i) => a == this.active[i])) active = this.active;\n    let open = tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;\n    if (!open && active.every(a => a.state != 1) && active.some(a => a.hasResult())) active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0, false) : a);\n    for (let effect of tr.effects) if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n    return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n  }\n  get tooltip() {\n    return this.open ? this.open.tooltip : null;\n  }\n  get attrs() {\n    return this.open ? this.open.attrs : baseAttrs;\n  }\n}\nfunction sameResults(a, b) {\n  if (a == b) return true;\n  for (let iA = 0, iB = 0; ; ) {\n    while (iA < a.length && !a[iA].hasResult) iA++;\n    while (iB < b.length && !b[iB].hasResult) iB++;\n    let endA = iA == a.length, endB = iB == b.length;\n    if (endA || endB) return endA == endB;\n    if (a[iA++].result != b[iB++].result) return false;\n  }\n}\nfunction makeAttrs(id, selected) {\n  return {\n    \"aria-autocomplete\": \"list\",\n    \"aria-activedescendant\": id + \"-\" + selected,\n    \"aria-owns\": id\n  };\n}\nconst baseAttrs = {\n  \"aria-autocomplete\": \"list\"\n}, none = [];\nfunction cmpOption(a, b) {\n  let dScore = b.match[0] - a.match[0];\n  if (dScore) return dScore;\n  let lA = a.completion.label, lB = b.completion.label;\n  return lA < lB ? -1 : lA == lB ? 0 : 1;\n}\nclass ActiveSource {\n  constructor(source, state, explicit) {\n    this.source = source;\n    this.state = state;\n    this.explicit = explicit;\n  }\n  hasResult() {\n    return false;\n  }\n  update(tr, conf) {\n    let event = tr.annotation(state_1.Transaction.userEvent), value = this;\n    if (event == \"input\" || event == \"delete\") value = value.handleUserEvent(tr, event, conf); else if (tr.docChanged) value = value.handleChange(tr); else if (tr.selection && value.state != 0) value = new ActiveSource(value.source, 0, false);\n    for (let effect of tr.effects) {\n      if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1, effect.value); else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0, false); else if (effect.is(setActiveEffect)) for (let active of effect.value) if (active.source == value.source) value = active;\n    }\n    return value;\n  }\n  handleUserEvent(_tr, type, conf) {\n    return type == \"delete\" || !conf.activateOnTyping ? this : new ActiveSource(this.source, 1, false);\n  }\n  handleChange(tr) {\n    return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0, false) : this;\n  }\n}\nclass ActiveResult extends ActiveSource {\n  constructor(source, explicit, result, from, to, span) {\n    super(source, 2, explicit);\n    this.result = result;\n    this.from = from;\n    this.to = to;\n    this.span = span;\n  }\n  hasResult() {\n    return true;\n  }\n  handleUserEvent(tr, type, conf) {\n    let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n    let pos = cur(tr.state);\n    if ((this.explicit ? pos < from : pos <= from) || pos > to) return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 : 0, false);\n    if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to)))) return new ActiveResult(this.source, this.explicit, this.result, from, to, this.span);\n    return new ActiveSource(this.source, 1, this.explicit);\n  }\n  handleChange(tr) {\n    return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0, false) : new ActiveResult(this.source, this.explicit, this.result, tr.changes.mapPos(this.from), tr.changes.mapPos(this.to, 1), this.span);\n  }\n  map(mapping) {\n    return new ActiveResult(this.source, this.explicit, this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);\n  }\n}\nconst startCompletionEffect = state_1.StateEffect.define();\nconst closeCompletionEffect = state_1.StateEffect.define();\nconst setActiveEffect = state_1.StateEffect.define({\n  map(sources, mapping) {\n    return sources.map(s => s.hasResult() && !mapping.empty ? s.map(mapping) : s);\n  }\n});\nconst setSelectedEffect = state_1.StateEffect.define();\nconst completionState = state_1.StateField.define({\n  create() {\n    return CompletionState.start();\n  },\n  update(value, tr) {\n    return value.update(tr);\n  },\n  provide: f => [tooltip_1.showTooltip.from(f, val => val.tooltip), view_1.EditorView.contentAttributes.from(f, state => state.attrs)]\n});\nconst CompletionInteractMargin = 75;\nfunction moveCompletionSelection(forward, by = \"option\") {\n  return view => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;\n    let step = 1, tooltip;\n    if (by == \"page\" && (tooltip = view.dom.querySelector(\".cm-tooltip-autocomplete\"))) step = Math.max(2, Math.floor(tooltip.offsetHeight / tooltip.firstChild.offsetHeight));\n    let selected = cState.open.selected + step * (forward ? 1 : -1), {length} = cState.open.options;\n    if (selected < 0) selected = by == \"page\" ? 0 : length - 1; else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n    view.dispatch({\n      effects: setSelectedEffect.of(selected)\n    });\n    return true;\n  };\n}\nconst acceptCompletion = view => {\n  let cState = view.state.field(completionState, false);\n  if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;\n  applyCompletion(view, cState.open.options[cState.open.selected]);\n  return true;\n};\nconst startCompletion = view => {\n  let cState = view.state.field(completionState, false);\n  if (!cState) return false;\n  view.dispatch({\n    effects: startCompletionEffect.of(true)\n  });\n  return true;\n};\nconst closeCompletion = view => {\n  let cState = view.state.field(completionState, false);\n  if (!cState || !cState.active.some(a => a.state != 0)) return false;\n  view.dispatch({\n    effects: closeCompletionEffect.of(null)\n  });\n  return true;\n};\nclass RunningQuery {\n  constructor(source, context) {\n    this.source = source;\n    this.context = context;\n    this.time = Date.now();\n    this.updates = [];\n    this.done = undefined;\n  }\n}\nconst DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = view_1.ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.debounceUpdate = -1;\n    this.running = [];\n    this.debounceAccept = -1;\n    this.composing = 0;\n    for (let active of view.state.field(completionState).active) if (active.state == 1) this.startQuery(active);\n  }\n  update(update) {\n    let cState = update.state.field(completionState);\n    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;\n    let doesReset = update.transactions.some(tr => {\n      let event = tr.annotation(state_1.Transaction.userEvent);\n      return (tr.selection || tr.docChanged) && event != \"input\" && event != \"delete\";\n    });\n    for (let i = 0; i < this.running.length; i++) {\n      let query = this.running[i];\n      if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {\n        for (let handler of query.context.abortListeners) {\n          try {\n            handler();\n          } catch (e) {\n            view_1.logException(this.view.state, e);\n          }\n        }\n        query.context.abortListeners = null;\n        this.running.splice(i--, 1);\n      } else {\n        query.updates.push(...update.transactions);\n      }\n    }\n    if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n    this.debounceUpdate = cState.active.some(a => a.state == 1 && !this.running.some(q => q.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;\n    if (this.composing != 0) for (let tr of update.transactions) {\n      if (tr.annotation(state_1.Transaction.userEvent) == \"input\") this.composing = 2; else if (this.composing == 2 && tr.selection) this.composing = 3;\n    }\n  }\n  startUpdate() {\n    this.debounceUpdate = -1;\n    let {state} = this.view, cState = state.field(completionState);\n    for (let active of cState.active) {\n      if (active.state == 1 && !this.running.some(r => r.source == active.source)) this.startQuery(active);\n    }\n  }\n  startQuery(active) {\n    let {state} = this.view, pos = cur(state);\n    let context = new CompletionContext(state, pos, active.explicit);\n    let pending = new RunningQuery(active.source, context);\n    this.running.push(pending);\n    Promise.resolve(active.source(context)).then(result => {\n      if (!pending.context.aborted) {\n        pending.done = result || null;\n        this.scheduleAccept();\n      }\n    }, err => {\n      this.view.dispatch({\n        effects: closeCompletionEffect.of(null)\n      });\n      view_1.logException(this.view.state, err);\n    });\n  }\n  scheduleAccept() {\n    if (this.running.every(q => q.done !== undefined)) this.accept(); else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);\n  }\n  accept() {\n    var _a;\n    if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n    this.debounceAccept = -1;\n    let updated = [];\n    let conf = this.view.state.facet(completionConfig);\n    for (let i = 0; i < this.running.length; i++) {\n      let query = this.running[i];\n      if (query.done === undefined) continue;\n      this.running.splice(i--, 1);\n      if (query.done) {\n        let active = new ActiveResult(query.source, query.context.explicit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span ? ensureAnchor(query.done.span, true) : null);\n        for (let tr of query.updates) active = active.update(tr, conf);\n        if (active.hasResult()) {\n          updated.push(active);\n          continue;\n        }\n      }\n      let current = this.view.state.field(completionState).active.find(a => a.source == query.source);\n      if (current && current.state == 1) {\n        if (query.done == null) {\n          let active = new ActiveSource(query.source, 0, false);\n          for (let tr of query.updates) active = active.update(tr, conf);\n          if (active.state != 1) updated.push(active);\n        } else {\n          this.startQuery(current);\n        }\n      }\n    }\n    if (updated.length) this.view.dispatch({\n      effects: setActiveEffect.of(updated)\n    });\n  }\n}, {\n  eventHandlers: {\n    compositionstart() {\n      this.composing = 1;\n    },\n    compositionend() {\n      if (this.composing == 3) this.view.dispatch({\n        effects: startCompletionEffect.of(false)\n      });\n      this.composing = 0;\n    }\n  }\n});\nclass FieldPos {\n  constructor(field, line, from, to) {\n    this.field = field;\n    this.line = line;\n    this.from = from;\n    this.to = to;\n  }\n}\nclass FieldRange {\n  constructor(field, from, to) {\n    this.field = field;\n    this.from = from;\n    this.to = to;\n  }\n  map(changes) {\n    return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));\n  }\n}\nclass Snippet {\n  constructor(lines, fieldPositions) {\n    this.lines = lines;\n    this.fieldPositions = fieldPositions;\n  }\n  instantiate(state, pos) {\n    let text = [], lineStart = [pos];\n    let lineObj = state.doc.lineAt(pos), baseIndent = (/^\\s*/).exec(lineObj.text)[0];\n    for (let line of this.lines) {\n      if (text.length) {\n        let indent = baseIndent, tabs = (/^\\t*/).exec(line)[0].length;\n        for (let i = 0; i < tabs; i++) indent += state.facet(language_1.indentUnit);\n        lineStart.push(pos + indent.length - tabs);\n        line = indent + line.slice(tabs);\n      }\n      text.push(line);\n      pos += line.length + 1;\n    }\n    let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n    return {\n      text,\n      ranges\n    };\n  }\n  static parse(template) {\n    let fields = [];\n    let lines = [], positions = [], m;\n    for (let line of template.split(/\\r\\n?|\\n/)) {\n      while (m = (/[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/).exec(line)) {\n        let seq = m[1] ? +m[1] : null, name = m[2] || m[3], found = -1;\n        for (let i = 0; i < fields.length; i++) {\n          if (name ? fields[i].name == name : seq != null && fields[i].seq == seq) found = i;\n        }\n        if (found < 0) {\n          let i = 0;\n          while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq)) i++;\n          fields.splice(i, 0, {\n            seq,\n            name: name || null\n          });\n          found = i;\n        }\n        positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n        line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n      }\n      lines.push(line);\n    }\n    return new Snippet(lines, positions);\n  }\n}\nlet fieldMarker = view_1.Decoration.widget({\n  widget: new (class extends view_1.WidgetType {\n    toDOM() {\n      let span = document.createElement(\"span\");\n      span.className = \"cm-snippetFieldPosition\";\n      return span;\n    }\n    ignoreEvent() {\n      return false;\n    }\n  })()\n});\nlet fieldRange = view_1.Decoration.mark({\n  class: \"cm-snippetField\"\n});\nclass ActiveSnippet {\n  constructor(ranges, active) {\n    this.ranges = ranges;\n    this.active = active;\n    this.deco = view_1.Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n  }\n  map(changes) {\n    return new ActiveSnippet(this.ranges.map(r => r.map(changes)), this.active);\n  }\n  selectionInsideField(sel) {\n    return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\n  }\n}\nconst setActive = state_1.StateEffect.define({\n  map(value, changes) {\n    return value && value.map(changes);\n  }\n});\nconst moveToField = state_1.StateEffect.define();\nconst snippetState = state_1.StateField.define({\n  create() {\n    return null;\n  },\n  update(value, tr) {\n    for (let effect of tr.effects) {\n      if (effect.is(setActive)) return effect.value;\n      if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n    }\n    if (value && tr.docChanged) value = value.map(tr.changes);\n    if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n    return value;\n  },\n  provide: f => view_1.EditorView.decorations.from(f, val => val ? val.deco : view_1.Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n  return state_1.EditorSelection.create(ranges.filter(r => r.field == field).map(r => state_1.EditorSelection.range(r.from, r.to)));\n}\nfunction snippet(template) {\n  let snippet = Snippet.parse(template);\n  return (editor, _completion, from, to) => {\n    let {text, ranges} = snippet.instantiate(editor.state, from);\n    let spec = {\n      changes: {\n        from,\n        to,\n        insert: state_1.Text.of(text)\n      }\n    };\n    if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n    if (ranges.length > 1) {\n      let effects = spec.effects = [setActive.of(new ActiveSnippet(ranges, 0))];\n      if (editor.state.field(snippetState, false) === undefined) effects.push(state_1.StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));\n    }\n    editor.dispatch(editor.state.update(spec));\n  };\n}\nfunction moveField(dir) {\n  return ({state, dispatch}) => {\n    let active = state.field(snippetState, false);\n    if (!active || dir < 0 && active.active == 0) return false;\n    let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\n    dispatch(state.update({\n      selection: fieldSelection(active.ranges, next),\n      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n    }));\n    return true;\n  };\n}\nconst clearSnippet = ({state, dispatch}) => {\n  let active = state.field(snippetState, false);\n  if (!active) return false;\n  dispatch(state.update({\n    effects: setActive.of(null)\n  }));\n  return true;\n};\nconst nextSnippetField = moveField(1);\nconst prevSnippetField = moveField(-1);\nconst defaultSnippetKeymap = [{\n  key: \"Tab\",\n  run: nextSnippetField,\n  shift: prevSnippetField\n}, {\n  key: \"Escape\",\n  run: clearSnippet\n}];\nconst snippetKeymap = state_1.Facet.define({\n  combine(maps) {\n    return maps.length ? maps[0] : defaultSnippetKeymap;\n  }\n});\nconst addSnippetKeymap = state_1.Prec.override(view_1.keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));\nfunction snippetCompletion(template, completion) {\n  return Object.assign(Object.assign({}, completion), {\n    apply: snippet(template)\n  });\n}\nconst snippetPointerHandler = view_1.EditorView.domEventHandlers({\n  mousedown(event, view) {\n    let active = view.state.field(snippetState, false), pos;\n    if (!active || (pos = view.posAtCoords({\n      x: event.clientX,\n      y: event.clientY\n    })) == null) return false;\n    let match = active.ranges.find(r => r.from <= pos && r.to >= pos);\n    if (!match || match.field == active.active) return false;\n    view.dispatch({\n      selection: fieldSelection(active.ranges, match.field),\n      effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)\n    });\n    return true;\n  }\n});\nconst completeAnyWord = context => {\n  let options = [], seen = Object.create(null);\n  let cat = context.state.charCategorizer(context.pos);\n  let start = Math.max(0, context.pos - 50000), end = Math.min(context.state.doc.length, start + 50000 * 2);\n  let from = context.pos;\n  for (let cur = context.state.doc.iterRange(start, end), pos = start; !cur.next().done; ) {\n    let {value} = cur, start = -1;\n    for (let i = 0; ; i++) {\n      if (i < value.length && cat(value[i]) == state_1.CharCategory.Word) {\n        if (start < 0) start = i;\n      } else if (start > -1) {\n        if (pos + start <= context.pos && pos + i >= context.pos) {\n          from = pos + start;\n        } else {\n          let word = value.slice(start, i);\n          if (!seen[word]) {\n            options.push({\n              type: \"text\",\n              label: word\n            });\n            seen[word] = true;\n          }\n        }\n        start = -1;\n      }\n      if (i == value.length) break;\n    }\n    pos += value.length;\n  }\n  return {\n    from,\n    options,\n    span: /^\\w*/\n  };\n};\nfunction autocompletion(config = {}) {\n  return [completionState, completionConfig.of(config), completionPlugin, completionKeymapExt, baseTheme];\n}\nconst completionKeymap = [{\n  key: \"Ctrl-Space\",\n  run: startCompletion\n}, {\n  key: \"Escape\",\n  run: closeCompletion\n}, {\n  key: \"ArrowDown\",\n  run: moveCompletionSelection(true)\n}, {\n  key: \"ArrowUp\",\n  run: moveCompletionSelection(false)\n}, {\n  key: \"PageDown\",\n  run: moveCompletionSelection(true, \"page\")\n}, {\n  key: \"PageUp\",\n  run: moveCompletionSelection(false, \"page\")\n}, {\n  key: \"Enter\",\n  run: acceptCompletion\n}];\nconst completionKeymapExt = state_1.Prec.override(view_1.keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));\nfunction completionStatus(state) {\n  let cState = state.field(completionState, false);\n  return cState && cState.active.some(a => a.state == 1) ? \"pending\" : cState && cState.active.some(a => a.state != 0) ? \"active\" : null;\n}\nfunction currentCompletions(state) {\n  var _a;\n  let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open ? open.options.map(o => o.completion) : [];\n}\nexports.CompletionContext = CompletionContext;\nexports.acceptCompletion = acceptCompletion;\nexports.autocompletion = autocompletion;\nexports.clearSnippet = clearSnippet;\nexports.closeCompletion = closeCompletion;\nexports.completeAnyWord = completeAnyWord;\nexports.completeFromList = completeFromList;\nexports.completionKeymap = completionKeymap;\nexports.completionStatus = completionStatus;\nexports.currentCompletions = currentCompletions;\nexports.ifNotIn = ifNotIn;\nexports.moveCompletionSelection = moveCompletionSelection;\nexports.nextSnippetField = nextSnippetField;\nexports.prevSnippetField = prevSnippetField;\nexports.snippet = snippet;\nexports.snippetCompletion = snippetCompletion;\nexports.snippetKeymap = snippetKeymap;\nexports.startCompletion = startCompletion;\n"}