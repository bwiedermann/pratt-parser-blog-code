{"contents":"","sourceMap":"{\"version\":3,\"sources\":[\"src/ast.ts\"],\"names\":[],\"mappings\":\"\",\"sourcesContent\":[\"import {Position} from './position';\\r\\nimport {BinaryOperationTokenType} from './lexer';\\r\\n\\r\\nexport type NodeType =\\r\\n  | 'SinkAssignment'\\r\\n  | 'VariableAssignment'\\r\\n  | 'Number'\\r\\n  | 'Boolean'\\r\\n  | 'String'\\r\\n  | 'BinaryOperation'\\r\\n  | 'Choose'\\r\\n  | 'Identifier'\\r\\n  | 'Function'\\r\\n  | 'Pair'\\r\\n  | 'CalculatorReference'\\r\\n  | 'Iterator'\\r\\n  | 'Program'\\r\\n  | 'RangeIdentifier';\\r\\n\\r\\nexport type NumberNode = {\\r\\n  nodeType: 'Number';\\r\\n  value: number;\\r\\n  outputType: Definitely<ValueType>;\\r\\n  pos: Position;\\r\\n  nodeId: string;\\r\\n};\\r\\n\\r\\nexport type BooleanNode = {\\r\\n  nodeType: 'Boolean';\\r\\n  value: boolean;\\r\\n  outputType: Definitely<ValueType>;\\r\\n  pos: Position;\\r\\n  nodeId: string;\\r\\n};\\r\\n\\r\\nexport type BinaryOperationNode = {\\r\\n  nodeType: 'BinaryOperation';\\r\\n  operator: BinaryOperationTokenType;\\r\\n  left: Node;\\r\\n  right: Node;\\r\\n  outputType: Possible<ValueType> | undefined;\\r\\n  pos: Position;\\r\\n  nodeId: string;\\r\\n};\\r\\n\\r\\n// Built to support isDefined(test()), isDefined(boolean), and test()\\r\\nexport type FunctionNode = {\\r\\n  nodeType: 'Function';\\r\\n  name: string;\\r\\n  args: Exclude<Node, ProgramNode>[]; //Everything except program node\\r\\n  outputType: Possible<ValueType>;\\r\\n  pos: Position;\\r\\n  nodeId: string;\\r\\n}\\r\\n\\r\\nexport type ChooseNode = {\\r\\n  nodeType: 'Choose';\\r\\n  case: { predicate: Exclude<Node, ProgramNode>, consequent: Exclude<Node, ProgramNode> };\\r\\n  otherwise: Exclude<Node, ProgramNode>;\\r\\n  outputType: Possible<ValueType>;\\r\\n  pos: Position\\r\\n  nodeId: string;\\r\\n}\\r\\n\\r\\nexport type VariableAssignmentNode = {\\r\\n  nodeType: 'VariableAssignment';\\r\\n  name: string;\\r\\n  assignment: Node;\\r\\n  outputType: Possible<ValueType>;\\r\\n  pos: Position;\\r\\n  nodeId: string;\\r\\n}\\r\\n\\r\\nexport type IdentifierNode = {\\r\\n  nodeType: 'Identifier' | 'RangeIdentifier';\\r\\n  name: string;\\r\\n  assignmentId: string;\\r\\n  outputType: Possible<ValueType>;\\r\\n  pos: Position;\\r\\n  nodeId: string;\\r\\n}\\r\\n\\r\\n//export type RangeIdentiferNode = {\\r\\n//  nodeType: 'RangeIdentifier';\\r\\n///  name: string;\\r\\n////  outputType: Possible<ValueType>;\\r\\n//  pos: Position;\\r\\n///  nodeId: string;\\r\\n//}\\r\\n\\r\\n\\r\\n\\r\\nexport type ProgramNode = {\\r\\n  nodeType: 'Program';\\r\\n  outputType: Possible<ValueType>;\\r\\n  children: Node[];\\r\\n}\\r\\n\\r\\nexport type IteratorNode = {\\r\\n  nodeType: 'Iterator';\\r\\n  outputType: undefined;\\r\\n  pos: Position;\\r\\n  nodeId: string;\\r\\n  index: number;\\r\\n  values: number[];\\r\\n  start: Node;\\r\\n  end: Node;\\r\\n  step: Node;\\r\\n}\\r\\n\\r\\nexport type Node = \\r\\n  | BooleanNode \\r\\n  | NumberNode \\r\\n  | BinaryOperationNode \\r\\n  | FunctionNode \\r\\n  | ChooseNode \\r\\n  | VariableAssignmentNode \\r\\n  | IdentifierNode\\r\\n  | ProgramNode\\r\\n  | IteratorNode\\r\\n  | undefined;\\r\\n\\r\\n// on to the proof of concept stuff\\r\\n\\r\\nexport type Definitely<ValueType> = {\\r\\n  status: 'Definitely'; // do we need a status anymore?\\r\\n  valueType: ValueType; // does this ensure if Definitely<boolean> than value is of type boolean?\\r\\n  value: number | undefined;\\r\\n}\\r\\n\\r\\nexport type Maybe<ValueType> = {\\r\\n  status: 'Maybe-Undefined'; // maybe only status here? This way we can \\\"change\\\" status to definitely?\\r\\n  valueType: ValueType;\\r\\n  value: number | undefined;\\r\\n}\\r\\n\\r\\nexport type OutputType<ValueType> =  Definitely<ValueType> | Maybe<ValueType>;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nexport type ValueType = 'number' | 'boolean' | 'pair' | 'any' | 'range' |undefined;\\r\\n\\r\\nexport type Possible<ValueType> = Definitely<ValueType> | Maybe<ValueType>;\\r\\n\\r\\n\\r\\n\"]}"}