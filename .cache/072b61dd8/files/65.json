{"contents":"var process = __fusereq(142);\nexports.__esModule = true;\nvar lezer_tree_1 = __fusereq(23);\nvar lezer_tree_2 = __fusereq(23);\nexports.NodeProp = lezer_tree_2.NodeProp;\nexports.NodeSet = lezer_tree_2.NodeSet;\nexports.NodeType = lezer_tree_2.NodeType;\nexports.Tree = lezer_tree_2.Tree;\nexports.TreeCursor = lezer_tree_2.TreeCursor;\nclass Stack {\n  constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, parent) {\n    this.p = p;\n    this.stack = stack;\n    this.state = state;\n    this.reducePos = reducePos;\n    this.pos = pos;\n    this.score = score;\n    this.buffer = buffer;\n    this.bufferBase = bufferBase;\n    this.curContext = curContext;\n    this.parent = parent;\n  }\n  toString() {\n    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n  }\n  static start(p, state, pos = 0) {\n    let cx = p.parser.context;\n    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, null);\n  }\n  get context() {\n    return this.curContext ? this.curContext.context : null;\n  }\n  pushState(state, start) {\n    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n    this.state = state;\n  }\n  reduce(action) {\n    let depth = action >> 19, type = action & 65535;\n    let {parser} = this.p;\n    let dPrec = parser.dynamicPrecedence(type);\n    if (dPrec) this.score += dPrec;\n    if (depth == 0) {\n      if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n      this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n      this.reduceContext(type);\n      return;\n    }\n    let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);\n    let start = this.stack[base - 2];\n    let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n    if (type < parser.minRepeatTerm || action & 131072) {\n      let pos = parser.stateFlag(this.state, 1) ? this.pos : this.reducePos;\n      this.storeNode(type, start, pos, count + 4, true);\n    }\n    if (action & 262144) {\n      this.state = this.stack[base];\n    } else {\n      let baseStateID = this.stack[base - 3];\n      this.state = parser.getGoto(baseStateID, type, true);\n    }\n    while (this.stack.length > base) this.stack.pop();\n    this.reduceContext(type);\n  }\n  storeNode(term, start, end, size = 4, isReduce = false) {\n    if (term == 0) {\n      let cur = this, top = this.buffer.length;\n      if (top == 0 && cur.parent) {\n        top = cur.bufferBase - cur.parent.bufferBase;\n        cur = cur.parent;\n      }\n      if (top > 0 && cur.buffer[top - 4] == 0 && cur.buffer[top - 1] > -1) {\n        if (start == end) return;\n        if (cur.buffer[top - 2] >= start) {\n          cur.buffer[top - 2] = end;\n          return;\n        }\n      }\n    }\n    if (!isReduce || this.pos == end) {\n      this.buffer.push(term, start, end, size);\n    } else {\n      let index = this.buffer.length;\n      if (index > 0 && this.buffer[index - 4] != 0) while (index > 0 && this.buffer[index - 2] > end) {\n        this.buffer[index] = this.buffer[index - 4];\n        this.buffer[index + 1] = this.buffer[index - 3];\n        this.buffer[index + 2] = this.buffer[index - 2];\n        this.buffer[index + 3] = this.buffer[index - 1];\n        index -= 4;\n        if (size > 4) size -= 4;\n      }\n      this.buffer[index] = term;\n      this.buffer[index + 1] = start;\n      this.buffer[index + 2] = end;\n      this.buffer[index + 3] = size;\n    }\n  }\n  shift(action, next, nextEnd) {\n    if (action & 131072) {\n      this.pushState(action & 65535, this.pos);\n    } else if ((action & 262144) == 0) {\n      let start = this.pos, nextState = action, {parser} = this.p;\n      if (nextEnd > this.pos || next <= parser.maxNode) {\n        this.pos = nextEnd;\n        if (!parser.stateFlag(nextState, 1)) this.reducePos = nextEnd;\n      }\n      this.pushState(nextState, start);\n      if (next <= parser.maxNode) this.buffer.push(next, start, nextEnd, 4);\n      this.shiftContext(next);\n    } else {\n      if (next <= this.p.parser.maxNode) this.buffer.push(next, this.pos, nextEnd, 4);\n      this.pos = nextEnd;\n    }\n  }\n  apply(action, next, nextEnd) {\n    if (action & 65536) this.reduce(action); else this.shift(action, next, nextEnd);\n  }\n  useNode(value, next) {\n    let index = this.p.reused.length - 1;\n    if (index < 0 || this.p.reused[index] != value) {\n      this.p.reused.push(value);\n      index++;\n    }\n    let start = this.pos;\n    this.reducePos = this.pos = start + value.length;\n    this.pushState(next, start);\n    this.buffer.push(index, start, this.reducePos, -1);\n    if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this.p.input, this));\n  }\n  split() {\n    let parent = this;\n    let off = parent.buffer.length;\n    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4;\n    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n    while (parent && base == parent.bufferBase) parent = parent.parent;\n    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, parent);\n  }\n  recoverByDelete(next, nextEnd) {\n    let isNode = next <= this.p.parser.maxNode;\n    if (isNode) this.storeNode(next, this.pos, nextEnd);\n    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);\n    this.pos = this.reducePos = nextEnd;\n    this.score -= 200;\n  }\n  canShift(term) {\n    for (let sim = new SimulatedStack(this); ; ) {\n      let action = this.p.parser.stateSlot(sim.top, 4) || this.p.parser.hasAction(sim.top, term);\n      if ((action & 65536) == 0) return true;\n      if (action == 0) return false;\n      sim.reduce(action);\n    }\n  }\n  get ruleStart() {\n    for (let state = this.state, base = this.stack.length; ; ) {\n      let force = this.p.parser.stateSlot(state, 5);\n      if (!(force & 65536)) return 0;\n      base -= 3 * (force >> 19);\n      if ((force & 65535) < this.p.parser.minRepeatTerm) return this.stack[base + 1];\n      state = this.stack[base];\n    }\n  }\n  startOf(types, before) {\n    let state = this.state, frame = this.stack.length, {parser} = this.p;\n    for (; ; ) {\n      let force = parser.stateSlot(state, 5);\n      let depth = force >> 19, term = force & 65535;\n      if (types.indexOf(term) > -1) {\n        let base = frame - 3 * (force >> 19), pos = this.stack[base + 1];\n        if (before == null || before > pos) return pos;\n      }\n      if (frame == 0) return null;\n      if (depth == 0) {\n        frame -= 3;\n        state = this.stack[frame];\n      } else {\n        frame -= 3 * (depth - 1);\n        state = parser.getGoto(this.stack[frame - 3], term, true);\n      }\n    }\n  }\n  recoverByInsert(next) {\n    if (this.stack.length >= 300) return [];\n    let nextStates = this.p.parser.nextStates(this.state);\n    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {\n      let best = [];\n      for (let i = 0, s; i < nextStates.length; i += 2) {\n        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);\n      }\n      if (this.stack.length < 120) for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {\n        let s = nextStates[i + 1];\n        if (!best.some((v, i) => i & 1 && v == s)) best.push(nextStates[i], s);\n      }\n      nextStates = best;\n    }\n    let result = [];\n    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {\n      let s = nextStates[i + 1];\n      if (s == this.state) continue;\n      let stack = this.split();\n      stack.storeNode(0, stack.pos, stack.pos, 4, true);\n      stack.pushState(s, this.pos);\n      stack.shiftContext(nextStates[i]);\n      stack.score -= 200;\n      result.push(stack);\n    }\n    return result;\n  }\n  forceReduce() {\n    let reduce = this.p.parser.stateSlot(this.state, 5);\n    if ((reduce & 65536) == 0) return false;\n    if (!this.p.parser.validAction(this.state, reduce)) {\n      this.storeNode(0, this.reducePos, this.reducePos, 4, true);\n      this.score -= 100;\n    }\n    this.reduce(reduce);\n    return true;\n  }\n  forceAll() {\n    while (!this.p.parser.stateFlag(this.state, 2) && this.forceReduce()) {}\n    return this;\n  }\n  get deadEnd() {\n    if (this.stack.length != 3) return false;\n    let {parser} = this.p;\n    return parser.data[parser.stateSlot(this.state, 1)] == 65535 && !parser.stateSlot(this.state, 4);\n  }\n  restart() {\n    this.state = this.stack[0];\n    this.stack.length = 0;\n  }\n  sameState(other) {\n    if (this.state != other.state || this.stack.length != other.stack.length) return false;\n    for (let i = 0; i < this.stack.length; i += 3) if (this.stack[i] != other.stack[i]) return false;\n    return true;\n  }\n  get parser() {\n    return this.p.parser;\n  }\n  dialectEnabled(dialectID) {\n    return this.p.parser.dialect.flags[dialectID];\n  }\n  shiftContext(term) {\n    if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this.p.input, this));\n  }\n  reduceContext(term) {\n    if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this.p.input, this));\n  }\n  emitContext() {\n    let cx = this.curContext;\n    if (!cx.tracker.strict) return;\n    let last = this.buffer.length - 1;\n    if (last < 0 || this.buffer[last] != -2) this.buffer.push(cx.hash, this.reducePos, this.reducePos, -2);\n  }\n  updateContext(context) {\n    if (context != this.curContext.context) {\n      let newCx = new StackContext(this.curContext.tracker, context);\n      if (newCx.hash != this.curContext.hash) this.emitContext();\n      this.curContext = newCx;\n    }\n  }\n}\nclass StackContext {\n  constructor(tracker, context) {\n    this.tracker = tracker;\n    this.context = context;\n    this.hash = tracker.hash(context);\n  }\n}\nvar Recover;\n(function (Recover) {\n  Recover[Recover[\"Token\"] = 200] = \"Token\";\n  Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n  Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n  Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n  Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\nclass SimulatedStack {\n  constructor(stack) {\n    this.stack = stack;\n    this.top = stack.state;\n    this.rest = stack.stack;\n    this.offset = this.rest.length;\n  }\n  reduce(action) {\n    let term = action & 65535, depth = action >> 19;\n    if (depth == 0) {\n      if (this.rest == this.stack.stack) this.rest = this.rest.slice();\n      this.rest.push(this.top, 0, 0);\n      this.offset += 3;\n    } else {\n      this.offset -= (depth - 1) * 3;\n    }\n    let goto = this.stack.p.parser.getGoto(this.rest[this.offset - 3], term, true);\n    this.top = goto;\n  }\n}\nclass StackBufferCursor {\n  constructor(stack, pos, index) {\n    this.stack = stack;\n    this.pos = pos;\n    this.index = index;\n    this.buffer = stack.buffer;\n    if (this.index == 0) this.maybeNext();\n  }\n  static create(stack) {\n    return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);\n  }\n  maybeNext() {\n    let next = this.stack.parent;\n    if (next != null) {\n      this.index = this.stack.bufferBase - next.bufferBase;\n      this.stack = next;\n      this.buffer = next.buffer;\n    }\n  }\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n  next() {\n    this.index -= 4;\n    this.pos -= 4;\n    if (this.index == 0) this.maybeNext();\n  }\n  fork() {\n    return new StackBufferCursor(this.stack, this.pos, this.index);\n  }\n}\nclass Token {\n  constructor() {\n    this.start = -1;\n    this.value = -1;\n    this.end = -1;\n  }\n  accept(value, end) {\n    this.value = value;\n    this.end = end;\n  }\n}\nclass TokenGroup {\n  constructor(data, id) {\n    this.data = data;\n    this.id = id;\n  }\n  token(input, token, stack) {\n    readToken(this.data, input, token, stack, this.id);\n  }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\nclass ExternalTokenizer {\n  constructor(token, options = {}) {\n    this.token = token;\n    this.contextual = !!options.contextual;\n    this.fallback = !!options.fallback;\n    this.extend = !!options.extend;\n  }\n}\nfunction readToken(data, input, token, stack, group) {\n  let state = 0, groupMask = 1 << group, dialect = stack.p.parser.dialect;\n  scan: for (let pos = token.start; ; ) {\n    if ((groupMask & data[state]) == 0) break;\n    let accEnd = data[state + 1];\n    for (let i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {\n      let term = data[i];\n      if (dialect.allows(term) && (token.value == -1 || token.value == term || stack.p.parser.overrides(term, token.value))) {\n        token.accept(term, pos);\n        break;\n      }\n    }\n    let next = input.get(pos++);\n    for (let low = 0, high = data[state + 2]; low < high; ) {\n      let mid = low + high >> 1;\n      let index = accEnd + mid + (mid << 1);\n      let from = data[index], to = data[index + 1];\n      if (next < from) high = mid; else if (next >= to) low = mid + 1; else {\n        state = data[index + 2];\n        continue scan;\n      }\n    }\n    break;\n  }\n}\nfunction decodeArray(input, Type = Uint16Array) {\n  if (typeof input != \"string\") return input;\n  let array = null;\n  for (let pos = 0, out = 0; pos < input.length; ) {\n    let value = 0;\n    for (; ; ) {\n      let next = input.charCodeAt(pos++), stop = false;\n      if (next == 126) {\n        value = 65535;\n        break;\n      }\n      if (next >= 92) next--;\n      if (next >= 34) next--;\n      let digit = next - 32;\n      if (digit >= 46) {\n        digit -= 46;\n        stop = true;\n      }\n      value += digit;\n      if (stop) break;\n      value *= 46;\n    }\n    if (array) array[out++] = value; else array = new Type(value);\n  }\n  return array;\n}\nconst verbose = typeof process != \"undefined\" && (/\\bparse\\b/).test(undefined);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n  let cursor = tree.cursor(pos);\n  for (; ; ) {\n    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for (; ; ) {\n      if ((side < 0 ? cursor.to <= pos : cursor.from >= pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 5)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 5));\n      if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;\n      if (!cursor.parent()) return side < 0 ? 0 : tree.length;\n    }\n  }\n}\nclass FragmentCursor {\n  constructor(fragments) {\n    this.fragments = fragments;\n    this.i = 0;\n    this.fragment = null;\n    this.safeFrom = -1;\n    this.safeTo = -1;\n    this.trees = [];\n    this.start = [];\n    this.index = [];\n    this.nextFragment();\n  }\n  nextFragment() {\n    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n    if (fr) {\n      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n      while (this.trees.length) {\n        this.trees.pop();\n        this.start.pop();\n        this.index.pop();\n      }\n      this.trees.push(fr.tree);\n      this.start.push(-fr.offset);\n      this.index.push(0);\n      this.nextStart = this.safeFrom;\n    } else {\n      this.nextStart = 1e9;\n    }\n  }\n  nodeAt(pos) {\n    if (pos < this.nextStart) return null;\n    while (this.fragment && this.safeTo <= pos) this.nextFragment();\n    if (!this.fragment) return null;\n    for (; ; ) {\n      let last = this.trees.length - 1;\n      if (last < 0) {\n        this.nextFragment();\n        return null;\n      }\n      let top = this.trees[last], index = this.index[last];\n      if (index == top.children.length) {\n        this.trees.pop();\n        this.start.pop();\n        this.index.pop();\n        continue;\n      }\n      let next = top.children[index];\n      let start = this.start[last] + top.positions[index];\n      if (start > pos) {\n        this.nextStart = start;\n        return null;\n      } else if (start == pos && start + next.length <= this.safeTo) {\n        return start == pos && start >= this.safeFrom ? next : null;\n      }\n      if (next instanceof lezer_tree_1.TreeBuffer) {\n        this.index[last]++;\n        this.nextStart = start + next.length;\n      } else {\n        this.index[last]++;\n        if (start + next.length >= pos) {\n          this.trees.push(next);\n          this.start.push(start);\n          this.index.push(0);\n        }\n      }\n    }\n  }\n}\nclass CachedToken extends Token {\n  constructor() {\n    super(...arguments);\n    this.extended = -1;\n    this.mask = 0;\n    this.context = 0;\n  }\n  clear(start) {\n    this.start = start;\n    this.value = this.extended = -1;\n  }\n}\nconst dummyToken = new Token();\nclass TokenCache {\n  constructor(parser) {\n    this.tokens = [];\n    this.mainToken = dummyToken;\n    this.actions = [];\n    this.tokens = parser.tokenizers.map(_ => new CachedToken());\n  }\n  getActions(stack, input) {\n    let actionIndex = 0;\n    let main = null;\n    let {parser} = stack.p, {tokenizers} = parser;\n    let mask = parser.stateSlot(stack.state, 3);\n    let context = stack.curContext ? stack.curContext.hash : 0;\n    for (let i = 0; i < tokenizers.length; i++) {\n      if ((1 << i & mask) == 0) continue;\n      let tokenizer = tokenizers[i], token = this.tokens[i];\n      if (main && !tokenizer.fallback) continue;\n      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n        this.updateCachedToken(token, tokenizer, stack, input);\n        token.mask = mask;\n        token.context = context;\n      }\n      if (token.value != 0) {\n        let startIndex = actionIndex;\n        if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n        if (!tokenizer.extend) {\n          main = token;\n          if (actionIndex > startIndex) break;\n        }\n      }\n    }\n    while (this.actions.length > actionIndex) this.actions.pop();\n    if (!main) {\n      main = dummyToken;\n      main.start = stack.pos;\n      if (stack.pos == input.length) main.accept(stack.p.parser.eofTerm, stack.pos); else main.accept(0, stack.pos + 1);\n    }\n    this.mainToken = main;\n    return this.actions;\n  }\n  updateCachedToken(token, tokenizer, stack, input) {\n    token.clear(stack.pos);\n    tokenizer.token(input, token, stack);\n    if (token.value > -1) {\n      let {parser} = stack.p;\n      for (let i = 0; i < parser.specialized.length; i++) if (parser.specialized[i] == token.value) {\n        let result = parser.specializers[i](input.read(token.start, token.end), stack);\n        if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n          if ((result & 1) == 0) token.value = result >> 1; else token.extended = result >> 1;\n          break;\n        }\n      }\n    } else if (stack.pos == input.length) {\n      token.accept(stack.p.parser.eofTerm, stack.pos);\n    } else {\n      token.accept(0, stack.pos + 1);\n    }\n  }\n  putAction(action, token, end, index) {\n    for (let i = 0; i < index; i += 3) if (this.actions[i] == action) return index;\n    this.actions[index++] = action;\n    this.actions[index++] = token;\n    this.actions[index++] = end;\n    return index;\n  }\n  addActions(stack, token, end, index) {\n    let {state} = stack, {parser} = stack.p, {data} = parser;\n    for (let set = 0; set < 2; set++) {\n      for (let i = parser.stateSlot(state, set ? 2 : 1); ; i += 3) {\n        if (data[i] == 65535) {\n          if (data[i + 1] == 1) {\n            i = pair(data, i + 2);\n          } else {\n            if (index == 0 && data[i + 1] == 2) index = this.putAction(pair(data, i + 1), token, end, index);\n            break;\n          }\n        }\n        if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);\n      }\n    }\n    return index;\n  }\n}\nvar Rec;\n(function (Rec) {\n  Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n  Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n  Rec[Rec[\"MinBufferLengthPrune\"] = 200] = \"MinBufferLengthPrune\";\n  Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n})(Rec || (Rec = {}));\nclass Parse {\n  constructor(parser, input, startPos, context) {\n    this.parser = parser;\n    this.input = input;\n    this.startPos = startPos;\n    this.context = context;\n    this.pos = 0;\n    this.recovering = 0;\n    this.nextStackID = 0x2654;\n    this.nested = null;\n    this.nestEnd = 0;\n    this.nestWrap = null;\n    this.reused = [];\n    this.tokens = new TokenCache(parser);\n    this.topTerm = parser.top[1];\n    this.stacks = [Stack.start(this, parser.top[0], this.startPos)];\n    let fragments = context === null || context === void 0 ? void 0 : context.fragments;\n    this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;\n  }\n  advance() {\n    if (this.nested) {\n      let result = this.nested.advance();\n      this.pos = this.nested.pos;\n      if (result) {\n        this.finishNested(this.stacks[0], result);\n        this.nested = null;\n      }\n      return null;\n    }\n    let stacks = this.stacks, pos = this.pos;\n    let newStacks = this.stacks = [];\n    let stopped, stoppedTokens;\n    let maybeNest;\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i], nest;\n      for (; ; ) {\n        if (stack.pos > pos) {\n          newStacks.push(stack);\n        } else if (nest = this.checkNest(stack)) {\n          if (!maybeNest || maybeNest.stack.score < stack.score) maybeNest = nest;\n        } else if (this.advanceStack(stack, newStacks, stacks)) {\n          continue;\n        } else {\n          if (!stopped) {\n            stopped = [];\n            stoppedTokens = [];\n          }\n          stopped.push(stack);\n          let tok = this.tokens.mainToken;\n          stoppedTokens.push(tok.value, tok.end);\n        }\n        break;\n      }\n    }\n    if (maybeNest) {\n      this.startNested(maybeNest);\n      return null;\n    }\n    if (!newStacks.length) {\n      let finished = stopped && findFinished(stopped);\n      if (finished) return this.stackToTree(finished);\n      if (this.parser.strict) {\n        if (verbose && stopped) console.log(\"Stuck with token \" + this.parser.getName(this.tokens.mainToken.value));\n        throw new SyntaxError(\"No parse at \" + pos);\n      }\n      if (!this.recovering) this.recovering = 5;\n    }\n    if (this.recovering && stopped) {\n      let finished = this.runRecovery(stopped, stoppedTokens, newStacks);\n      if (finished) return this.stackToTree(finished.forceAll());\n    }\n    if (this.recovering) {\n      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;\n      if (newStacks.length > maxRemaining) {\n        newStacks.sort((a, b) => b.score - a.score);\n        while (newStacks.length > maxRemaining) newStacks.pop();\n      }\n      if (newStacks.some(s => s.reducePos > pos)) this.recovering--;\n    } else if (newStacks.length > 1) {\n      outer: for (let i = 0; i < newStacks.length - 1; i++) {\n        let stack = newStacks[i];\n        for (let j = i + 1; j < newStacks.length; j++) {\n          let other = newStacks[j];\n          if (stack.sameState(other) || stack.buffer.length > 200 && other.buffer.length > 200) {\n            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {\n              newStacks.splice(j--, 1);\n            } else {\n              newStacks.splice(i--, 1);\n              continue outer;\n            }\n          }\n        }\n      }\n    }\n    this.pos = newStacks[0].pos;\n    for (let i = 1; i < newStacks.length; i++) if (newStacks[i].pos < this.pos) this.pos = newStacks[i].pos;\n    return null;\n  }\n  advanceStack(stack, stacks, split) {\n    let start = stack.pos, {input, parser} = this;\n    let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n    if (this.fragments) {\n      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n      for (let cached = this.fragments.nodeAt(start); cached; ) {\n        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n        if (match > -1 && cached.length && (!strictCx || (cached.contextHash || 0) == cxHash)) {\n          stack.useNode(cached, match);\n          if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n          return true;\n        }\n        if (!(cached instanceof lezer_tree_1.Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;\n        let inner = cached.children[0];\n        if (inner instanceof lezer_tree_1.Tree) cached = inner; else break;\n      }\n    }\n    let defaultReduce = parser.stateSlot(stack.state, 4);\n    if (defaultReduce > 0) {\n      stack.reduce(defaultReduce);\n      if (verbose) console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535)})`);\n      return true;\n    }\n    let actions = this.tokens.getActions(stack, input);\n    for (let i = 0; i < actions.length; ) {\n      let action = actions[i++], term = actions[i++], end = actions[i++];\n      let last = i == actions.length || !split;\n      let localStack = last ? stack : stack.split();\n      localStack.apply(action, term, end);\n      if (verbose) console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? \"shift\" : `reduce of ${parser.getName(action & 65535)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n      if (last) return true; else if (localStack.pos > start) stacks.push(localStack); else split.push(localStack);\n    }\n    return false;\n  }\n  advanceFully(stack, newStacks) {\n    let pos = stack.pos;\n    for (; ; ) {\n      let nest = this.checkNest(stack);\n      if (nest) return nest;\n      if (!this.advanceStack(stack, null, null)) return false;\n      if (stack.pos > pos) {\n        pushStackDedup(stack, newStacks);\n        return true;\n      }\n    }\n  }\n  runRecovery(stacks, tokens, newStacks) {\n    let finished = null, restarted = false;\n    let maybeNest;\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n      let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n      if (stack.deadEnd) {\n        if (restarted) continue;\n        restarted = true;\n        stack.restart();\n        if (verbose) console.log(base + this.stackID(stack) + \" (restarted)\");\n        let done = this.advanceFully(stack, newStacks);\n        if (done) {\n          if (done !== true) maybeNest = done;\n          continue;\n        }\n      }\n      let force = stack.split(), forceBase = base;\n      for (let j = 0; force.forceReduce() && j < 10; j++) {\n        if (verbose) console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n        let done = this.advanceFully(force, newStacks);\n        if (done) {\n          if (done !== true) maybeNest = done;\n          break;\n        }\n        if (verbose) forceBase = this.stackID(force) + \" -> \";\n      }\n      for (let insert of stack.recoverByInsert(token)) {\n        if (verbose) console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n        this.advanceFully(insert, newStacks);\n      }\n      if (this.input.length > stack.pos) {\n        if (tokenEnd == stack.pos) {\n          tokenEnd++;\n          token = 0;\n        }\n        stack.recoverByDelete(token, tokenEnd);\n        if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n        pushStackDedup(stack, newStacks);\n      } else if (!finished || finished.score < stack.score) {\n        finished = stack;\n      }\n    }\n    if (finished) return finished;\n    if (maybeNest) for (let s of this.stacks) if (s.score > maybeNest.stack.score) {\n      maybeNest = undefined;\n      break;\n    }\n    if (maybeNest) this.startNested(maybeNest);\n    return null;\n  }\n  forceFinish() {\n    let stack = this.stacks[0].split();\n    if (this.nested) this.finishNested(stack, this.nested.forceFinish());\n    return this.stackToTree(stack.forceAll());\n  }\n  stackToTree(stack, pos = stack.pos) {\n    if (this.parser.context) stack.emitContext();\n    return lezer_tree_1.Tree.build({\n      buffer: StackBufferCursor.create(stack),\n      nodeSet: this.parser.nodeSet,\n      topID: this.topTerm,\n      maxBufferLength: this.parser.bufferLength,\n      reused: this.reused,\n      start: this.startPos,\n      length: pos - this.startPos,\n      minRepeatType: this.parser.minRepeatTerm\n    });\n  }\n  checkNest(stack) {\n    let info = this.parser.findNested(stack.state);\n    if (!info) return null;\n    let spec = info.value;\n    if (typeof spec == \"function\") spec = spec(this.input, stack);\n    return spec ? {\n      stack,\n      info,\n      spec\n    } : null;\n  }\n  startNested(nest) {\n    let {stack, info, spec} = nest;\n    this.stacks = [stack];\n    this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);\n    this.nestWrap = typeof spec.wrapType == \"number\" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;\n    if (spec.startParse) {\n      this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);\n    } else {\n      this.finishNested(stack);\n    }\n  }\n  scanForNestEnd(stack, endToken, filter) {\n    for (let pos = stack.pos; pos < this.input.length; pos++) {\n      dummyToken.start = pos;\n      dummyToken.value = -1;\n      endToken.token(this.input, dummyToken, stack);\n      if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end)))) return pos;\n    }\n    return this.input.length;\n  }\n  finishNested(stack, tree) {\n    if (this.nestWrap) tree = new lezer_tree_1.Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos); else if (!tree) tree = new lezer_tree_1.Tree(lezer_tree_1.NodeType.none, [], [], this.nestEnd - stack.pos);\n    let info = this.parser.findNested(stack.state);\n    stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));\n    if (verbose) console.log(this.stackID(stack) + ` (via unnest)`);\n  }\n  stackID(stack) {\n    let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);\n    if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n    return id + stack;\n  }\n}\nfunction pushStackDedup(stack, newStacks) {\n  for (let i = 0; i < newStacks.length; i++) {\n    let other = newStacks[i];\n    if (other.pos == stack.pos && other.sameState(stack)) {\n      if (newStacks[i].score < stack.score) newStacks[i] = stack;\n      return;\n    }\n  }\n  newStacks.push(stack);\n}\nclass Dialect {\n  constructor(source, flags, disabled) {\n    this.source = source;\n    this.flags = flags;\n    this.disabled = disabled;\n  }\n  allows(term) {\n    return !this.disabled || this.disabled[term] == 0;\n  }\n}\nconst id = x => x;\nclass ContextTracker {\n  constructor(spec) {\n    this.start = spec.start;\n    this.shift = spec.shift || id;\n    this.reduce = spec.reduce || id;\n    this.reuse = spec.reuse || id;\n    this.hash = spec.hash;\n    this.strict = spec.strict !== false;\n  }\n}\nclass Parser {\n  constructor(spec) {\n    this.bufferLength = lezer_tree_1.DefaultBufferLength;\n    this.strict = false;\n    this.cachedDialect = null;\n    if (spec.version != 13) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13})`);\n    let tokenArray = decodeArray(spec.tokenData);\n    let nodeNames = spec.nodeNames.split(\" \");\n    this.minRepeatTerm = nodeNames.length;\n    this.context = spec.context;\n    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push(\"\");\n    let nodeProps = [];\n    for (let i = 0; i < nodeNames.length; i++) nodeProps.push([]);\n    function setProp(nodeID, prop, value) {\n      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n    }\n    if (spec.nodeProps) for (let propSpec of spec.nodeProps) {\n      let prop = propSpec[0];\n      for (let i = 1; i < propSpec.length; ) {\n        let next = propSpec[i++];\n        if (next >= 0) {\n          setProp(next, prop, propSpec[i++]);\n        } else {\n          let value = propSpec[i + -next];\n          for (let j = -next; j > 0; j--) setProp(propSpec[i++], prop, value);\n          i++;\n        }\n      }\n    }\n    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);\n    this.specializers = [];\n    if (spec.specialized) for (let i = 0; i < spec.specialized.length; i++) {\n      this.specialized[i] = spec.specialized[i].term;\n      this.specializers[i] = spec.specialized[i].get;\n    }\n    this.states = decodeArray(spec.states, Uint32Array);\n    this.data = decodeArray(spec.stateData);\n    this.goto = decodeArray(spec.goto);\n    let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n    this.nodeSet = new lezer_tree_1.NodeSet(nodeNames.map((name, i) => lezer_tree_1.NodeType.define({\n      name: i >= this.minRepeatTerm ? undefined : name,\n      id: i,\n      props: nodeProps[i],\n      top: topTerms.indexOf(i) > -1,\n      error: i == 0,\n      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n    })));\n    this.maxTerm = spec.maxTerm;\n    this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n    this.topRules = spec.topRules;\n    this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {\n      return {\n        name,\n        value,\n        end: new TokenGroup(decodeArray(endToken), 0),\n        placeholder\n      };\n    });\n    this.dialects = spec.dialects || ({});\n    this.dynamicPrecedences = spec.dynamicPrecedences || null;\n    this.tokenPrecTable = spec.tokenPrec;\n    this.termNames = spec.termNames || null;\n    this.maxNode = this.nodeSet.types.length - 1;\n    this.dialect = this.parseDialect();\n    this.top = this.topRules[Object.keys(this.topRules)[0]];\n  }\n  parse(input, startPos = 0, context = {}) {\n    if (typeof input == \"string\") input = lezer_tree_1.stringInput(input);\n    let cx = new Parse(this, input, startPos, context);\n    for (; ; ) {\n      let done = cx.advance();\n      if (done) return done;\n    }\n  }\n  startParse(input, startPos = 0, context = {}) {\n    if (typeof input == \"string\") input = lezer_tree_1.stringInput(input);\n    return new Parse(this, input, startPos, context);\n  }\n  getGoto(state, term, loose = false) {\n    let table = this.goto;\n    if (term >= table[0]) return -1;\n    for (let pos = table[term + 1]; ; ) {\n      let groupTag = table[pos++], last = groupTag & 1;\n      let target = table[pos++];\n      if (last && loose) return target;\n      for (let end = pos + (groupTag >> 1); pos < end; pos++) if (table[pos] == state) return target;\n      if (last) return -1;\n    }\n  }\n  hasAction(state, terminal) {\n    let data = this.data;\n    for (let set = 0; set < 2; set++) {\n      for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {\n        if ((next = data[i]) == 65535) {\n          if (data[i + 1] == 1) next = data[i = pair(data, i + 2)]; else if (data[i + 1] == 2) return pair(data, i + 2); else break;\n        }\n        if (next == terminal || next == 0) return pair(data, i + 1);\n      }\n    }\n    return 0;\n  }\n  stateSlot(state, slot) {\n    return this.states[state * 6 + slot];\n  }\n  stateFlag(state, flag) {\n    return (this.stateSlot(state, 0) & flag) > 0;\n  }\n  findNested(state) {\n    let flags = this.stateSlot(state, 0);\n    return flags & 4 ? this.nested[flags >> 10] : null;\n  }\n  validAction(state, action) {\n    if (action == this.stateSlot(state, 4)) return true;\n    for (let i = this.stateSlot(state, 1); ; i += 3) {\n      if (this.data[i] == 65535) {\n        if (this.data[i + 1] == 1) i = pair(this.data, i + 2); else return false;\n      }\n      if (action == pair(this.data, i + 1)) return true;\n    }\n  }\n  nextStates(state) {\n    let result = [];\n    for (let i = this.stateSlot(state, 1); ; i += 3) {\n      if (this.data[i] == 65535) {\n        if (this.data[i + 1] == 1) i = pair(this.data, i + 2); else break;\n      }\n      if ((this.data[i + 2] & 65536 >> 16) == 0) {\n        let value = this.data[i + 1];\n        if (!result.some((v, i) => i & 1 && v == value)) result.push(this.data[i], value);\n      }\n    }\n    return result;\n  }\n  overrides(token, prev) {\n    let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n  }\n  configure(config) {\n    let copy = Object.assign(Object.create(Parser.prototype), this);\n    if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props);\n    if (config.top) {\n      let info = this.topRules[config.top];\n      if (!info) throw new RangeError(`Invalid top rule name ${config.top}`);\n      copy.top = info;\n    }\n    if (config.tokenizers) copy.tokenizers = this.tokenizers.map(t => {\n      let found = config.tokenizers.find(r => r.from == t);\n      return found ? found.to : t;\n    });\n    if (config.dialect) copy.dialect = this.parseDialect(config.dialect);\n    if (config.nested) copy.nested = this.nested.map(obj => {\n      if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name)) return obj;\n      return {\n        name: obj.name,\n        value: config.nested[obj.name],\n        end: obj.end,\n        placeholder: obj.placeholder\n      };\n    });\n    if (config.strict != null) copy.strict = config.strict;\n    if (config.bufferLength != null) copy.bufferLength = config.bufferLength;\n    return copy;\n  }\n  getName(term) {\n    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n  }\n  get eofTerm() {\n    return this.maxNode + 1;\n  }\n  get hasNested() {\n    return this.nested.length > 0;\n  }\n  get topNode() {\n    return this.nodeSet.types[this.top[1]];\n  }\n  dynamicPrecedence(term) {\n    let prec = this.dynamicPrecedences;\n    return prec == null ? 0 : prec[term] || 0;\n  }\n  parseDialect(dialect) {\n    if (this.cachedDialect && this.cachedDialect.source == dialect) return this.cachedDialect;\n    let values = Object.keys(this.dialects), flags = values.map(() => false);\n    if (dialect) for (let part of dialect.split(\" \")) {\n      let id = values.indexOf(part);\n      if (id >= 0) flags[id] = true;\n    }\n    let disabled = null;\n    for (let i = 0; i < values.length; i++) if (!flags[i]) {\n      for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535; ) (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n    }\n    return this.cachedDialect = new Dialect(dialect, flags, disabled);\n  }\n  static deserialize(spec) {\n    return new Parser(spec);\n  }\n}\nfunction pair(data, off) {\n  return data[off] | data[off + 1] << 16;\n}\nfunction findOffset(data, start, term) {\n  for (let i = start, next; (next = data[i]) != 65535; i++) if (next == term) return i - start;\n  return -1;\n}\nfunction findFinished(stacks) {\n  let best = null;\n  for (let stack of stacks) {\n    if (stack.pos == stack.p.input.length && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score)) best = stack;\n  }\n  return best;\n}\nexports.ContextTracker = ContextTracker;\nexports.ExternalTokenizer = ExternalTokenizer;\nexports.Parser = Parser;\nexports.Stack = Stack;\nexports.Token = Token;\n"}