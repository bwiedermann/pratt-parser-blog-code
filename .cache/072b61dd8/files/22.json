{"contents":"exports.__esModule = true;\nvar parselet_1 = __fusereq(39);\nvar tokenstream_1 = __fusereq(40);\nvar position_1 = __fusereq(41);\nfunction parse(text, varMap, registeredNodes, dependsMap) {\n  const nodes = [];\n  const tokens = new tokenstream_1.TokenStream(text);\n  const parser = new Parser();\n  while (tokens.peek()) {\n    try {\n      nodes.push(parser.parse(tokens, 0, varMap, registeredNodes, dependsMap));\n    } catch (e) {\n      return {\n        nodes,\n        errors: [e]\n      };\n    }\n  }\n  return {\n    nodes,\n    errors: []\n  };\n}\nexports.parse = parse;\nclass AbstractParser {\n  constructor() {\n    this.bindingPowers = {};\n    const bindingClasses = this.bindingClasses();\n    for (let i = 0; i < bindingClasses.length; i++) {\n      for (const tokenType of bindingClasses[i]) {\n        this.bindingPowers[tokenType] = 10 * i + 9;\n      }\n    }\n    for (const tokenType of Object.keys(this.consequentMap)) {\n      if (this.bindingPowers[tokenType] == undefined) {\n        throw new Error(`Token ${tokenType} defined in consequentMap has no associated binding power.\r\n          Make sure it is also listed in bindingClasses.`);\n      }\n    }\n  }\n  bindingPower(token) {\n    if (this.bindingPowers[token.type] != undefined) {\n      return this.bindingPowers[token.type];\n    } else {\n      throw new position_1.ParseError(`Unexpected token type ${token.type}.`, position_1.token2pos(token));\n    }\n  }\n  parse(tokens, currentBindingPower, varMap, registeredNodes, dependsMap) {\n    const token = tokens.consume();\n    if (!token) {\n      throw new position_1.ParseError(`Unexpected end of tokens.`, position_1.token2pos(tokens.last()));\n    }\n    const initialParselet = this.initialMap()[token.type];\n    if (!initialParselet) {\n      throw new position_1.ParseError(`Unexpected token type ${token.type}`, position_1.token2pos(token));\n    }\n    let left = initialParselet.parse(this, tokens, token, varMap, registeredNodes, dependsMap);\n    while (true) {\n      const next = tokens.peek();\n      if (!next) {\n        break;\n      }\n      const consequentParselet = this.consequentMap()[next.type];\n      if (!consequentParselet) {\n        break;\n      }\n      if (currentBindingPower >= this.bindingPower(next)) {\n        break;\n      }\n      tokens.consume();\n      left = consequentParselet.parse(this, tokens, left, next, varMap, registeredNodes, dependsMap);\n    }\n    return left;\n  }\n}\nexports.AbstractParser = AbstractParser;\nclass Parser extends AbstractParser {\n  initialMap() {\n    return {\n      NUMBER: new parselet_1.NumberParselet(),\n      TRUE: new parselet_1.BooleanParselet(true),\n      FALSE: new parselet_1.BooleanParselet(false),\n      '(': new parselet_1.ParenParselet(),\n      '[': new parselet_1.BracketParselet(),\n      FUNCTION: new parselet_1.FunctionParselet(),\n      CHOOSE1: new parselet_1.ChooseParselet(),\n      IDENTIFIER: new parselet_1.IdentifierParselet()\n    };\n  }\n  consequentMap() {\n    return {\n      '+': new parselet_1.BinaryOperatorParselet('+', 'left'),\n      '-': new parselet_1.BinaryOperatorParselet('-', 'left'),\n      '*': new parselet_1.BinaryOperatorParselet('*', 'left'),\n      '/': new parselet_1.BinaryOperatorParselet('/', 'left'),\n      '|': new parselet_1.BinaryOperatorParselet('|', 'right'),\n      '&': new parselet_1.BinaryOperatorParselet('&', 'right')\n    };\n  }\n  bindingClasses() {\n    const classes = [['+', '-'], ['*', '/'], ['|', '&']];\n    return classes;\n  }\n}\nexports.Parser = Parser;\n","sourceMap":"{\"version\":3,\"sources\":[\"src/parser.ts\"],\"names\":[\"text\",\"varMap\",\"registeredNodes\",\"dependsMap\",\"nodes\",\"tokens\",\"tokenstream_1\",\"parser\",\"Parser\",\"peek\",\"push\",\"parse\",\"e\",\"errors\",\"constructor\",\"bindingPowers\",\"bindingClasses\",\"i\",\"length\",\"tokenType\",\"Object\",\"keys\",\"consequentMap\",\"undefined\",\"Error\",\"bindingPower\",\"token\",\"type\",\"position_1\",\"currentBindingPower\",\"consume\",\"last\",\"initialParselet\",\"initialMap\",\"left\",\"next\",\"consequentParselet\",\"AbstractParser\",\"NUMBER\",\"NumberParselet\",\"TRUE\",\"BooleanParselet\",\"FALSE\",\"ParenParselet\",\"BracketParselet\",\"FUNCTION\",\"FunctionParselet\",\"CHOOSE1\",\"ChooseParselet\",\"IDENTIFIER\",\"IdentifierParselet\",\"BinaryOperatorParselet\",\"classes\"],\"mappings\":\";;;;AAMO,eAAeA,MACAC,QACAC,iBACAC;QAEdC;QAEAC,aAAaC,0BAAYN;QACzBO,aAAaC;SACZH,OAAOI;;MAEVL,MAAMM,KAAKH,OAAOI,MAAMN,QAAQ,GAAGJ,QAAQC,iBAAiBC;aACrDS;;QAELR;QACAS,SAASD;;;;;IAKPR;IAAOS;;;;AAGV;EAWLC;IACE,KAAKC;UAECC,iBAAiB,KAAKA;aACnBC,IAAI,GAAGA,IAAID,eAAeE,QAAQD;iBAC9BE,aAAaH,eAAeC;QACrC,KAAKF,cAAcI,aAAa,KAAKF,IAAI;;;eAIlCE,aAAaC,OAAOC,KAAK,KAAKC;UACnC,KAAKP,cAAcI,cAAcI;kBACzBC,eACCL;;;;;EAOjBM,aAAaC;QACP,KAAKX,cAAcW,MAAMC,SAASJ;aAC7B,KAAKR,cAAcW,MAAMC;;gBAEtBC,+CACiBF,MAAMC,SAC/BC,qBAAUF;;;EAKhBf,MAAMN,QACAwB,qBACA5B,QACAC,iBACAC;UACEuB,QAAQrB,OAAOyB;SAChBJ;gBACOE,mDAERA,qBAAUvB,OAAO0B;;UAIfC,kBAAkB,KAAKC,aAAaP,MAAMC;SAE3CK;gBACOJ,+CACiBF,MAAMC,QAC/BC,qBAAUF;;QAIVQ,OAAOF,gBAAgBrB,MAAM,MAAMN,QAAQqB,OAAOzB,QAAQC,iBAAiBC;WAExE;YACCgC,OAAO9B,OAAOI;WACf0B;;;YAICC,qBAAqB,KAAKd,gBAAgBa,KAAKR;WAEhDS;;;UAIDP,uBAAuB,KAAKJ,aAAaU;;;MAI7C9B,OAAOyB;MACPI,OAAOE,mBAAmBzB,MAAM,MAAMN,QAAQ6B,MAAMC,MAAMlC,QAAQC,iBAAiBC;;WAG9E+B;;;;AAIJ,qBAAqBG;EAC1BJ;;MAEIK,uBAAqBC;MACrBC,qBAAmBC,gBAAgB;MACnCC,sBAAoBD,gBAAgB;MACpC,oBAAkBE;MAClB,oBAAkBC;MAClBC,yBAAuBC;MACvBC,wBAAsBC;MACtBC,2BAAyBC;;;EAI7B5B;;MAEI,oBAAkB6B,uBAAuB,KAAK;MAC9C,oBAAkBA,uBAAuB,KAAK;MAC9C,oBAAkBA,uBAAuB,KAAK;MAC9C,oBAAkBA,uBAAuB,KAAK;MAC9C,oBAAkBA,uBAAuB,KAAK;MAC9C,oBAAkBA,uBAAuB,KAAK;;;EAIlDnC;UACQoC,YAA2B,KAAK,OAAO,KAAK,OAAO,KAAK;WACvDA\",\"sourcesContent\":[\"import * as Parselet from './parselet';\\r\\nimport {Token, TokenType} from './lexer';\\r\\nimport {TokenStream} from './tokenstream';\\r\\nimport {ParseError, token2pos} from './position';\\r\\nimport * as AST from './ast';\\r\\n\\r\\nexport function parse(text: string,\\r\\n                      varMap: {[key: string]: string},\\r\\n                      registeredNodes: {[key: string]: AST.Node},\\r\\n                      dependsMap: {[key: string]: string[]}): \\r\\n                      {nodes: AST.Node[]; errors: ParseError[]} {\\r\\n  const nodes: AST.Node[] = [];\\r\\n\\r\\n  const tokens = new TokenStream(text);\\r\\n  const parser = new Parser();\\r\\n  while (tokens.peek()) {\\r\\n    try {\\r\\n      nodes.push(parser.parse(tokens, 0, varMap, registeredNodes, dependsMap));\\r\\n    } catch (e) {\\r\\n      return {\\r\\n        nodes,\\r\\n        errors: [e],\\r\\n      };\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {nodes, errors: []};\\r\\n}\\r\\n\\r\\nexport abstract class AbstractParser {\\r\\n  public bindingPowers: {[tokenType in TokenType]: number};\\r\\n\\r\\n  protected abstract initialMap(): Partial<\\r\\n    {[K in TokenType]: Parselet.InitialParselet}\\r\\n  >;\\r\\n  protected abstract consequentMap(): Partial<\\r\\n    {[K in TokenType]: Parselet.ConsequentParselet}\\r\\n  >;\\r\\n  protected abstract bindingClasses(): TokenType[][];\\r\\n\\r\\n  constructor() {\\r\\n    this.bindingPowers = {} as any;\\r\\n\\r\\n    const bindingClasses = this.bindingClasses();\\r\\n    for (let i = 0; i < bindingClasses.length; i++) {\\r\\n      for (const tokenType of bindingClasses[i]) {\\r\\n        this.bindingPowers[tokenType] = 10 * i + 9;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    for (const tokenType of Object.keys(this.consequentMap) as TokenType[]) {\\r\\n      if (this.bindingPowers[tokenType] == undefined) {\\r\\n        throw new Error(\\r\\n          `Token ${tokenType} defined in consequentMap has no associated binding power.\\r\\n          Make sure it is also listed in bindingClasses.`,\\r\\n        );\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  bindingPower(token: Token): number {\\r\\n    if (this.bindingPowers[token.type] != undefined) {\\r\\n      return this.bindingPowers[token.type];\\r\\n    } else {\\r\\n      throw new ParseError(\\r\\n        `Unexpected token type ${token.type}.`,\\r\\n        token2pos(token),\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  parse(tokens: TokenStream,\\r\\n        currentBindingPower: number,\\r\\n        varMap: {[key: string]: string},\\r\\n        registeredNodes: {[key: string]: AST.Node},\\r\\n        dependsMap: {[key: string]: string[]}): AST.Node {\\r\\n    const token = tokens.consume();\\r\\n    if (!token) {\\r\\n      throw new ParseError(\\r\\n        `Unexpected end of tokens.`,\\r\\n        token2pos(tokens.last()),\\r\\n      );\\r\\n    }\\r\\n\\r\\n    const initialParselet = this.initialMap()[token.type];\\r\\n\\r\\n    if (!initialParselet) {\\r\\n      throw new ParseError(\\r\\n        `Unexpected token type ${token.type}`,\\r\\n        token2pos(token),\\r\\n      );\\r\\n    }\\r\\n\\r\\n    let left = initialParselet.parse(this, tokens, token, varMap, registeredNodes, dependsMap);\\r\\n\\r\\n    while (true) {\\r\\n      const next = tokens.peek();\\r\\n      if (!next) {\\r\\n        break;\\r\\n      }\\r\\n\\r\\n      const consequentParselet = this.consequentMap()[next.type];\\r\\n\\r\\n      if (!consequentParselet) {\\r\\n        break;\\r\\n      }\\r\\n\\r\\n      if (currentBindingPower >= this.bindingPower(next)) {\\r\\n        break;\\r\\n      }\\r\\n\\r\\n      tokens.consume();\\r\\n      left = consequentParselet.parse(this, tokens, left, next, varMap, registeredNodes, dependsMap);\\r\\n    }\\r\\n\\r\\n    return left;\\r\\n  }\\r\\n}\\r\\n\\r\\nexport class Parser extends AbstractParser {\\r\\n  initialMap() {\\r\\n    return {\\r\\n      NUMBER: new Parselet.NumberParselet(),\\r\\n      TRUE: new Parselet.BooleanParselet(true),\\r\\n      FALSE: new Parselet.BooleanParselet(false),\\r\\n      '(': new Parselet.ParenParselet(),\\r\\n      '[': new Parselet.BracketParselet(),\\r\\n      FUNCTION: new Parselet.FunctionParselet(),\\r\\n      CHOOSE1: new Parselet.ChooseParselet(),\\r\\n      IDENTIFIER: new Parselet.IdentifierParselet()\\r\\n    };\\r\\n  }\\r\\n\\r\\n  consequentMap() {\\r\\n    return {\\r\\n      '+': new Parselet.BinaryOperatorParselet('+', 'left'),\\r\\n      '-': new Parselet.BinaryOperatorParselet('-', 'left'),\\r\\n      '*': new Parselet.BinaryOperatorParselet('*', 'left'),\\r\\n      '/': new Parselet.BinaryOperatorParselet('/', 'left'),\\r\\n      '|': new Parselet.BinaryOperatorParselet('|', 'right'),\\r\\n      '&': new Parselet.BinaryOperatorParselet('&', 'right')\\r\\n    };\\r\\n  }\\r\\n\\r\\n  bindingClasses() {\\r\\n    const classes: TokenType[][] = [['+', '-'], ['*', '/'], ['|', '&']];\\r\\n    return classes;\\r\\n  }\\r\\n}\\r\\n\"]}"}