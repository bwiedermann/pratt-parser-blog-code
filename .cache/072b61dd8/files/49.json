{"contents":"function findBases(node, dependsMap) {\n  return baseMap[node.nodeType].findBase(node, dependsMap);\n}\nexports.findBases = findBases;\nclass BaseNumber {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseBoolean {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseBinary {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    let leftList = findBases(node.left, dependsMap);\n    baseList = baseList.concat(leftList);\n    let rightList = findBases(node.right, dependsMap);\n    baseList = baseList.concat(rightList);\n    return baseList;\n  }\n}\nclass BaseFunction {\n  findBase(node, dependsMap) {\n    console.log(\"in base function\");\n    let baseList = [];\n    if (node.name == \"Input\") {\n      baseList.push(node.nodeId);\n    } else {\n      for (let i = 0; i < node.args.length; i++) {\n        baseList = baseList.concat(findBases(node.args[i], dependsMap));\n      }\n    }\n    return baseList;\n  }\n}\nclass BaseChoose {\n  findBase(node, dependsMap) {\n    let baseList = [];\n    let consBases = findBases(node.case.consequent, dependsMap);\n    baseList = baseList.concat(consBases);\n    let otherBases = findBases(node.otherwise, dependsMap);\n    baseList = baseList.concat(otherBases);\n    return baseList;\n  }\n}\nclass BaseVariableAssignment {\n  findBase(node) {\n    return [];\n  }\n}\nclass BaseIdentifier {\n  findBase(node, dependsMap) {\n    return dependsMap[node.assignmentId];\n  }\n}\nclass BaseIterator {\n  findBase(node) {\n    return [];\n  }\n}\nconst baseMap = {\n  'Number': new BaseNumber(),\n  'Boolean': new BaseBoolean(),\n  'BinaryOperation': new BaseBinary(),\n  'Function': new BaseFunction(),\n  'Choose': new BaseChoose(),\n  'VariableAssignment': new BaseVariableAssignment(),\n  'Identifier': new BaseIdentifier(),\n  'Iterator': new BaseIterator()\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/findBase.ts\"],\"names\":[\"node\",\"dependsMap\",\"baseMap\",\"nodeType\",\"findBase\",\"baseList\",\"leftList\",\"findBases\",\"left\",\"concat\",\"rightList\",\"right\",\"console\",\"log\",\"name\",\"push\",\"nodeId\",\"i\",\"args\",\"length\",\"consBases\",\"case\",\"consequent\",\"otherBases\",\"otherwise\",\"assignmentId\",\"BaseNumber\",\"BaseBoolean\",\"BaseBinary\",\"BaseFunction\",\"BaseChoose\",\"BaseVariableAssignment\",\"BaseIdentifier\",\"BaseIterator\"],\"mappings\":\"AAEO,mBAAmBA,MAAgBC;SAC/BC,QAAQF,KAAKG,UAAUC,SAASJ,MAAMC;;;AAOjD;EACEG,SAASJ;;;;AAKX;EACII,SAASJ;;;;AAKb;EACII,SAASJ,MAA+BC;QAChCI;QAEAC,WAAWC,UAAUP,KAAKQ,MAAMP;IACpCI,WAAWA,SAASI,OAAOH;QACvBI,YAAYH,UAAUP,KAAKW,OAAOV;IACtCI,WAAWA,SAASI,OAAOC;WACpBL;;;AAMf;EACID,SAASJ,MAAwBC;IAC7BW,QAAQC,IAAI;QACRR;QACAL,KAAKc,QAAQ;MAEbT,SAASU,KAAKf,KAAKgB;;eAIVC,IAAI,GAAGA,IAAIjB,KAAKkB,KAAKC,QAAQF;QAClCZ,WAAWA,SAASI,OAAOF,UAAUP,KAAKkB,KAAKD,IAAIhB;;;WAGpDI;;;AAMf;EACID,SAASJ,MAAsBC;QACvBI;QAEAe,YAAYb,UAAUP,KAAKqB,KAAKC,YAAYrB;IAChDI,WAAWA,SAASI,OAAOW;QACvBG,aAAahB,UAAUP,KAAKwB,WAAWvB;IAC3CI,WAAWA,SAASI,OAAOc;WACpBlB;;;AAIf;EACID,SAASJ;;;;AAKb;EACII,SAASJ,MAA0BC;WAExBA,WAAWD,KAAKyB;;;AAI/B;EACIrB,SAASJ;;;;MAMPE;EACJ,cAAewB;EACf,eAAgBC;EAChB,uBAAwBC;EACxB,gBAAiBC;EACjB,cAAcC;EACd,0BAA0BC;EAC1B,kBAAkBC;EAClB,gBAAgBC\",\"sourcesContent\":[\"import * as AST from './ast';\\r\\n\\r\\nexport function findBases(node: AST.Node, dependsMap: {[key: string]: string[]}): string[] {\\r\\n    return baseMap[node.nodeType].findBase(node, dependsMap); \\r\\n}\\r\\n\\r\\nexport interface BaseFinder {\\r\\n  findBase(node: AST.Node, dependsMap: {[key: string]: string[]}): string[];\\r\\n}\\r\\n\\r\\nclass BaseNumber implements BaseFinder {\\r\\n  findBase(node: AST.NumberNode): string[] {\\r\\n    return []\\r\\n  }\\r\\n}\\r\\n\\r\\nclass BaseBoolean implements BaseFinder {\\r\\n    findBase(node: AST.BooleanNode): string[] {\\r\\n        return []\\r\\n    }\\r\\n}\\r\\n\\r\\nclass BaseBinary implements BaseFinder {\\r\\n    findBase(node: AST.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\\r\\n        let baseList: string[] = [];\\r\\n        // recursively call findBases on left and right\\r\\n        let leftList = findBases(node.left, dependsMap);\\r\\n        baseList = baseList.concat(leftList);\\r\\n        let rightList = findBases(node.right, dependsMap)\\r\\n        baseList = baseList.concat(rightList);\\r\\n        return baseList;\\r\\n    }\\r\\n}\\r\\n\\r\\n// examples: x = Input(3); x = IsDefined(Input(3)); z = Inverse(x)\\r\\n// need dependsMap for the third example\\r\\nclass BaseFunction implements BaseFinder {\\r\\n    findBase(node: AST.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\\r\\n        console.log(\\\"in base function\\\");\\r\\n        let baseList: string[] = [];\\r\\n        if (node.name == \\\"Input\\\") {\\r\\n            // this is a base\\r\\n            baseList.push(node.nodeId);\\r\\n        }\\r\\n        else {\\r\\n            // recursively call findBases on argument(s)\\r\\n            for (let i = 0; i < node.args.length; i++) {\\r\\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\\r\\n            }\\r\\n        }\\r\\n        return baseList;\\r\\n    }\\r\\n}\\r\\n\\r\\n// assume that choose nodes will never create their own bases\\r\\n// they can still error check previously defined bases\\r\\nclass BaseChoose implements BaseFinder {\\r\\n    findBase(node: AST.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\\r\\n        let baseList: string[] = [];\\r\\n        // the bases of the cons and the otherwise\\r\\n        letÂ consBases = findBases(node.case.consequent, dependsMap);\\r\\n        baseList = baseList.concat(consBases);\\r\\n        let otherBases = findBases(node.otherwise, dependsMap);\\r\\n        baseList = baseList.concat(otherBases);\\r\\n        return baseList;\\r\\n    }\\r\\n}\\r\\n\\r\\nclass BaseVariableAssignment implements BaseFinder {\\r\\n    findBase(node: AST.VariableAssignmentNode): string[] {\\r\\n        return []\\r\\n    }\\r\\n}\\r\\n\\r\\nclass BaseIdentifier implements BaseFinder {\\r\\n    findBase(node: AST.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\\r\\n        // follow the chain in the dependsMap\\r\\n        return dependsMap[node.assignmentId];\\r\\n    }\\r\\n}\\r\\n\\r\\nclass BaseIterator implements BaseFinder {\\r\\n    findBase(node: AST.IteratorNode): string[] {\\r\\n        return []\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\\r\\n  'Number' : new BaseNumber(),\\r\\n  'Boolean' : new BaseBoolean(),\\r\\n  'BinaryOperation' : new BaseBinary(),\\r\\n  'Function' : new BaseFunction(),\\r\\n  'Choose': new BaseChoose(),\\r\\n  'VariableAssignment': new BaseVariableAssignment(),\\r\\n  'Identifier': new BaseIdentifier(),\\r\\n  'Iterator': new BaseIterator()\\r\\n}\\r\\n\"]}"}