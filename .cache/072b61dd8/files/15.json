{"contents":"exports.__esModule = true;\nvar text_1 = __fusereq(26);\nvar text_2 = __fusereq(26);\nexports.Text = text_2.Text;\nconst DefaultSplit = /\\r\\n?|\\n/;\nvar MapMode;\n(function (MapMode) {\n  MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n  MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n  MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n  MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n})(MapMode || (MapMode = {}));\nclass ChangeDesc {\n  constructor(sections) {\n    this.sections = sections;\n  }\n  get length() {\n    let result = 0;\n    for (let i = 0; i < this.sections.length; i += 2) result += this.sections[i];\n    return result;\n  }\n  get newLength() {\n    let result = 0;\n    for (let i = 0; i < this.sections.length; i += 2) {\n      let ins = this.sections[i + 1];\n      result += ins < 0 ? this.sections[i] : ins;\n    }\n    return result;\n  }\n  get empty() {\n    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;\n  }\n  iterGaps(f) {\n    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {\n      let len = this.sections[i++], ins = this.sections[i++];\n      if (ins < 0) {\n        f(posA, posB, len);\n        posB += len;\n      } else {\n        posB += ins;\n      }\n      posA += len;\n    }\n  }\n  iterChangedRanges(f, individual = false) {\n    iterChanges(this, f, individual);\n  }\n  get invertedDesc() {\n    let sections = [];\n    for (let i = 0; i < this.sections.length; ) {\n      let len = this.sections[i++], ins = this.sections[i++];\n      if (ins < 0) sections.push(len, ins); else sections.push(ins, len);\n    }\n    return new ChangeDesc(sections);\n  }\n  composeDesc(other) {\n    return this.empty ? other : other.empty ? this : composeSets(this, other);\n  }\n  mapDesc(other, before = false) {\n    return other.empty ? this : mapSet(this, other, before);\n  }\n  mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n    let posA = 0, posB = 0;\n    for (let i = 0; i < this.sections.length; ) {\n      let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n      if (ins < 0) {\n        if (endA > pos) return posB + (pos - posA);\n        posB += len;\n      } else {\n        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;\n        if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;\n        posB += ins;\n      }\n      posA = endA;\n    }\n    if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n    return posB;\n  }\n  touchesRange(from, to = from) {\n    for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {\n      let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n      if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? \"cover\" : true;\n      pos = end;\n    }\n    return false;\n  }\n  toString() {\n    let result = \"\";\n    for (let i = 0; i < this.sections.length; ) {\n      let len = this.sections[i++], ins = this.sections[i++];\n      result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n    }\n    return result;\n  }\n}\nclass ChangeSet extends ChangeDesc {\n  constructor(sections, inserted) {\n    super(sections);\n    this.inserted = inserted;\n  }\n  apply(doc) {\n    if (this.length != doc.length) throw new RangeError(\"Applying change set to a document with the wrong length\");\n    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n    return doc;\n  }\n  mapDesc(other, before = false) {\n    return mapSet(this, other, before, true);\n  }\n  invert(doc) {\n    let sections = this.sections.slice(), inserted = [];\n    for (let i = 0, pos = 0; i < sections.length; i += 2) {\n      let len = sections[i], ins = sections[i + 1];\n      if (ins >= 0) {\n        sections[i] = ins;\n        sections[i + 1] = len;\n        let index = i >> 1;\n        while (inserted.length < index) inserted.push(text_1.Text.empty);\n        inserted.push(len ? doc.slice(pos, pos + len) : text_1.Text.empty);\n      }\n      pos += len;\n    }\n    return new ChangeSet(sections, inserted);\n  }\n  compose(other) {\n    return this.empty ? other : other.empty ? this : composeSets(this, other, true);\n  }\n  map(other, before = false) {\n    return other.empty ? this : mapSet(this, other, before, true);\n  }\n  iterChanges(f, individual = false) {\n    iterChanges(this, f, individual);\n  }\n  get desc() {\n    return new ChangeDesc(this.sections);\n  }\n  filter(ranges) {\n    let resultSections = [], resultInserted = [], filteredSections = [];\n    let iter = new SectionIter(this);\n    done: for (let i = 0, pos = 0; ; ) {\n      let next = i == ranges.length ? 1e9 : ranges[i++];\n      while (pos < next || pos == next && iter.len == 0) {\n        if (iter.done) break done;\n        let len = Math.min(iter.len, next - pos);\n        addSection(filteredSections, len, -1);\n        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n        addSection(resultSections, len, ins);\n        if (ins > 0) addInsert(resultInserted, resultSections, iter.text);\n        iter.forward(len);\n        pos += len;\n      }\n      let end = ranges[i++];\n      while (pos < end) {\n        if (iter.done) break done;\n        let len = Math.min(iter.len, end - pos);\n        addSection(resultSections, len, -1);\n        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n        iter.forward(len);\n        pos += len;\n      }\n    }\n    return {\n      changes: new ChangeSet(resultSections, resultInserted),\n      filtered: new ChangeDesc(filteredSections)\n    };\n  }\n  toJSON() {\n    let parts = [];\n    for (let i = 0; i < this.sections.length; i += 2) {\n      let len = this.sections[i], ins = this.sections[i + 1];\n      if (ins < 0) parts.push(len); else if (ins == 0) parts.push([len]); else parts.push([len].concat(this.inserted[i >> 1].toJSON()));\n    }\n    return parts;\n  }\n  static of(changes, length, lineSep) {\n    let sections = [], inserted = [], pos = 0;\n    let total = null;\n    function flush(force = false) {\n      if (!force && !sections.length) return;\n      if (pos < length) addSection(sections, length - pos, -1);\n      let set = new ChangeSet(sections, inserted);\n      total = total ? total.compose(set.map(total)) : set;\n      sections = [];\n      inserted = [];\n      pos = 0;\n    }\n    function process(spec) {\n      if (Array.isArray(spec)) {\n        for (let sub of spec) process(sub);\n      } else if (spec instanceof ChangeSet) {\n        if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n        flush();\n        total = total ? total.compose(spec.map(total)) : spec;\n      } else {\n        let {from, to = from, insert} = spec;\n        if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n        let insText = !insert ? text_1.Text.empty : typeof insert == \"string\" ? text_1.Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n        let insLen = insText.length;\n        if (from == to && insLen == 0) return;\n        if (from < pos) flush();\n        if (from > pos) addSection(sections, from - pos, -1);\n        addSection(sections, to - from, insLen);\n        addInsert(inserted, sections, insText);\n        pos = to;\n      }\n    }\n    process(changes);\n    flush(!total);\n    return total;\n  }\n  static empty(length) {\n    return new ChangeSet(length ? [length, -1] : [], []);\n  }\n  static fromJSON(json) {\n    if (!Array.isArray(json)) throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n    let sections = [], inserted = [];\n    for (let i = 0; i < json.length; i++) {\n      let part = json[i];\n      if (typeof part == \"number\") {\n        sections.push(part, -1);\n      } else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i) => i && typeof e != \"string\")) {\n        throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n      } else if (part.length == 1) {\n        sections.push(part[0], 0);\n      } else {\n        while (inserted.length < i) inserted.push(text_1.Text.empty);\n        inserted[i] = text_1.Text.of(part.slice(1));\n        sections.push(part[0], inserted[i].length);\n      }\n    }\n    return new ChangeSet(sections, inserted);\n  }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n  if (len == 0 && ins <= 0) return;\n  let last = sections.length - 2;\n  if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len; else if (len == 0 && sections[last] == 0) sections[last + 1] += ins; else if (forceJoin) {\n    sections[last] += len;\n    sections[last + 1] += ins;\n  } else sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n  if (value.length == 0) return;\n  let index = sections.length - 2 >> 1;\n  if (index < values.length) {\n    values[values.length - 1] = values[values.length - 1].append(value);\n  } else {\n    while (values.length < index) values.push(text_1.Text.empty);\n    values.push(value);\n  }\n}\nfunction iterChanges(desc, f, individual) {\n  let inserted = desc.inserted;\n  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {\n    let len = desc.sections[i++], ins = desc.sections[i++];\n    if (ins < 0) {\n      posA += len;\n      posB += len;\n    } else {\n      let endA = posA, endB = posB, text = text_1.Text.empty;\n      for (; ; ) {\n        endA += len;\n        endB += ins;\n        if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);\n        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;\n        len = desc.sections[i++];\n        ins = desc.sections[i++];\n      }\n      f(posA, endA, posB, endB, text);\n      posA = endA;\n      posB = endB;\n    }\n  }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n  let sections = [], insert = mkSet ? [] : null;\n  let a = new SectionIter(setA), b = new SectionIter(setB);\n  for (let posA = 0, posB = 0; ; ) {\n    if (a.ins == -1) {\n      posA += a.len;\n      a.next();\n    } else if (b.ins == -1 && posB < posA) {\n      let skip = Math.min(b.len, posA - posB);\n      b.forward(skip);\n      addSection(sections, skip, -1);\n      posB += skip;\n    } else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {\n      addSection(sections, b.ins, -1);\n      while (posA > posB && !a.done && posA + a.len < posB + b.len) {\n        posA += a.len;\n        a.next();\n      }\n      posB += b.len;\n      b.next();\n    } else if (a.ins >= 0) {\n      let len = 0, end = posA + a.len;\n      for (; ; ) {\n        if (b.ins >= 0 && posB > posA && posB + b.len < end) {\n          len += b.ins;\n          posB += b.len;\n          b.next();\n        } else if (b.ins == -1 && posB < end) {\n          let skip = Math.min(b.len, end - posB);\n          len += skip;\n          b.forward(skip);\n          posB += skip;\n        } else {\n          break;\n        }\n      }\n      addSection(sections, len, a.ins);\n      if (insert) addInsert(insert, sections, a.text);\n      posA = end;\n      a.next();\n    } else if (a.done && b.done) {\n      return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);\n    } else {\n      throw new Error(\"Mismatched change set lengths\");\n    }\n  }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n  let sections = [];\n  let insert = mkSet ? [] : null;\n  let a = new SectionIter(setA), b = new SectionIter(setB);\n  for (let open = false; ; ) {\n    if (a.done && b.done) {\n      return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);\n    } else if (a.ins == 0) {\n      addSection(sections, a.len, 0, open);\n      a.next();\n    } else if (b.len == 0 && !b.done) {\n      addSection(sections, 0, b.ins, open);\n      if (insert) addInsert(insert, sections, b.text);\n      b.next();\n    } else if (a.done || b.done) {\n      throw new Error(\"Mismatched change set lengths\");\n    } else {\n      let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n      if (a.ins == -1) {\n        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n        addSection(sections, len, insB, open);\n        if (insert && insB) addInsert(insert, sections, b.text);\n      } else if (b.ins == -1) {\n        addSection(sections, a.off ? 0 : a.len, len, open);\n        if (insert) addInsert(insert, sections, a.textBit(len));\n      } else {\n        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n        if (insert && !b.off) addInsert(insert, sections, b.text);\n      }\n      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n      a.forward2(len);\n      b.forward(len);\n    }\n  }\n}\nclass SectionIter {\n  constructor(set) {\n    this.set = set;\n    this.i = 0;\n    this.next();\n  }\n  next() {\n    let {sections} = this.set;\n    if (this.i < sections.length) {\n      this.len = sections[this.i++];\n      this.ins = sections[this.i++];\n    } else {\n      this.len = 0;\n      this.ins = -2;\n    }\n    this.off = 0;\n  }\n  get done() {\n    return this.ins == -2;\n  }\n  get len2() {\n    return this.ins < 0 ? this.len : this.ins;\n  }\n  get text() {\n    let {inserted} = this.set, index = this.i - 2 >> 1;\n    return index >= inserted.length ? text_1.Text.empty : inserted[index];\n  }\n  textBit(len) {\n    let {inserted} = this.set, index = this.i - 2 >> 1;\n    return index >= inserted.length && !len ? text_1.Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n  }\n  forward(len) {\n    if (len == this.len) this.next(); else {\n      this.len -= len;\n      this.off += len;\n    }\n  }\n  forward2(len) {\n    if (this.ins == -1) this.forward(len); else if (len == this.ins) this.next(); else {\n      this.ins -= len;\n      this.off += len;\n    }\n  }\n}\nclass SelectionRange {\n  constructor(from, to, flags) {\n    this.from = from;\n    this.to = to;\n    this.flags = flags;\n  }\n  get anchor() {\n    return this.flags & 16 ? this.to : this.from;\n  }\n  get head() {\n    return this.flags & 16 ? this.from : this.to;\n  }\n  get empty() {\n    return this.from == this.to;\n  }\n  get assoc() {\n    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;\n  }\n  get bidiLevel() {\n    let level = this.flags & 3;\n    return level == 3 ? null : level;\n  }\n  get goalColumn() {\n    let value = this.flags >> 5;\n    return value == 33554431 ? undefined : value;\n  }\n  map(change, assoc = -1) {\n    let from = change.mapPos(this.from, assoc), to = change.mapPos(this.to, assoc);\n    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n  }\n  extend(from, to = from) {\n    if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);\n    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n    return EditorSelection.range(this.anchor, head);\n  }\n  eq(other) {\n    return this.anchor == other.anchor && this.head == other.head;\n  }\n  toJSON() {\n    return {\n      anchor: this.anchor,\n      head: this.head\n    };\n  }\n  static fromJSON(json) {\n    if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n    return EditorSelection.range(json.anchor, json.head);\n  }\n}\nclass EditorSelection {\n  constructor(ranges, mainIndex = 0) {\n    this.ranges = ranges;\n    this.mainIndex = mainIndex;\n  }\n  map(change, assoc = -1) {\n    if (change.empty) return this;\n    return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);\n  }\n  eq(other) {\n    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;\n    for (let i = 0; i < this.ranges.length; i++) if (!this.ranges[i].eq(other.ranges[i])) return false;\n    return true;\n  }\n  get main() {\n    return this.ranges[this.mainIndex];\n  }\n  asSingle() {\n    return this.ranges.length == 1 ? this : new EditorSelection([this.main]);\n  }\n  addRange(range, main = true) {\n    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n  }\n  replaceRange(range, which = this.mainIndex) {\n    let ranges = this.ranges.slice();\n    ranges[which] = range;\n    return EditorSelection.create(ranges, this.mainIndex);\n  }\n  toJSON() {\n    return {\n      ranges: this.ranges.map(r => r.toJSON()),\n      main: this.mainIndex\n    };\n  }\n  static fromJSON(json) {\n    if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length) throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n    return new EditorSelection(json.ranges.map(r => SelectionRange.fromJSON(r)), json.main);\n  }\n  static single(anchor, head = anchor) {\n    return new EditorSelection([EditorSelection.range(anchor, head)], 0);\n  }\n  static create(ranges, mainIndex = 0) {\n    if (ranges.length == 0) throw new RangeError(\"A selection needs at least one range\");\n    for (let pos = 0, i = 0; i < ranges.length; i++) {\n      let range = ranges[i];\n      if (range.empty ? range.from <= pos : range.from < pos) return normalized(ranges.slice(), mainIndex);\n      pos = range.to;\n    }\n    return new EditorSelection(ranges, mainIndex);\n  }\n  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n    return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);\n  }\n  static range(anchor, head, goalColumn) {\n    let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;\n    return head < anchor ? new SelectionRange(head, anchor, 16 | goal) : new SelectionRange(anchor, head, goal);\n  }\n}\nfunction normalized(ranges, mainIndex = 0) {\n  let main = ranges[mainIndex];\n  ranges.sort((a, b) => a.from - b.from);\n  mainIndex = ranges.indexOf(main);\n  for (let i = 1; i < ranges.length; i++) {\n    let range = ranges[i], prev = ranges[i - 1];\n    if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n      let from = prev.from, to = Math.max(range.to, prev.to);\n      if (i <= mainIndex) mainIndex--;\n      ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n    }\n  }\n  return new EditorSelection(ranges, mainIndex);\n}\nfunction checkSelection(selection, docLength) {\n  for (let range of selection.ranges) if (range.to > docLength) throw new RangeError(\"Selection points outside of document\");\n}\nlet nextID = 0;\nclass Facet {\n  constructor(combine, compareInput, compare, isStatic, extensions) {\n    this.combine = combine;\n    this.compareInput = compareInput;\n    this.compare = compare;\n    this.isStatic = isStatic;\n    this.extensions = extensions;\n    this.id = nextID++;\n    this.default = combine([]);\n  }\n  static define(config = {}) {\n    return new Facet(config.combine || (a => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);\n  }\n  of(value) {\n    return new FacetProvider([], this, 0, value);\n  }\n  compute(deps, get) {\n    if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n    return new FacetProvider(deps, this, 1, get);\n  }\n  computeN(deps, get) {\n    if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n    return new FacetProvider(deps, this, 2, get);\n  }\n  from(field, get) {\n    if (!get) get = x => x;\n    return this.compute([field], state => get(state.field(field)));\n  }\n}\nfunction sameArray(a, b) {\n  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n  constructor(dependencies, facet, type, value) {\n    this.dependencies = dependencies;\n    this.facet = facet;\n    this.type = type;\n    this.value = value;\n    this.id = nextID++;\n  }\n  dynamicSlot(addresses) {\n    var _a;\n    let getter = this.value;\n    let compare = this.facet.compareInput;\n    let idx = addresses[this.id] >> 1, multi = this.type == 2;\n    let depDoc = false, depSel = false, depAddrs = [];\n    for (let dep of this.dependencies) {\n      if (dep == \"doc\") depDoc = true; else if (dep == \"selection\") depSel = true; else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);\n    }\n    return (state, tr) => {\n      if (!tr || tr.reconfigured) {\n        state.values[idx] = getter(state);\n        return 1;\n      } else {\n        let depChanged = depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || depAddrs.some(addr => (ensureAddr(state, addr) & 1) > 0);\n        if (!depChanged) return 0;\n        let newVal = getter(state), oldVal = tr.startState.values[idx];\n        if (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal)) return 0;\n        state.values[idx] = newVal;\n        return 1;\n      }\n    };\n  }\n}\nfunction compareArray(a, b, compare) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) if (!compare(a[i], b[i])) return false;\n  return true;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n  let providerAddrs = providers.map(p => addresses[p.id]);\n  let providerTypes = providers.map(p => p.type);\n  let dynamic = providerAddrs.filter(p => !(p & 1));\n  let idx = addresses[facet.id] >> 1;\n  return (state, tr) => {\n    let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1;\n    let changed = oldAddr == null;\n    for (let dynAddr of dynamic) {\n      if (ensureAddr(state, dynAddr) & 1) changed = true;\n    }\n    if (!changed) return 0;\n    let values = [];\n    for (let i = 0; i < providerAddrs.length; i++) {\n      let value = getAddr(state, providerAddrs[i]);\n      if (providerTypes[i] == 2) for (let val of value) values.push(val); else values.push(value);\n    }\n    let newVal = facet.combine(values);\n    if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr))) return 0;\n    state.values[idx] = newVal;\n    return 1;\n  };\n}\nfunction maybeIndex(state, id) {\n  let found = state.config.address[id];\n  return found == null ? null : found >> 1;\n}\nconst initField = Facet.define({\n  static: true\n});\nclass StateField {\n  constructor(id, createF, updateF, compareF, spec) {\n    this.id = id;\n    this.createF = createF;\n    this.updateF = updateF;\n    this.compareF = compareF;\n    this.spec = spec;\n    this.provides = undefined;\n  }\n  static define(config) {\n    let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);\n    if (config.provide) field.provides = config.provide(field);\n    return field;\n  }\n  create(state) {\n    let init = state.facet(initField).find(i => i.field == this);\n    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n  }\n  slot(addresses) {\n    let idx = addresses[this.id] >> 1;\n    return (state, tr) => {\n      if (!tr) {\n        state.values[idx] = this.create(state);\n        return 1;\n      }\n      let oldVal, changed = 0;\n      if (tr.reconfigured) {\n        let oldIdx = maybeIndex(tr.startState, this.id);\n        oldVal = oldIdx == null ? this.create(tr.startState) : tr.startState.values[oldIdx];\n        changed = 1;\n      } else {\n        oldVal = tr.startState.values[idx];\n      }\n      let value = this.updateF(oldVal, tr);\n      if (!changed && !this.compareF(oldVal, value)) changed = 1;\n      if (changed) state.values[idx] = value;\n      return changed;\n    };\n  }\n  init(create) {\n    return [this, initField.of({\n      field: this,\n      create\n    })];\n  }\n  get extension() {\n    return this;\n  }\n}\nconst Prec_ = {\n  fallback: 3,\n  default: 2,\n  extend: 1,\n  override: 0\n};\nfunction prec(value) {\n  return ext => new PrecExtension(ext, value);\n}\nconst Prec = {\n  fallback: prec(Prec_.fallback),\n  default: prec(Prec_.default),\n  extend: prec(Prec_.extend),\n  override: prec(Prec_.override)\n};\nclass PrecExtension {\n  constructor(inner, prec) {\n    this.inner = inner;\n    this.prec = prec;\n  }\n}\nclass Compartment {\n  of(ext) {\n    return new CompartmentInstance(this, ext);\n  }\n  reconfigure(content) {\n    return Compartment.reconfigure.of({\n      compartment: this,\n      extension: content\n    });\n  }\n  get(state) {\n    return state.config.compartments.get(this);\n  }\n}\nclass CompartmentInstance {\n  constructor(compartment, inner) {\n    this.compartment = compartment;\n    this.inner = inner;\n  }\n}\nclass Configuration {\n  constructor(base, compartments, dynamicSlots, address, staticValues) {\n    this.base = base;\n    this.compartments = compartments;\n    this.dynamicSlots = dynamicSlots;\n    this.address = address;\n    this.staticValues = staticValues;\n    this.statusTemplate = [];\n    while (this.statusTemplate.length < dynamicSlots.length) this.statusTemplate.push(0);\n  }\n  staticFacet(facet) {\n    let addr = this.address[facet.id];\n    return addr == null ? facet.default : this.staticValues[addr >> 1];\n  }\n  static resolve(base, compartments, oldState) {\n    let fields = [];\n    let facets = Object.create(null);\n    let newCompartments = new Map();\n    for (let ext of flatten(base, compartments, newCompartments)) {\n      if (ext instanceof StateField) fields.push(ext); else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n    }\n    let address = Object.create(null);\n    let staticValues = [];\n    let dynamicSlots = [];\n    for (let field of fields) {\n      address[field.id] = dynamicSlots.length << 1;\n      dynamicSlots.push(a => field.slot(a));\n    }\n    for (let id in facets) {\n      let providers = facets[id], facet = providers[0].facet;\n      if (providers.every(p => p.type == 0)) {\n        address[facet.id] = staticValues.length << 1 | 1;\n        let value = facet.combine(providers.map(p => p.value));\n        let oldAddr = oldState ? oldState.config.address[facet.id] : null;\n        if (oldAddr != null) {\n          let oldVal = getAddr(oldState, oldAddr);\n          if (facet.compare(value, oldVal)) value = oldVal;\n        }\n        staticValues.push(value);\n      } else {\n        for (let p of providers) {\n          if (p.type == 0) {\n            address[p.id] = staticValues.length << 1 | 1;\n            staticValues.push(p.value);\n          } else {\n            address[p.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => p.dynamicSlot(a));\n          }\n        }\n        address[facet.id] = dynamicSlots.length << 1;\n        dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n      }\n    }\n    return new Configuration(base, newCompartments, dynamicSlots.map(f => f(address)), address, staticValues);\n  }\n}\nfunction flatten(extension, compartments, newCompartments) {\n  let result = [[], [], [], []];\n  let seen = new Map();\n  function inner(ext, prec) {\n    let known = seen.get(ext);\n    if (known != null) {\n      if (known >= prec) return;\n      let found = result[known].indexOf(ext);\n      if (found > -1) result[known].splice(found, 1);\n      if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);\n    }\n    seen.set(ext, prec);\n    if (Array.isArray(ext)) {\n      for (let e of ext) inner(e, prec);\n    } else if (ext instanceof CompartmentInstance) {\n      if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);\n      let content = compartments.get(ext.compartment) || ext.inner;\n      newCompartments.set(ext.compartment, content);\n      inner(content, prec);\n    } else if (ext instanceof PrecExtension) {\n      inner(ext.inner, ext.prec);\n    } else if (ext instanceof StateField) {\n      result[prec].push(ext);\n      if (ext.provides) inner(ext.provides, prec);\n    } else if (ext instanceof FacetProvider) {\n      result[prec].push(ext);\n      if (ext.facet.extensions) inner(ext.facet.extensions, prec);\n    } else {\n      let content = ext.extension;\n      if (!content) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n      inner(content, prec);\n    }\n  }\n  inner(extension, Prec_.default);\n  return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n  if (addr & 1) return 2;\n  let idx = addr >> 1;\n  let status = state.status[idx];\n  if (status == 4) throw new Error(\"Cyclic dependency between fields and/or facets\");\n  if (status & 2) return status;\n  state.status[idx] = 4;\n  let changed = state.config.dynamicSlots[idx](state, state.applying);\n  return state.status[idx] = 2 | changed;\n}\nfunction getAddr(state, addr) {\n  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\nconst languageData = Facet.define();\nconst allowMultipleSelections = Facet.define({\n  combine: values => values.some(v => v),\n  static: true\n});\nconst lineSeparator = Facet.define({\n  combine: values => values.length ? values[0] : undefined,\n  static: true\n});\nconst changeFilter = Facet.define();\nconst transactionFilter = Facet.define();\nconst transactionExtender = Facet.define();\nclass Annotation {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n  static define() {\n    return new AnnotationType();\n  }\n}\nclass AnnotationType {\n  of(value) {\n    return new Annotation(this, value);\n  }\n}\nclass StateEffectType {\n  constructor(map) {\n    this.map = map;\n  }\n  of(value) {\n    return new StateEffect(this, value);\n  }\n}\nclass StateEffect {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n  map(mapping) {\n    let mapped = this.type.map(this.value, mapping);\n    return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n  }\n  is(type) {\n    return this.type == type;\n  }\n  static define(spec = {}) {\n    return new StateEffectType(spec.map || (v => v));\n  }\n  static mapEffects(effects, mapping) {\n    if (!effects.length) return effects;\n    let result = [];\n    for (let effect of effects) {\n      let mapped = effect.map(mapping);\n      if (mapped) result.push(mapped);\n    }\n    return result;\n  }\n}\nStateEffect.reconfigure = StateEffect.define();\nStateEffect.appendConfig = StateEffect.define();\nclass Transaction {\n  constructor(startState, changes, selection, effects, annotations, scrollIntoView) {\n    this.startState = startState;\n    this.changes = changes;\n    this.selection = selection;\n    this.effects = effects;\n    this.annotations = annotations;\n    this.scrollIntoView = scrollIntoView;\n    this._doc = null;\n    this._state = null;\n    if (selection) checkSelection(selection, changes.newLength);\n    if (!annotations.some(a => a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n  }\n  get newDoc() {\n    return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n  }\n  get newSelection() {\n    return this.selection || this.startState.selection.map(this.changes);\n  }\n  get state() {\n    if (!this._state) this.startState.applyTransaction(this);\n    return this._state;\n  }\n  annotation(type) {\n    for (let ann of this.annotations) if (ann.type == type) return ann.value;\n    return undefined;\n  }\n  get docChanged() {\n    return !this.changes.empty;\n  }\n  get reconfigured() {\n    return this.startState.config != this.state.config;\n  }\n}\nTransaction.time = Annotation.define();\nTransaction.userEvent = Annotation.define();\nTransaction.addToHistory = Annotation.define();\nfunction joinRanges(a, b) {\n  let result = [];\n  for (let iA = 0, iB = 0; ; ) {\n    let from, to;\n    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n      from = a[iA++];\n      to = a[iA++];\n    } else if (iB < b.length) {\n      from = b[iB++];\n      to = b[iB++];\n    } else return result;\n    if (!result.length || result[result.length - 1] < from) result.push(from, to); else if (result[result.length - 1] < to) result[result.length - 1] = to;\n  }\n}\nfunction mergeTransaction(a, b, sequential) {\n  var _a;\n  let mapForA, mapForB, changes;\n  if (sequential) {\n    mapForA = b.changes;\n    mapForB = ChangeSet.empty(b.changes.length);\n    changes = a.changes.compose(b.changes);\n  } else {\n    mapForA = b.changes.map(a.changes);\n    mapForB = a.changes.mapDesc(b.changes, true);\n    changes = a.changes.compose(mapForA);\n  }\n  return {\n    changes,\n    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n    scrollIntoView: a.scrollIntoView || b.scrollIntoView\n  };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n  let sel = spec.selection;\n  return {\n    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n    effects: asArray(spec.effects),\n    annotations: asArray(spec.annotations),\n    scrollIntoView: !!spec.scrollIntoView\n  };\n}\nfunction resolveTransaction(state, specs, filter) {\n  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n  if (specs.length && specs[0].filter === false) filter = false;\n  for (let i = 1; i < specs.length; i++) {\n    if (specs[i].filter === false) filter = false;\n    let seq = !!specs[i].sequential;\n    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n  }\n  let tr = new Transaction(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n  return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\nfunction filterTransaction(tr) {\n  let state = tr.startState;\n  let result = true;\n  for (let filter of state.facet(changeFilter)) {\n    let value = filter(tr);\n    if (value === false) {\n      result = false;\n      break;\n    }\n    if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);\n  }\n  if (result !== true) {\n    let changes, back;\n    if (result === false) {\n      back = tr.changes.invertedDesc;\n      changes = ChangeSet.empty(state.doc.length);\n    } else {\n      let filtered = tr.changes.filter(result);\n      changes = filtered.changes;\n      back = filtered.filtered.invertedDesc;\n    }\n    tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n  }\n  let filters = state.facet(transactionFilter);\n  for (let i = filters.length - 1; i >= 0; i--) {\n    let filtered = filters[i](tr);\n    if (filtered instanceof Transaction) tr = filtered; else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0]; else tr = resolveTransaction(state, asArray(filtered), false);\n  }\n  return tr;\n}\nfunction extendTransaction(tr) {\n  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n  for (let i = extenders.length - 1; i >= 0; i--) {\n    let extension = extenders[i](tr);\n    if (extension && Object.keys(extension).length) spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n  }\n  return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n  return value == null ? none : Array.isArray(value) ? value : [value];\n}\nvar CharCategory;\n(function (CharCategory) {\n  CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n  CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n  CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n})(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n  wordChar = new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch (_) {}\nfunction hasWordChar(str) {\n  if (wordChar) return wordChar.test(str);\n  for (let i = 0; i < str.length; i++) {\n    let ch = str[i];\n    if ((/\\w/).test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;\n  }\n  return false;\n}\nfunction makeCategorizer(wordChars) {\n  return char => {\n    if (!(/\\S/).test(char)) return CharCategory.Space;\n    if (hasWordChar(char)) return CharCategory.Word;\n    for (let i = 0; i < wordChars.length; i++) if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;\n    return CharCategory.Other;\n  };\n}\nclass EditorState {\n  constructor(config, doc, selection, tr = null) {\n    this.config = config;\n    this.doc = doc;\n    this.selection = selection;\n    this.applying = null;\n    this.status = config.statusTemplate.slice();\n    if (tr && tr.startState.config == config) {\n      this.values = tr.startState.values.slice();\n    } else {\n      this.values = config.dynamicSlots.map(_ => null);\n      if (tr) for (let id in config.address) {\n        let cur = config.address[id], prev = tr.startState.config.address[id];\n        if (prev != null && (cur & 1) == 0) this.values[cur >> 1] = getAddr(tr.startState, prev);\n      }\n    }\n    this.applying = tr;\n    if (tr) tr._state = this;\n    for (let i = 0; i < this.config.dynamicSlots.length; i++) ensureAddr(this, i << 1);\n    this.applying = null;\n  }\n  field(field, require = true) {\n    let addr = this.config.address[field.id];\n    if (addr == null) {\n      if (require) throw new RangeError(\"Field is not present in this state\");\n      return undefined;\n    }\n    ensureAddr(this, addr);\n    return getAddr(this, addr);\n  }\n  update(...specs) {\n    return resolveTransaction(this, specs, true);\n  }\n  applyTransaction(tr) {\n    let conf = this.config, {base, compartments} = conf;\n    for (let effect of tr.effects) {\n      if (effect.is(Compartment.reconfigure)) {\n        if (conf) {\n          compartments = new Map();\n          conf.compartments.forEach((val, key) => compartments.set(key, val));\n          conf = null;\n        }\n        compartments.set(effect.value.compartment, effect.value.extension);\n      } else if (effect.is(StateEffect.reconfigure)) {\n        conf = null;\n        base = effect.value;\n      } else if (effect.is(StateEffect.appendConfig)) {\n        conf = null;\n        base = asArray(base).concat(effect.value);\n      }\n    }\n    new EditorState(conf || Configuration.resolve(base, compartments, this), tr.newDoc, tr.newSelection, tr);\n  }\n  replaceSelection(text) {\n    if (typeof text == \"string\") text = this.toText(text);\n    return this.changeByRange(range => ({\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: text\n      },\n      range: EditorSelection.cursor(range.from + text.length)\n    }));\n  }\n  changeByRange(f) {\n    let sel = this.selection;\n    let result1 = f(sel.ranges[0]);\n    let changes = this.changes(result1.changes), ranges = [result1.range];\n    let effects = asArray(result1.effects);\n    for (let i = 1; i < sel.ranges.length; i++) {\n      let result = f(sel.ranges[i]);\n      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n      for (let j = 0; j < i; j++) ranges[j] = ranges[j].map(newMapped);\n      let mapBy = changes.mapDesc(newChanges, true);\n      ranges.push(result.range.map(mapBy));\n      changes = changes.compose(newMapped);\n      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n    }\n    return {\n      changes,\n      selection: EditorSelection.create(ranges, sel.mainIndex),\n      effects\n    };\n  }\n  changes(spec = []) {\n    if (spec instanceof ChangeSet) return spec;\n    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n  }\n  toText(string) {\n    return text_1.Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n  }\n  sliceDoc(from = 0, to = this.doc.length) {\n    return this.doc.sliceString(from, to, this.lineBreak);\n  }\n  facet(facet) {\n    let addr = this.config.address[facet.id];\n    if (addr == null) return facet.default;\n    ensureAddr(this, addr);\n    return getAddr(this, addr);\n  }\n  toJSON(fields) {\n    let result = {\n      doc: this.sliceDoc(),\n      selection: this.selection.toJSON()\n    };\n    if (fields) for (let prop in fields) {\n      let value = fields[prop];\n      if (value instanceof StateField) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n    }\n    return result;\n  }\n  static fromJSON(json, config = {}, fields) {\n    if (!json || typeof json.doc != \"string\") throw new RangeError(\"Invalid JSON representation for EditorState\");\n    let fieldInit = [];\n    if (fields) for (let prop in fields) {\n      let field = fields[prop], value = json[prop];\n      fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));\n    }\n    return EditorState.create({\n      doc: json.doc,\n      selection: EditorSelection.fromJSON(json.selection),\n      extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit\n    });\n  }\n  static create(config = {}) {\n    let configuration = Configuration.resolve(config.extensions || [], new Map());\n    let doc = config.doc instanceof text_1.Text ? config.doc : text_1.Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n    let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);\n    checkSelection(selection, doc.length);\n    if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();\n    return new EditorState(configuration, doc, selection);\n  }\n  get tabSize() {\n    return this.facet(EditorState.tabSize);\n  }\n  get lineBreak() {\n    return this.facet(EditorState.lineSeparator) || \"\\n\";\n  }\n  phrase(phrase) {\n    for (let map of this.facet(EditorState.phrases)) if (Object.prototype.hasOwnProperty.call(map, phrase)) return map[phrase];\n    return phrase;\n  }\n  languageDataAt(name, pos) {\n    let values = [];\n    for (let provider of this.facet(languageData)) {\n      for (let result of provider(this, pos)) {\n        if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);\n      }\n    }\n    return values;\n  }\n  charCategorizer(at) {\n    return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n  }\n}\nEditorState.allowMultipleSelections = allowMultipleSelections;\nEditorState.tabSize = Facet.define({\n  combine: values => values.length ? values[0] : 4\n});\nEditorState.lineSeparator = lineSeparator;\nEditorState.phrases = Facet.define();\nEditorState.languageData = languageData;\nEditorState.changeFilter = changeFilter;\nEditorState.transactionFilter = transactionFilter;\nEditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = StateEffect.define();\nfunction combineConfig(configs, defaults, combine = {}) {\n  let result = {};\n  for (let config of configs) for (let key of Object.keys(config)) {\n    let value = config[key], current = result[key];\n    if (current === undefined) result[key] = value; else if (current === value || value === undefined) ; else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value); else throw new Error(\"Config merge conflict for field \" + key);\n  }\n  for (let key in defaults) if (result[key] === undefined) result[key] = defaults[key];\n  return result;\n}\nexports.Annotation = Annotation;\nexports.AnnotationType = AnnotationType;\nexports.ChangeDesc = ChangeDesc;\nexports.ChangeSet = ChangeSet;\nexports.CharCategory = CharCategory;\nexports.Compartment = Compartment;\nexports.EditorSelection = EditorSelection;\nexports.EditorState = EditorState;\nexports.Facet = Facet;\nexports.MapMode = MapMode;\nexports.Prec = Prec;\nexports.SelectionRange = SelectionRange;\nexports.StateEffect = StateEffect;\nexports.StateEffectType = StateEffectType;\nexports.StateField = StateField;\nexports.Transaction = Transaction;\nexports.combineConfig = combineConfig;\n"}