{"contents":"exports.__esModule = true;\nlet extend = (\"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\").split(\",\").map(s => s ? parseInt(s, 36) : 1);\nfor (let i = 1; i < extend.length; i++) extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n  for (let i = 1; i < extend.length; i += 2) if (extend[i] > code) return extend[i - 1] <= code;\n  return false;\n}\nfunction isRegionalIndicator(code) {\n  return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\nfunction findClusterBreak(str, pos, forward = true) {\n  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);\n}\nfunction nextClusterBreak(str, pos) {\n  if (pos == str.length) return pos;\n  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;\n  let prev = codePointAt(str, pos);\n  pos += codePointSize(prev);\n  while (pos < str.length) {\n    let next = codePointAt(str, pos);\n    if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {\n      pos += codePointSize(next);\n      prev = next;\n    } else if (isRegionalIndicator(next)) {\n      let countBefore = 0, i = pos - 2;\n      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\n        countBefore++;\n        i -= 2;\n      }\n      if (countBefore % 2 == 0) break; else pos += 2;\n    } else {\n      break;\n    }\n  }\n  return pos;\n}\nfunction prevClusterBreak(str, pos) {\n  while (pos > 0) {\n    let found = nextClusterBreak(str, pos - 2);\n    if (found < pos) return found;\n    pos--;\n  }\n  return 0;\n}\nfunction surrogateLow(ch) {\n  return ch >= 0xDC00 && ch < 0xE000;\n}\nfunction surrogateHigh(ch) {\n  return ch >= 0xD800 && ch < 0xDC00;\n}\nfunction codePointAt(str, pos) {\n  let code0 = str.charCodeAt(pos);\n  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n  let code1 = str.charCodeAt(pos + 1);\n  if (!surrogateLow(code1)) return code0;\n  return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n}\nfunction fromCodePoint(code) {\n  if (code <= 0xffff) return String.fromCharCode(code);\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\nfunction codePointSize(code) {\n  return code < 0x10000 ? 1 : 2;\n}\nfunction countColumn(string, n, tabSize) {\n  for (let i = 0; i < string.length; ) {\n    if (string.charCodeAt(i) == 9) {\n      n += tabSize - n % tabSize;\n      i++;\n    } else {\n      n++;\n      i = findClusterBreak(string, i);\n    }\n  }\n  return n;\n}\nfunction findColumn(string, n, col, tabSize) {\n  for (let i = 0; i < string.length; ) {\n    if (n >= col) return {\n      offset: i,\n      leftOver: 0\n    };\n    n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;\n    i = findClusterBreak(string, i);\n  }\n  return {\n    offset: string.length,\n    leftOver: col - n\n  };\n}\nclass Text {\n  constructor() {}\n  lineAt(pos) {\n    if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n    return this.lineInner(pos, false, 1, 0);\n  }\n  line(n) {\n    if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n    return this.lineInner(n, true, 1, 0);\n  }\n  replace(from, to, text) {\n    let parts = [];\n    this.decompose(0, from, parts, 2);\n    if (text.length) text.decompose(0, text.length, parts, 1 | 2);\n    this.decompose(to, this.length, parts, 1);\n    return TextNode.from(parts, this.length - (to - from) + text.length);\n  }\n  append(other) {\n    return this.replace(this.length, this.length, other);\n  }\n  slice(from, to = this.length) {\n    let parts = [];\n    this.decompose(from, to, parts, 0);\n    return TextNode.from(parts, to - from);\n  }\n  eq(other) {\n    if (other == this) return true;\n    if (other.length != this.length || other.lines != this.lines) return false;\n    let a = new RawTextCursor(this), b = new RawTextCursor(other);\n    for (; ; ) {\n      a.next();\n      b.next();\n      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n      if (a.done) return true;\n    }\n  }\n  iter(dir = 1) {\n    return new RawTextCursor(this, dir);\n  }\n  iterRange(from, to = this.length) {\n    return new PartialTextCursor(this, from, to);\n  }\n  toString() {\n    return this.sliceString(0);\n  }\n  toJSON() {\n    let lines = [];\n    this.flatten(lines);\n    return lines;\n  }\n  static of(text) {\n    if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n    if (text.length == 1 && !text[0]) return Text.empty;\n    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n  }\n}\nif (typeof Symbol != \"undefined\") Text.prototype[Symbol.iterator] = function () {\n  return this.iter();\n};\nclass TextLeaf extends Text {\n  constructor(text, length = textLength(text)) {\n    super();\n    this.text = text;\n    this.length = length;\n  }\n  get lines() {\n    return this.text.length;\n  }\n  get children() {\n    return null;\n  }\n  lineInner(target, isLine, line, offset) {\n    for (let i = 0; ; i++) {\n      let string = this.text[i], end = offset + string.length;\n      if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n      offset = end + 1;\n      line++;\n    }\n  }\n  decompose(from, to, target, open) {\n    let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n    if (open & 1) {\n      let prev = target.pop();\n      let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n      if (joined.length <= 32) {\n        target.push(new TextLeaf(joined, prev.length + text.length));\n      } else {\n        let mid = joined.length >> 1;\n        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n      }\n    } else {\n      target.push(text);\n    }\n  }\n  replace(from, to, text) {\n    if (!(text instanceof TextLeaf)) return super.replace(from, to, text);\n    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n    let newLen = this.length + text.length - (to - from);\n    if (lines.length <= 32) return new TextLeaf(lines, newLen);\n    return TextNode.from(TextLeaf.split(lines, []), newLen);\n  }\n  sliceString(from, to = this.length, lineSep = \"\\n\") {\n    let result = \"\";\n    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n      let line = this.text[i], end = pos + line.length;\n      if (pos > from && i) result += lineSep;\n      if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n      pos = end + 1;\n    }\n    return result;\n  }\n  flatten(target) {\n    for (let line of this.text) target.push(line);\n  }\n  static split(text, target) {\n    let part = [], len = -1;\n    for (let line of text) {\n      part.push(line);\n      len += line.length + 1;\n      if (part.length == 32) {\n        target.push(new TextLeaf(part, len));\n        part = [];\n        len = -1;\n      }\n    }\n    if (len > -1) target.push(new TextLeaf(part, len));\n    return target;\n  }\n}\nclass TextNode extends Text {\n  constructor(children, length) {\n    super();\n    this.children = children;\n    this.length = length;\n    this.lines = 0;\n    for (let child of children) this.lines += child.lines;\n  }\n  lineInner(target, isLine, line, offset) {\n    for (let i = 0; ; i++) {\n      let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n      if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n      offset = end + 1;\n      line = endLine + 1;\n    }\n  }\n  decompose(from, to, target, open) {\n    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n      let child = this.children[i], end = pos + child.length;\n      if (from <= end && to >= pos) {\n        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));\n        if (pos >= from && end <= to && !childOpen) target.push(child); else child.decompose(from - pos, to - pos, target, childOpen);\n      }\n      pos = end + 1;\n    }\n  }\n  replace(from, to, text) {\n    if (text.lines < this.lines) for (let i = 0, pos = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = pos + child.length;\n      if (from >= pos && to <= end) {\n        let updated = child.replace(from - pos, to - pos, text);\n        let totalLines = this.lines - child.lines + updated.lines;\n        if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {\n          let copy = this.children.slice();\n          copy[i] = updated;\n          return new TextNode(copy, this.length - (to - from) + text.length);\n        }\n        return super.replace(pos, end, updated);\n      }\n      pos = end + 1;\n    }\n    return super.replace(from, to, text);\n  }\n  sliceString(from, to = this.length, lineSep = \"\\n\") {\n    let result = \"\";\n    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n      let child = this.children[i], end = pos + child.length;\n      if (pos > from && i) result += lineSep;\n      if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n      pos = end + 1;\n    }\n    return result;\n  }\n  flatten(target) {\n    for (let child of this.children) child.flatten(target);\n  }\n  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n    let lines = 0;\n    for (let ch of children) lines += ch.lines;\n    if (lines < 32) {\n      let flat = [];\n      for (let ch of children) ch.flatten(flat);\n      return new TextLeaf(flat, length);\n    }\n    let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;\n    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n    function add(child) {\n      let last;\n      if (child.lines > maxChunk && child instanceof TextNode) {\n        for (let node of child.children) add(node);\n      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n        flush();\n        chunked.push(child);\n      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {\n        currentLines += child.lines;\n        currentLen += child.length + 1;\n        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n      } else {\n        if (currentLines + child.lines > chunk) flush();\n        currentLines += child.lines;\n        currentLen += child.length + 1;\n        currentChunk.push(child);\n      }\n    }\n    function flush() {\n      if (currentLines == 0) return;\n      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n      currentLen = -1;\n      currentLines = currentChunk.length = 0;\n    }\n    for (let child of children) add(child);\n    flush();\n    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n  }\n}\nText.empty = new TextLeaf([\"\"], 0);\nfunction textLength(text) {\n  let length = -1;\n  for (let line of text) length += line.length + 1;\n  return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n    let line = text[i], end = pos + line.length;\n    if (end >= from) {\n      if (end > to) line = line.slice(0, to - pos);\n      if (pos < from) line = line.slice(from - pos);\n      if (first) {\n        target[target.length - 1] += line;\n        first = false;\n      } else target.push(line);\n    }\n    pos = end + 1;\n  }\n  return target;\n}\nfunction sliceText(text, from, to) {\n  return appendText(text, [\"\"], from, to);\n}\nclass RawTextCursor {\n  constructor(text, dir = 1) {\n    this.dir = dir;\n    this.done = false;\n    this.lineBreak = false;\n    this.value = \"\";\n    this.nodes = [text];\n    this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];\n  }\n  next(skip = 0) {\n    for (; ; ) {\n      let last = this.nodes.length - 1;\n      if (last < 0) {\n        this.done = true;\n        this.value = \"\";\n        this.lineBreak = false;\n        return this;\n      }\n      let top = this.nodes[last], offset = this.offsets[last];\n      let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n      if (offset == (this.dir > 0 ? size : 0)) {\n        this.nodes.pop();\n        this.offsets.pop();\n      } else if (!this.lineBreak && offset != (this.dir > 0 ? 0 : size)) {\n        this.lineBreak = true;\n        if (skip == 0) {\n          this.value = \"\\n\";\n          return this;\n        }\n        skip--;\n      } else if (top instanceof TextLeaf) {\n        let next = top.text[offset - (this.dir < 0 ? 1 : 0)];\n        this.offsets[last] = offset += this.dir;\n        this.lineBreak = false;\n        if (next.length > Math.max(0, skip)) {\n          this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n          return this;\n        }\n        skip -= next.length;\n      } else {\n        let next = top.children[this.dir > 0 ? offset : offset - 1];\n        this.offsets[last] = offset + this.dir;\n        this.lineBreak = false;\n        if (skip > next.length) {\n          skip -= next.length;\n        } else {\n          this.nodes.push(next);\n          this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);\n        }\n      }\n    }\n  }\n}\nclass PartialTextCursor {\n  constructor(text, start, end) {\n    this.value = \"\";\n    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n    if (start > end) {\n      this.skip = text.length - start;\n      this.limit = start - end;\n    } else {\n      this.skip = start;\n      this.limit = end - start;\n    }\n  }\n  next(skip = 0) {\n    if (this.limit <= 0) {\n      this.limit = -1;\n    } else {\n      let {value, lineBreak, done} = this.cursor.next(this.skip + skip);\n      this.skip = 0;\n      this.value = value;\n      let len = lineBreak ? 1 : value.length;\n      if (len > this.limit) this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);\n      if (done || this.value.length == 0) this.limit = -1; else this.limit -= this.value.length;\n    }\n    return this;\n  }\n  get lineBreak() {\n    return this.cursor.lineBreak;\n  }\n  get done() {\n    return this.limit < 0;\n  }\n}\nclass Line {\n  constructor(from, to, number, text) {\n    this.from = from;\n    this.to = to;\n    this.number = number;\n    this.text = text;\n  }\n  get length() {\n    return this.to - this.from;\n  }\n}\nexports.Line = Line;\nexports.Text = Text;\nexports.codePointAt = codePointAt;\nexports.codePointSize = codePointSize;\nexports.countColumn = countColumn;\nexports.findClusterBreak = findClusterBreak;\nexports.findColumn = findColumn;\nexports.fromCodePoint = fromCodePoint;\n"}