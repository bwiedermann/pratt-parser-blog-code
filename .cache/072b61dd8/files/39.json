{"contents":"var _1_, _2_;\nvar _3_, _4_;\nexports.__esModule = true;\nvar position_1 = __fusereq(41);\nvar findBase_1 = __fusereq(49);\nclass NumberParselet {\n  parse(_parser, _tokens, token, varMap, registeredNodes, dependsMap) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    let newNode = {\n      nodeType: 'Number',\n      value: parseFloat(token.text),\n      outputType: {\n        status: 'Definitely',\n        valueType: 'number',\n        value: undefined\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.NumberParselet = NumberParselet;\nclass BooleanParselet {\n  constructor(value) {\n    this.value = value;\n  }\n  parse(_parser, _tokens, token, varMap, registeredNodes, dependsMap) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    let newNode = {\n      nodeType: 'Boolean',\n      value: this.value,\n      outputType: {\n        status: 'Definitely',\n        valueType: 'boolean',\n        value: undefined\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.BooleanParselet = BooleanParselet;\nclass ParenParselet {\n  parse(parser, tokens, _token, varMap, registeredNodes, dependsMap) {\n    const exp = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    tokens.expectToken(')');\n    return exp;\n  }\n}\nexports.ParenParselet = ParenParselet;\nclass BracketParselet {\n  parse(parser, tokens, token, varMap, registeredNodes, dependsMap) {\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    const arg3 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    tokens.expectToken(']');\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    let newNode = {\n      nodeType: 'Iterator',\n      outputType: undefined,\n      pos: position,\n      nodeId: id,\n      index: 0,\n      values: [],\n      start: arg1,\n      end: arg2,\n      step: arg3\n    };\n    console.log(\"The Iterator parslet is running!\");\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.BracketParselet = BracketParselet;\nclass ConsequentParselet {\n  constructor(tokenType, associativity) {\n    this.tokenType = tokenType;\n    this.associativity = associativity;\n  }\n}\nexports.ConsequentParselet = ConsequentParselet;\nclass BinaryOperatorParselet extends ConsequentParselet {\n  constructor(tokenType, associativity) {\n    super(tokenType, associativity);\n    this.tokenType = tokenType;\n  }\n  parse(parser, tokens, left, token, varMap, registeredNodes, dependsMap) {\n    const bindingPower = parser.bindingPower(token);\n    const right = parser.parse(tokens, this.associativity == 'left' ? bindingPower : bindingPower - 1, varMap, registeredNodes, dependsMap);\n    const position = position_1.join(left.pos, position_1.token2pos(tokens.last()));\n    const id = position_1.pos2string(position);\n    let newNode = {\n      nodeType: 'BinaryOperation',\n      operator: this.tokenType,\n      left,\n      right,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: undefined,\n        value: undefined\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.BinaryOperatorParselet = BinaryOperatorParselet;\nclass FunctionParselet {\n  parse(parser, tokens, token, varMap, registeredNodes, dependsMap) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    tokens.expectToken('(');\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    let args = [arg1];\n    if (token.text == \"ParseOrderedPair\") {\n      const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n      args.push(arg2);\n    }\n    tokens.expectToken(')');\n    let newNode = {\n      nodeType: 'Function',\n      name: token.text,\n      args: args,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: undefined,\n        value: undefined\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.FunctionParselet = FunctionParselet;\nclass ChooseParselet {\n  parse(parser, tokens, token, varMap, registeredNodes, dependsMap) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    const predicate = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    const consequent = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    tokens.expectToken('CHOOSE2');\n    const otherwise = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    let newNode = {\n      nodeType: 'Choose',\n      case: {\n        predicate: predicate,\n        consequent: consequent\n      },\n      otherwise: otherwise,\n      outputType: {\n        status: 'Maybe-Undefined',\n        valueType: undefined,\n        value: undefined\n      },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\nexports.ChooseParselet = ChooseParselet;\nclass VariableAssignmentParselet {\n  parse(parser, tokens, token, varMap, registeredNodes, dependsMap) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    tokens.expectToken('=');\n    const assignment = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    varMap[token.text] = id;\n    if (token.text.indexOf(\"%\") != -1) {\n      let newNode = {\n        nodeType: 'VariableAssignment',\n        name: token.text,\n        assignment: assignment,\n        outputType: {\n          status: \"Maybe-Undefined\",\n          valueType: (_2_ = (_1_ = assignment) === null || _1_ === void 0 ? void 0 : _1_.outputType) === null || _2_ === void 0 ? void 0 : _2_.valueType,\n          value: undefined\n        },\n        pos: position,\n        nodeId: id\n      };\n      registeredNodes[id] = newNode;\n      dependsMap[id] = findBase_1.findBases(assignment, dependsMap);\n      return newNode;\n    } else {\n      let newNode = {\n        nodeType: 'VariableAssignment',\n        name: token.text,\n        assignment: assignment,\n        outputType: {\n          status: \"Maybe-Undefined\",\n          valueType: (_4_ = (_3_ = assignment) === null || _3_ === void 0 ? void 0 : _3_.outputType) === null || _4_ === void 0 ? void 0 : _4_.valueType,\n          value: undefined\n        },\n        pos: position,\n        nodeId: id\n      };\n      registeredNodes[id] = newNode;\n      dependsMap[id] = findBase_1.findBases(assignment, dependsMap);\n      return newNode;\n    }\n  }\n}\nexports.VariableAssignmentParselet = VariableAssignmentParselet;\nclass IdentifierParselet {\n  parse(parser, tokens, token, varMap, registeredNodes, dependsMap) {\n    const position = position_1.token2pos(token);\n    const id = position_1.pos2string(position);\n    const assignmentId = varMap[token.text];\n    if (!assignmentId) {\n      const varParselet = new VariableAssignmentParselet();\n      return varParselet.parse(parser, tokens, token, varMap, registeredNodes, dependsMap);\n    } else {\n      if (token.text.indexOf(\"%\") != -1) {\n        let newNode = {\n          nodeType: 'RangeIdentifier',\n          name: token.text,\n          assignmentId: assignmentId,\n          outputType: {\n            status: \"Maybe-Undefined\",\n            valueType: undefined,\n            value: undefined\n          },\n          pos: position,\n          nodeId: id\n        };\n        registeredNodes[id] = newNode;\n        return newNode;\n      } else {\n        let newNode = {\n          nodeType: 'Identifier',\n          name: token.text,\n          assignmentId: assignmentId,\n          outputType: {\n            status: \"Maybe-Undefined\",\n            valueType: undefined,\n            value: undefined\n          },\n          pos: position,\n          nodeId: id\n        };\n        registeredNodes[id] = newNode;\n        return newNode;\n      }\n    }\n  }\n}\nexports.IdentifierParselet = IdentifierParselet;\n","sourceMap":"{\"version\":3,\"sources\":[\"src/parselet.ts\"],\"names\":[\"parse\",\"_parser\",\"_tokens\",\"token\",\"varMap\",\"registeredNodes\",\"dependsMap\",\"position\",\"position_1\",\"id\",\"newNode\",\"nodeType\",\"value\",\"parseFloat\",\"text\",\"outputType\",\"status\",\"valueType\",\"undefined\",\"pos\",\"nodeId\",\"constructor\",\"parser\",\"tokens\",\"_token\",\"exp\",\"expectToken\",\"arg1\",\"arg2\",\"arg3\",\"index\",\"values\",\"start\",\"end\",\"step\",\"console\",\"log\",\"tokenType\",\"associativity\",\"ConsequentParselet\",\"left\",\"bindingPower\",\"right\",\"last\",\"operator\",\"args\",\"push\",\"name\",\"predicate\",\"consequent\",\"otherwise\",\"case\",\"assignment\",\"indexOf\",\"findBase_1\",\"assignmentId\",\"varParselet\",\"VariableAssignmentParselet\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { TokenStream } from './tokenstream';\\r\\nimport { Token, TokenType, BinaryOperationTokenType} from './lexer';\\r\\nimport * as AST from './ast';\\r\\nimport { AbstractParser } from './parser';\\r\\nimport {ParseError, token2pos, join, pos2string} from './position';\\r\\nimport {findBases} from './findBase';\\r\\n\\r\\nexport interface InitialParselet {\\r\\n  parse(parser: AbstractParser,\\r\\n        tokens: TokenStream, token: Token,\\r\\n        varMap: {[key: string]: string},\\r\\n        registeredNodes: {[key: string]: AST.Node},\\r\\n        dependsMap: {[key: string]: string[]}): AST.Node;\\r\\n}\\r\\n\\r\\n\\r\\nexport class NumberParselet implements InitialParselet {\\r\\n  parse(_parser: AbstractParser,\\r\\n        _tokens: TokenStream,\\r\\n        token: Token,\\r\\n        varMap: {[key: string]: string},\\r\\n        registeredNodes: {[key: string]: AST.Node},\\r\\n        dependsMap: {[key: string]: string[]}) {\\r\\n    const position = token2pos(token);\\r\\n    const id = pos2string(position);\\r\\n    // add node to the map\\r\\n    let newNode : AST.NumberNode = {\\r\\n      nodeType: 'Number' as 'Number',\\r\\n      value: parseFloat(token.text),\\r\\n      outputType: { status: 'Definitely' as 'Definitely',\\r\\n                    valueType: 'number' as 'number',\\r\\n                    value: undefined },\\r\\n      pos: position,\\r\\n      nodeId: id\\r\\n    };\\r\\n    registeredNodes[id] = newNode;\\r\\n    return newNode;\\r\\n  }\\r\\n}\\r\\n\\r\\nexport class BooleanParselet implements InitialParselet {\\r\\n  constructor(private value: boolean) {}\\r\\n  parse(_parser: AbstractParser,\\r\\n        _tokens: TokenStream, token: Token,\\r\\n        varMap: {[key: string]: string},\\r\\n        registeredNodes: {[key: string]: AST.Node},\\r\\n        dependsMap: {[key: string]: string[]}) {\\r\\n    const position = token2pos(token);\\r\\n    const id = pos2string(position);\\r\\n    let newNode = {\\r\\n      nodeType: 'Boolean' as 'Boolean',\\r\\n      value: this.value,\\r\\n      outputType: { status: 'Definitely' as 'Definitely',\\r\\n                    valueType: 'boolean' as 'boolean',\\r\\n                    value: undefined},\\r\\n      pos: position,\\r\\n      nodeId: id\\r\\n    };\\r\\n    registeredNodes[id] = newNode;\\r\\n    return newNode;\\r\\n  }\\r\\n}\\r\\n\\r\\nexport class ParenParselet implements InitialParselet {\\r\\n  parse(parser: AbstractParser,\\r\\n    tokens: TokenStream,\\r\\n    _token: Token,\\r\\n    varMap: {[key: string]: string},\\r\\n    registeredNodes: {[key: string]: AST.Node},\\r\\n    dependsMap: {[key: string]: string[]}) {\\r\\n\\r\\n    const exp = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\\r\\n    tokens.expectToken(')');\\r\\n\\r\\n    return exp;\\r\\n  }\\r\\n}\\r\\n\\r\\nexport class BracketParselet implements InitialParselet {\\r\\n  parse(parser: AbstractParser,\\r\\n    tokens: TokenStream, token: Token,\\r\\n    varMap: {[key: string]: string},\\r\\n    registeredNodes: {[key: string]: AST.Node},\\r\\n    dependsMap: {[key: string]: string[]}) {\\r\\n\\r\\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\\r\\n    const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\\r\\n    const arg3 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\\r\\n    tokens.expectToken(']');\\r\\n\\r\\n\\r\\n    const position = token2pos(token);\\r\\n    const id = pos2string(position);\\r\\n    // add node to the map\\r\\n    let newNode : AST.IteratorNode = {\\r\\n      nodeType: 'Iterator' as 'Iterator',\\r\\n      outputType: undefined,\\r\\n      pos: position,\\r\\n      nodeId: id,\\r\\n      index: 0,\\r\\n      values: [],\\r\\n      start: arg1,\\r\\n      end: arg2,\\r\\n      step: arg3,\\r\\n    };\\r\\n\\r\\n    console.log(\\\"The Iterator parslet is running!\\\")\\r\\n    registeredNodes[id] = newNode;\\r\\n\\r\\n\\r\\n    return newNode;\\r\\n\\r\\n  }\\r\\n}\\r\\n\\r\\nexport abstract class ConsequentParselet {\\r\\n  constructor(\\r\\n    readonly tokenType: TokenType,\\r\\n    readonly associativity: 'left' | 'right'\\r\\n  ) {}\\r\\n  abstract parse(\\r\\n    parser: AbstractParser,\\r\\n    tokens: TokenStream,\\r\\n    left: AST.Node,\\r\\n    token: Token,\\r\\n    varMap: {[key: string]: string},\\r\\n    registeredNodes: {[key: string]: AST.Node},\\r\\n    dependsMap: {[key: string]: string[]}\\r\\n  ): AST.Node;\\r\\n}\\r\\n\\r\\nexport class BinaryOperatorParselet extends ConsequentParselet {\\r\\n  constructor(\\r\\n    public tokenType: BinaryOperationTokenType,\\r\\n    associativity: 'left' | 'right'\\r\\n  ) {\\r\\n    super(tokenType, associativity);\\r\\n  }\\r\\n\\r\\n  parse(\\r\\n    parser: AbstractParser,\\r\\n    tokens: TokenStream,\\r\\n    left: Exclude<Exclude<AST.Node, AST.ProgramNode>, undefined>,\\r\\n    token: Token,\\r\\n    varMap: {[key: string]: string},\\r\\n    registeredNodes: {[key: string]: AST.Node},\\r\\n    dependsMap: {[key: string]: string[]}\\r\\n  ): AST.Node {\\r\\n    const bindingPower = parser.bindingPower(token);\\r\\n\\r\\n    const right = parser.parse(\\r\\n      tokens,\\r\\n      this.associativity == 'left' ? bindingPower : bindingPower - 1,\\r\\n      varMap,\\r\\n      registeredNodes,\\r\\n      dependsMap\\r\\n    );\\r\\n    const position = join(left.pos, token2pos(tokens.last()));\\r\\n    const id = pos2string(position);\\r\\n    let newNode = {\\r\\n      nodeType: 'BinaryOperation' as 'BinaryOperation',\\r\\n      operator: this.tokenType,\\r\\n      left,\\r\\n      right,\\r\\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\\r\\n                    valueType: undefined,\\r\\n                    value: undefined},\\r\\n      pos: position,\\r\\n      nodeId: id\\r\\n    };\\r\\n    registeredNodes[id] = newNode;\\r\\n\\r\\n    return newNode;\\r\\n  }\\r\\n}\\r\\n\\r\\n// Parse function calls\\r\\n// Limitation: Functions are allowed to take exactly one argument\\r\\nexport class FunctionParselet implements InitialParselet {\\r\\n  \\r\\n  parse(parser: AbstractParser,\\r\\n    tokens: TokenStream,\\r\\n    token: Token,\\r\\n    varMap: {[key: string]: string},\\r\\n    registeredNodes: {[key: string]: AST.Node},\\r\\n    dependsMap: {[key: string]: string[]}) {\\r\\n\\r\\n    const position = token2pos(token);\\r\\n    const id = pos2string(position);\\r\\n    tokens.expectToken('(');\\r\\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\\r\\n    let args = [arg1];\\r\\n    if (token.text == \\\"ParseOrderedPair\\\") {\\r\\n      const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for second argument\\r\\n      args.push(arg2);\\r\\n    }\\r\\n    tokens.expectToken(')');\\r\\n    let newNode = {\\r\\n      nodeType: 'Function' as 'Function',\\r\\n      name: token.text,\\r\\n      args: args,\\r\\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\\r\\n                    valueType: undefined,\\r\\n                    value: undefined },\\r\\n      pos: position,\\r\\n      nodeId: id\\r\\n    };\\r\\n    registeredNodes[id] = newNode;\\r\\n    return newNode;\\r\\n  }\\r\\n}\\r\\n\\r\\nexport class ChooseParselet implements InitialParselet {\\r\\n  parse(parser: AbstractParser,\\r\\n    tokens: TokenStream,\\r\\n    token: Token,\\r\\n    varMap: {[key: string]: string},\\r\\n    registeredNodes: {[key: string]: AST.Node},\\r\\n    dependsMap: {[key: string]: string[]}) {\\r\\n    const position = token2pos(token);\\r\\n    const id = pos2string(position);\\r\\n\\r\\n    const predicate = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\\r\\n    const consequent = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\\r\\n    tokens.expectToken('CHOOSE2');\\r\\n    const otherwise = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\\r\\n\\r\\n    let newNode = {\\r\\n      nodeType: 'Choose' as 'Choose',\\r\\n      case: { predicate: predicate, consequent: consequent },\\r\\n      otherwise: otherwise,\\r\\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\\r\\n                    valueType: undefined,\\r\\n                    value: undefined },\\r\\n      pos: position,\\r\\n      nodeId: id\\r\\n    };\\r\\n    registeredNodes[id] = newNode;\\r\\n    return newNode;\\r\\n  }\\r\\n}\\r\\n\\r\\nexport class VariableAssignmentParselet implements InitialParselet {\\r\\n  parse(parser: AbstractParser,\\r\\n    tokens: TokenStream,\\r\\n    token: Token,\\r\\n    varMap: {[key: string]: string},\\r\\n    registeredNodes: {[key: string]: AST.Node},\\r\\n    dependsMap: {[key: string]: string[]}) {\\r\\n\\r\\n    const position = token2pos(token);\\r\\n    const id = pos2string(position);\\r\\n    \\r\\n    //is this a special '%' assignment or identifier?\\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n    // deal with variable assignment\\r\\n    tokens.expectToken('=');\\r\\n    const assignment = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\\r\\n\\r\\n\\r\\n    // need to save the variable and its assignment in a lookup table\\r\\n    varMap[token.text] = id;\\r\\n\\r\\n    if (token.text.indexOf(\\\"%\\\") != -1){\\r\\n\\r\\n      let newNode = {\\r\\n        nodeType: 'VariableAssignment' as 'VariableAssignment',\\r\\n        name: token.text,\\r\\n        assignment: assignment,\\r\\n        outputType: { status: \\\"Maybe-Undefined\\\" as \\\"Maybe-Undefined\\\",\\r\\n                      valueType: assignment?.outputType?.valueType,\\r\\n                      value: undefined },\\r\\n        pos: position,\\r\\n        nodeId: id\\r\\n      };\\r\\n      registeredNodes[id] = newNode;\\r\\n      dependsMap[id] = findBases(assignment, dependsMap); // NEW FUNCTION HERE\\r\\n      return newNode;\\r\\n\\r\\n    } else {\\r\\n      let newNode = {\\r\\n        nodeType: 'VariableAssignment' as 'VariableAssignment',\\r\\n        name: token.text,\\r\\n        assignment: assignment,\\r\\n        outputType: { status: \\\"Maybe-Undefined\\\" as \\\"Maybe-Undefined\\\",\\r\\n                      valueType: assignment?.outputType?.valueType,\\r\\n                      value: undefined },\\r\\n        pos: position,\\r\\n        nodeId: id\\r\\n      };\\r\\n      registeredNodes[id] = newNode;\\r\\n      dependsMap[id] = findBases(assignment, dependsMap); // NEW FUNCTION HERE\\r\\n      return newNode;\\r\\n    }\\r\\n\\r\\n \\r\\n\\r\\n  }\\r\\n}\\r\\n\\r\\nexport class IdentifierParselet implements InitialParselet {\\r\\n  parse(parser: AbstractParser,\\r\\n    tokens: TokenStream,\\r\\n    token: Token,\\r\\n    varMap: {[key: string]: string},\\r\\n    registeredNodes: {[key: string]: AST.Node},\\r\\n    dependsMap: {[key: string]: string[]}) {\\r\\n    \\r\\n    const position = token2pos(token);\\r\\n    const id = pos2string(position);\\r\\n    // need to look up known variables in a lookup table (map?)\\r\\n\\r\\n\\r\\n    const assignmentId = varMap[token.text];\\r\\n\\r\\n    if (!assignmentId) {\\r\\n      //if the variable is an assignment\\r\\n      const varParselet = new VariableAssignmentParselet();\\r\\n      return varParselet.parse(parser, tokens, token, varMap, registeredNodes, dependsMap);\\r\\n\\r\\n    }\\r\\n    else {\\r\\n      if (token.text.indexOf(\\\"%\\\") != -1){\\r\\n        let newNode = {\\r\\n          nodeType: 'RangeIdentifier' as 'RangeIdentifier',\\r\\n          name: token.text,\\r\\n          assignmentId: assignmentId,\\r\\n          outputType: { status: \\\"Maybe-Undefined\\\" as \\\"Maybe-Undefined\\\",\\r\\n                        valueType: undefined,\\r\\n                        value: undefined },\\r\\n          pos: position,\\r\\n          nodeId: id\\r\\n        };\\r\\n        registeredNodes[id] = newNode;\\r\\n        return newNode;\\r\\n      } else {\\r\\n        let newNode = {\\r\\n          nodeType: 'Identifier' as 'Identifier',\\r\\n          name: token.text,\\r\\n          assignmentId: assignmentId,\\r\\n          outputType: { status: \\\"Maybe-Undefined\\\" as \\\"Maybe-Undefined\\\",\\r\\n                        valueType: undefined,\\r\\n                        value: undefined },\\r\\n          pos: position,\\r\\n          nodeId: id\\r\\n        };\\r\\n        registeredNodes[id] = newNode;\\r\\n        return newNode;\\r\\n      }\\r\\n\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"]}"}