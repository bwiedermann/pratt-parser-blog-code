{"contents":"var _1_, _2_, _3_;\nvar _4_, _5_;\nvar _6_, _7_;\nvar _8_, _9_;\nvar _10_;\nvar _11_;\nvar _12_, _13_;\nvar _14_, _15_;\nvar _16_, _17_;\nvar _18_, _19_;\nvar _20_, _21_;\nvar _22_, _23_;\nvar _24_, _25_;\nvar _26_, _27_;\nfunction darCheck(nodes, registeredNodes) {\n  const errors = nodes.map(n => darCheckNode(n, nodes, registeredNodes));\n  return [].concat(...errors);\n}\nexports.darCheck = darCheck;\nfunction darCheckNode(node, nodes, registeredNodes) {\n  if (darCheckerMap != undefined && node.nodeType != undefined && darCheckerMap[node.nodeType] == undefined) {\n    return [];\n  } else {\n    return darCheckerMap[node.nodeType].darCheck(node, nodes, registeredNodes);\n  }\n}\nclass TypeError {\n  constructor(message, position) {\n    this.message = message;\n    this.position = position;\n  }\n}\nexports.TypeError = TypeError;\nclass DarCheckNumber {\n  darCheck(node) {\n    node.outputType.value = node.value;\n    return [];\n  }\n}\nclass DarCheckFunction {\n  darCheck(node, nodes, registeredNodes) {\n    const errors = [];\n    if (node.name == \"TestConstant\") {\n      darCheckNode(node.args[0], nodes, registeredNodes);\n      if (((_3_ = (_2_ = (_1_ = node) === null || _1_ === void 0 ? void 0 : _1_.args[0]) === null || _2_ === void 0 ? void 0 : _2_.outputType) === null || _3_ === void 0 ? void 0 : _3_.value) == undefined) {\n        errors.push(new TypeError(\"Input to TestConstant() is not constant\", node.pos));\n      }\n    }\n    return errors;\n  }\n}\nclass DarCheckBinary {\n  evaluateOperation(left, right, operator) {\n    if (typeof left == 'number' && typeof right == 'number') {\n      if (operator == \"+\") {\n        return left + right;\n      } else if (operator == \"-\") {\n        return left - right;\n      } else if (operator == \"*\") {\n        return left * right;\n      } else if (operator == \"/\") {\n        return left / right;\n      } else {\n        return 999999;\n      }\n    } else {\n      return undefined;\n    }\n  }\n  darCheck(node, nodes, registeredNodes) {\n    const errors = darCheckNode(node.left, nodes, registeredNodes).concat(darCheckNode(node.right, nodes, registeredNodes));\n    if (((_5_ = (_4_ = node.left) === null || _4_ === void 0 ? void 0 : _4_.outputType) === null || _5_ === void 0 ? void 0 : _5_.value) != undefined && ((_7_ = (_6_ = node.right) === null || _6_ === void 0 ? void 0 : _6_.outputType) === null || _7_ === void 0 ? void 0 : _7_.value) != undefined) {\n      node.outputType = {\n        status: node.outputType.status,\n        valueType: (_9_ = (_8_ = node.left) === null || _8_ === void 0 ? void 0 : _8_.outputType) === null || _9_ === void 0 ? void 0 : _9_.valueType,\n        value: this.evaluateOperation((_10_ = node.left) === null || _10_ === void 0 ? void 0 : _10_.outputType.value, (_11_ = node.right) === null || _11_ === void 0 ? void 0 : _11_.outputType.value, node.operator)\n      };\n    } else {\n      console.log(\"One or both sides has no 'value'\");\n    }\n    return errors;\n  }\n}\nclass DarCheckVariable {\n  darCheck(node, nodes, registeredNodes) {\n    darCheckNode(node.assignment, nodes, registeredNodes);\n    if (((_13_ = (_12_ = node.assignment) === null || _12_ === void 0 ? void 0 : _12_.outputType) === null || _13_ === void 0 ? void 0 : _13_.value) != undefined) {\n      node.outputType.value = node.assignment.outputType.value;\n    }\n    return [];\n  }\n}\nclass DarCheckIdentifier {\n  darCheck(node, nodes, registeredNodes) {\n    const assignmentNode = registeredNodes[node.assignmentId];\n    if (((_15_ = (_14_ = assignmentNode) === null || _14_ === void 0 ? void 0 : _14_.outputType) === null || _15_ === void 0 ? void 0 : _15_.value) != undefined) {\n      node.outputType.value = assignmentNode.outputType.value;\n    }\n    return [];\n  }\n}\nclass DarCheckIterator {\n  getRange(start, end, step) {\n    let current = start;\n    let out = [];\n    while (current < end) {\n      out.push(current);\n      current += step;\n    }\n    return out;\n  }\n  darCheck(node, nodes, registeredNodes) {\n    const errors = [];\n    darCheckNode(node.start, nodes, registeredNodes);\n    darCheckNode(node.end, nodes, registeredNodes);\n    darCheckNode(node.step, nodes, registeredNodes);\n    if (((_17_ = (_16_ = node.start) === null || _16_ === void 0 ? void 0 : _16_.outputType) === null || _17_ === void 0 ? void 0 : _17_.value) != undefined && ((_19_ = (_18_ = node.end) === null || _18_ === void 0 ? void 0 : _18_.outputType) === null || _19_ === void 0 ? void 0 : _19_.value) != undefined && ((_21_ = (_20_ = node.step) === null || _20_ === void 0 ? void 0 : _20_.outputType) === null || _21_ === void 0 ? void 0 : _21_.value) != undefined) {\n      const start = (_23_ = (_22_ = node.start) === null || _22_ === void 0 ? void 0 : _22_.outputType) === null || _23_ === void 0 ? void 0 : _23_.value;\n      const end = (_25_ = (_24_ = node.end) === null || _24_ === void 0 ? void 0 : _24_.outputType) === null || _25_ === void 0 ? void 0 : _25_.value;\n      const step = (_27_ = (_26_ = node.step) === null || _26_ === void 0 ? void 0 : _26_.outputType) === null || _27_ === void 0 ? void 0 : _27_.value;\n      console.log(\"start, end, step:\", start, end, step);\n      node.values = this.getRange(start, end, step);\n    } else {\n      console.log(\"Iterator used with non constant stuff\");\n      errors.push(new TypeError(\"Non constant value used in iterator decleration\", node.pos));\n    }\n    return errors;\n  }\n}\nconst darCheckerMap = {\n  'Number': new DarCheckNumber(),\n  'BinaryOperation': new DarCheckBinary(),\n  'Function': new DarCheckFunction(),\n  'VariableAssignment': new DarCheckVariable(),\n  'Identifier': new DarCheckIdentifier(),\n  'Iterator': new DarCheckIterator()\n};\n","sourceMap":"{\"version\":3,\"sources\":[\"src/darChecker.ts\"],\"names\":[\"nodes\",\"registeredNodes\",\"errors\",\"map\",\"n\",\"darCheckNode\",\"concat\",\"node\",\"darCheckerMap\",\"undefined\",\"nodeType\",\"darCheck\",\"constructor\",\"message\",\"position\",\"outputType\",\"value\",\"name\",\"args\",\"push\",\"TypeError\",\"pos\",\"evaluateOperation\",\"left\",\"right\",\"operator\",\"status\",\"valueType\",\"console\",\"log\",\"assignment\",\"assignmentNode\",\"assignmentId\",\"getRange\",\"start\",\"end\",\"step\",\"current\",\"out\",\"values\",\"DarCheckNumber\",\"DarCheckBinary\",\"DarCheckFunction\",\"DarCheckVariable\",\"DarCheckIdentifier\",\"DarCheckIterator\"],\"mappings\":\"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\",\"sourcesContent\":[\"import {Position} from './position';\\r\\nimport * as AST from './ast';\\r\\nimport {equals} from './equals';\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nexport function darCheck(nodes: AST.Node[],  registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n    const errors = nodes.map(n => darCheckNode(n, nodes, registeredNodes));\\r\\n    return ([] as TypeError[]).concat(...errors);\\r\\n}\\r\\n\\r\\nfunction darCheckNode(node: AST.Node, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n    if (darCheckerMap != undefined && node.nodeType != undefined && darCheckerMap[node.nodeType] == undefined){\\r\\n        return [];\\r\\n    }else{\\r\\n        return darCheckerMap[node.nodeType].darCheck(node, nodes, registeredNodes);\\r\\n    }\\r\\n}\\r\\n\\r\\nexport class TypeError {\\r\\n    constructor(public message: string, public position: Position) {}\\r\\n  }\\r\\n\\r\\nexport interface DarChecker {\\r\\n\\r\\n    darCheck(node: AST.Node,\\r\\n            nodes: AST.Node[], \\r\\n            registeredNodes: {[key: string]: AST.Node},): TypeError[];\\r\\n  }\\r\\n\\r\\nclass DarCheckNumber implements DarChecker {\\r\\n    darCheck(node: AST.NumberNode): TypeError[] {\\r\\n\\r\\n        //set the value in the outputType\\r\\n        node.outputType.value = node.value;\\r\\n        return [];\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n  class DarCheckFunction implements DarChecker{\\r\\n      darCheck(node: AST.FunctionNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}) : TypeError[]{\\r\\n        const errors: TypeError[] = [];\\r\\n        \\r\\n        if (node.name == \\\"TestConstant\\\"){\\r\\n            //do our test constant demo\\r\\n\\r\\n            //pre-check the arg (to assign value)\\r\\n            darCheckNode(node.args[0], nodes, registeredNodes)\\r\\n\\r\\n            //check if the argument has a value\\r\\n            if (node?.args[0]?.outputType?.value == undefined){\\r\\n                errors.push(new TypeError(\\\"Input to TestConstant() is not constant\\\", node.pos));\\r\\n            }\\r\\n\\r\\n        }\\r\\n        return errors;\\r\\n      }\\r\\n  }\\r\\n\\r\\nclass DarCheckBinary implements DarChecker {\\r\\n\\r\\n\\r\\n    evaluateOperation(left : number, right : number, operator : string): number | undefined {\\r\\n\\r\\n        //check to make sure left & right are numbers\\r\\n        if (typeof(left) == 'number' && typeof(right) == 'number' ){\\r\\n            if (operator == \\\"+\\\"){\\r\\n                return left + right\\r\\n            } else if (operator == \\\"-\\\"){\\r\\n                return left - right\\r\\n            } else if (operator == \\\"*\\\"){\\r\\n                return left * right\\r\\n            } else if (operator ==\\\"/\\\"){\\r\\n                return left / right\\r\\n            } else {\\r\\n                return 999999\\r\\n            }\\r\\n        } else {\\r\\n            //one or both sides is a non-number. We only care about numbers\\r\\n            return undefined\\r\\n        }\\r\\n    }\\r\\n\\r\\n    darCheck(node: AST.BinaryOperationNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n        const errors: TypeError[] = darCheckNode(node.left, nodes, registeredNodes).concat(darCheckNode(node.right, nodes, registeredNodes));\\r\\n        \\r\\n        //check if outputType of both left and right is constant\\r\\n        if (node.left?.outputType?.value != undefined && node.right?.outputType?.value != undefined){\\r\\n            \\r\\n            //evaluate the operation and set the value\\r\\n            node.outputType = {\\r\\n                status : node.outputType!.status,\\r\\n                valueType: node.left?.outputType?.valueType,\\r\\n                value: this.evaluateOperation(node.left?.outputType.value, node.right?.outputType.value, node.operator) \\r\\n            }\\r\\n            \\r\\n   \\r\\n        } else{\\r\\n            //One or both of the left + right does NOT have a value\\r\\n            console.log(\\\"One or both sides has no 'value'\\\");\\r\\n        }\\r\\n   \\r\\n        return errors;\\r\\n    }\\r\\n}\\r\\n\\r\\nclass DarCheckVariable implements DarChecker {\\r\\n    darCheck(node: AST.VariableAssignmentNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n\\r\\n\\r\\n        //check the assignment (and propagate value, if applicable)\\r\\n        darCheckNode(node.assignment, nodes, registeredNodes);\\r\\n\\r\\n        //does the assignment node have a value\\r\\n        if (node.assignment?.outputType?.value != undefined){\\r\\n            //set value of this node to the value of the assignment\\r\\n            node.outputType.value = node.assignment.outputType.value;\\r\\n        }\\r\\n\\r\\n        return [];\\r\\n    }\\r\\n}\\r\\n\\r\\nclass DarCheckIdentifier implements DarChecker {\\r\\n    darCheck(node: AST.IdentifierNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n\\r\\n        //grab the assignment node that this ident refrences\\r\\n        const assignmentNode = registeredNodes[node.assignmentId];\\r\\n\\r\\n        if (assignmentNode?.outputType?.value != undefined){\\r\\n            //set value of this node to the value of the assignment\\r\\n            node.outputType.value = assignmentNode.outputType.value;\\r\\n        }\\r\\n\\r\\n        return [];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  class DarCheckIterator implements DarChecker {\\r\\n\\r\\n    getRange(start: number, end: number, step: number): number[]{\\r\\n        let current = start;\\r\\n        let out = [];\\r\\n        while (current < end){\\r\\n            out.push(current);\\r\\n            current += step;\\r\\n        }\\r\\n        return out;\\r\\n    }\\r\\n    darCheck(node: AST.IteratorNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\\r\\n        const errors: TypeError[] = [];\\r\\n\\r\\n        //pre-check nodes\\r\\n        darCheckNode(node.start, nodes, registeredNodes);\\r\\n        darCheckNode(node.end, nodes, registeredNodes);\\r\\n        darCheckNode(node.step, nodes, registeredNodes);\\r\\n\\r\\n\\r\\n        //calculate range\\r\\n\\r\\n        if (node.start?.outputType?.value != undefined && node.end?.outputType?.value != undefined && node.step?.outputType?.value != undefined){\\r\\n            //if start, end, and step all are constant numbers\\r\\n\\r\\n            const start = node.start?.outputType?.value;\\r\\n            const end = node.end?.outputType?.value;\\r\\n            const step = node.step?.outputType?.value;\\r\\n\\r\\n            console.log(\\\"start, end, step:\\\", start, end, step);\\r\\n\\r\\n            node.values = this.getRange(start, end, step);\\r\\n        } else {\\r\\n            console.log(\\\"Iterator used with non constant stuff\\\")\\r\\n            errors.push(new TypeError(\\\"Non constant value used in iterator decleration\\\", node.pos));\\r\\n        }\\r\\n\\r\\n\\r\\n        return errors;\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n\\r\\nconst darCheckerMap: Partial<{[K in AST.NodeType]: DarChecker}> = {\\r\\n'Number' : new DarCheckNumber(),\\r\\n//'Boolean' : new CheckBoolean(),\\r\\n'BinaryOperation' : new DarCheckBinary(),\\r\\n'Function' : new DarCheckFunction(),\\r\\n//'Choose': new CheckChoose(),\\r\\n'VariableAssignment': new DarCheckVariable(),\\r\\n'Identifier': new DarCheckIdentifier(),\\r\\n'Iterator': new DarCheckIterator(),\\r\\n}\"]}"}