{"contents":"exports.__esModule = true;\nvar lezer_tree_1 = __fusereq(23);\nvar text_1 = __fusereq(26);\nvar state_1 = __fusereq(15);\nvar view_1 = __fusereq(14);\nconst languageDataProp = new lezer_tree_1.NodeProp();\nfunction defineLanguageFacet(baseData) {\n  return state_1.Facet.define({\n    combine: baseData ? values => values.concat(baseData) : undefined\n  });\n}\nclass Language {\n  constructor(data, parser, topNode, extraExtensions = []) {\n    this.data = data;\n    this.topNode = topNode;\n    if (!state_1.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(state_1.EditorState.prototype, \"tree\", {\n      get() {\n        return syntaxTree(this);\n      }\n    });\n    this.parser = parser;\n    this.extension = [language.of(this), state_1.EditorState.languageData.of((state, pos) => state.facet(languageDataFacetAt(state, pos)))].concat(extraExtensions);\n  }\n  isActiveAt(state, pos) {\n    return languageDataFacetAt(state, pos) == this.data;\n  }\n  findRegions(state) {\n    let lang = state.facet(language);\n    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [{\n      from: 0,\n      to: state.doc.length\n    }];\n    if (!lang || !lang.allowsNesting) return [];\n    let result = [];\n    syntaxTree(state).iterate({\n      enter: (type, from, to) => {\n        if (type.isTop && type.prop(languageDataProp) == this.data) {\n          result.push({\n            from,\n            to\n          });\n          return false;\n        }\n        return undefined;\n      }\n    });\n    return result;\n  }\n  get allowsNesting() {\n    return true;\n  }\n  parseString(code) {\n    let doc = text_1.Text.of(code.split(\"\\n\"));\n    let parse = this.parser.startParse(new DocInput(doc), 0, new EditorParseContext(this.parser, state_1.EditorState.create({\n      doc\n    }), [], lezer_tree_1.Tree.empty, {\n      from: 0,\n      to: code.length\n    }, []));\n    let tree;\n    while (!(tree = parse.advance())) {}\n    return tree;\n  }\n}\nLanguage.setState = state_1.StateEffect.define();\nfunction languageDataFacetAt(state, pos) {\n  let topLang = state.facet(language);\n  if (!topLang) return null;\n  if (!topLang.allowsNesting) return topLang.data;\n  let tree = syntaxTree(state);\n  let target = tree.resolve(pos, -1);\n  while (target) {\n    let facet = target.type.prop(languageDataProp);\n    if (facet) return facet;\n    target = target.parent;\n  }\n  return topLang.data;\n}\nclass LezerLanguage extends Language {\n  constructor(data, parser) {\n    super(data, parser, parser.topNode);\n    this.parser = parser;\n  }\n  static define(spec) {\n    let data = defineLanguageFacet(spec.languageData);\n    return new LezerLanguage(data, spec.parser.configure({\n      props: [languageDataProp.add(type => type.isTop ? data : undefined)]\n    }));\n  }\n  configure(options) {\n    return new LezerLanguage(this.data, this.parser.configure(options));\n  }\n  get allowsNesting() {\n    return this.parser.hasNested;\n  }\n}\nfunction syntaxTree(state) {\n  let field = state.field(Language.state, false);\n  return field ? field.tree : lezer_tree_1.Tree.empty;\n}\nfunction ensureSyntaxTree(state, upto, timeout = 50) {\n  var _a;\n  let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n  return !parse ? null : parse.tree.length >= upto || parse.work(timeout, upto) ? parse.tree : null;\n}\nclass DocInput {\n  constructor(doc, length = doc.length) {\n    this.doc = doc;\n    this.length = length;\n    this.cursorPos = 0;\n    this.string = \"\";\n    this.prevString = \"\";\n    this.cursor = doc.iter();\n  }\n  syncTo(pos) {\n    if (pos < this.cursorPos) {\n      this.cursor = this.doc.iter();\n      this.cursorPos = 0;\n    }\n    this.prevString = pos == this.cursorPos ? this.string : \"\";\n    this.string = this.cursor.next(pos - this.cursorPos).value;\n    this.cursorPos = pos + this.string.length;\n    return this.cursorPos - this.string.length;\n  }\n  get(pos) {\n    if (pos >= this.length) return -1;\n    let stringStart = this.cursorPos - this.string.length;\n    if (pos < stringStart || pos >= this.cursorPos) {\n      if (pos < stringStart && pos >= stringStart - this.prevString.length) return this.prevString.charCodeAt(pos - (stringStart - this.prevString.length));\n      stringStart = this.syncTo(pos);\n    }\n    return this.string.charCodeAt(pos - stringStart);\n  }\n  lineAfter(pos) {\n    if (pos >= this.length || pos < 0) return \"\";\n    let stringStart = this.cursorPos - this.string.length;\n    if (pos < stringStart || pos >= this.cursorPos) stringStart = this.syncTo(pos);\n    return this.cursor.lineBreak ? \"\" : this.string.slice(pos - stringStart);\n  }\n  read(from, to) {\n    let stringStart = this.cursorPos - this.string.length;\n    if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to); else return this.string.slice(from - stringStart, to - stringStart);\n  }\n  clip(at) {\n    return new DocInput(this.doc, at);\n  }\n}\nclass EditorParseContext {\n  constructor(parser, state, fragments = [], tree, viewport, skipped) {\n    this.parser = parser;\n    this.state = state;\n    this.fragments = fragments;\n    this.tree = tree;\n    this.viewport = viewport;\n    this.skipped = skipped;\n    this.parse = null;\n    this.tempSkipped = [];\n  }\n  work(time, upto) {\n    if (this.tree != lezer_tree_1.Tree.empty && (upto == null ? this.tree.length == this.state.doc.length : this.tree.length >= upto)) {\n      this.takeTree();\n      return true;\n    }\n    if (!this.parse) this.parse = this.parser.startParse(new DocInput(this.state.doc), 0, this);\n    let endTime = Date.now() + time;\n    for (; ; ) {\n      let done = this.parse.advance();\n      if (done) {\n        this.fragments = this.withoutTempSkipped(lezer_tree_1.TreeFragment.addTree(done));\n        this.parse = null;\n        this.tree = done;\n        return true;\n      } else if (upto != null && this.parse.pos >= upto) {\n        this.takeTree();\n        return true;\n      }\n      if (Date.now() > endTime) return false;\n    }\n  }\n  takeTree() {\n    if (this.parse && this.parse.pos > this.tree.length) {\n      this.tree = this.parse.forceFinish();\n      this.fragments = this.withoutTempSkipped(lezer_tree_1.TreeFragment.addTree(this.tree, this.fragments, true));\n    }\n  }\n  withoutTempSkipped(fragments) {\n    for (let r; r = this.tempSkipped.pop(); ) fragments = cutFragments(fragments, r.from, r.to);\n    return fragments;\n  }\n  changes(changes, newState) {\n    let {fragments, tree, viewport, skipped} = this;\n    this.takeTree();\n    if (!changes.empty) {\n      let ranges = [];\n      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({\n        fromA,\n        toA,\n        fromB,\n        toB\n      }));\n      fragments = lezer_tree_1.TreeFragment.applyChanges(fragments, ranges);\n      tree = lezer_tree_1.Tree.empty;\n      viewport = {\n        from: changes.mapPos(viewport.from, -1),\n        to: changes.mapPos(viewport.to, 1)\n      };\n      if (this.skipped.length) {\n        skipped = [];\n        for (let r of this.skipped) {\n          let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n          if (from < to) skipped.push({\n            from,\n            to\n          });\n        }\n      }\n    }\n    return new EditorParseContext(this.parser, newState, fragments, tree, viewport, skipped);\n  }\n  updateViewport(viewport) {\n    this.viewport = viewport;\n    let startLen = this.skipped.length;\n    for (let i = 0; i < this.skipped.length; i++) {\n      let {from, to} = this.skipped[i];\n      if (from < viewport.to && to > viewport.from) {\n        this.fragments = cutFragments(this.fragments, from, to);\n        this.skipped.splice(i--, 1);\n      }\n    }\n    return this.skipped.length < startLen;\n  }\n  reset() {\n    if (this.parse) {\n      this.takeTree();\n      this.parse = null;\n    }\n  }\n  skipUntilInView(from, to) {\n    this.skipped.push({\n      from,\n      to\n    });\n  }\n  movedPast(pos) {\n    return this.tree.length < pos && this.parse && this.parse.pos >= pos;\n  }\n}\nEditorParseContext.skippingParser = {\n  startParse(input, startPos, context) {\n    return {\n      pos: startPos,\n      advance() {\n        context.tempSkipped.push({\n          from: startPos,\n          to: input.length\n        });\n        this.pos = input.length;\n        return new lezer_tree_1.Tree(lezer_tree_1.NodeType.none, [], [], input.length - startPos);\n      },\n      forceFinish() {\n        return this.advance();\n      }\n    };\n  }\n};\nfunction cutFragments(fragments, from, to) {\n  return lezer_tree_1.TreeFragment.applyChanges(fragments, [{\n    fromA: from,\n    toA: to,\n    fromB: from,\n    toB: to\n  }]);\n}\nclass LanguageState {\n  constructor(context) {\n    this.context = context;\n    this.tree = context.tree;\n  }\n  apply(tr) {\n    if (!tr.docChanged) return this;\n    let newCx = this.context.changes(tr.changes, tr.state);\n    let upto = this.context.tree.length == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.tree.length), newCx.viewport.to);\n    if (!newCx.work(25, upto)) newCx.takeTree();\n    return new LanguageState(newCx);\n  }\n  static init(state) {\n    let parseState = new EditorParseContext(state.facet(language).parser, state, [], lezer_tree_1.Tree.empty, {\n      from: 0,\n      to: state.doc.length\n    }, []);\n    if (!parseState.work(25)) parseState.takeTree();\n    return new LanguageState(parseState);\n  }\n}\nLanguage.state = state_1.StateField.define({\n  create: LanguageState.init,\n  update(value, tr) {\n    for (let e of tr.effects) if (e.is(Language.setState)) return e.value;\n    if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n    return value.apply(tr);\n  }\n});\nlet requestIdle = typeof window != \"undefined\" && window.requestIdleCallback || ((callback, {timeout}) => setTimeout(callback, timeout));\nlet cancelIdle = typeof window != \"undefined\" && window.cancelIdleCallback || clearTimeout;\nconst parseWorker = view_1.ViewPlugin.fromClass(class ParseWorker {\n  constructor(view) {\n    this.view = view;\n    this.working = -1;\n    this.chunkEnd = -1;\n    this.chunkBudget = -1;\n    this.work = this.work.bind(this);\n    this.scheduleWork();\n  }\n  update(update) {\n    if (update.viewportChanged) {\n      let cx = this.view.state.field(Language.state).context;\n      if (cx.updateViewport(update.view.viewport)) cx.reset();\n      if (this.view.viewport.to > cx.tree.length) this.scheduleWork();\n    }\n    if (update.docChanged) {\n      if (this.view.hasFocus) this.chunkBudget += 50;\n      this.scheduleWork();\n    }\n  }\n  scheduleWork() {\n    if (this.working > -1) return;\n    let {state} = this.view, field = state.field(Language.state);\n    if (field.tree.length >= state.doc.length) return;\n    this.working = requestIdle(this.work, {\n      timeout: 500\n    });\n  }\n  work(deadline) {\n    this.working = -1;\n    let now = Date.now();\n    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n      this.chunkEnd = now + 30000;\n      this.chunkBudget = 3000;\n    }\n    if (this.chunkBudget <= 0) return;\n    let {state, viewport: {to: vpTo}} = this.view, field = state.field(Language.state);\n    if (field.tree.length >= vpTo + 1000000) return;\n    let time = Math.min(this.chunkBudget, deadline ? Math.max(25, deadline.timeRemaining()) : 100);\n    let done = field.context.work(time, vpTo + 1000000);\n    this.chunkBudget -= Date.now() - now;\n    if (done || this.chunkBudget <= 0 || field.context.movedPast(vpTo)) {\n      field.context.takeTree();\n      this.view.dispatch({\n        effects: Language.setState.of(new LanguageState(field.context))\n      });\n    }\n    if (!done && this.chunkBudget > 0) this.scheduleWork();\n  }\n  destroy() {\n    if (this.working >= 0) cancelIdle(this.working);\n  }\n}, {\n  eventHandlers: {\n    focus() {\n      this.scheduleWork();\n    }\n  }\n});\nconst language = state_1.Facet.define({\n  combine(languages) {\n    return languages.length ? languages[0] : null;\n  },\n  enables: [Language.state, parseWorker]\n});\nclass LanguageSupport {\n  constructor(language, support = []) {\n    this.language = language;\n    this.support = support;\n    this.extension = [language, support];\n  }\n}\nclass LanguageDescription {\n  constructor(name, alias, extensions, filename, loadFunc) {\n    this.name = name;\n    this.alias = alias;\n    this.extensions = extensions;\n    this.filename = filename;\n    this.loadFunc = loadFunc;\n    this.support = undefined;\n    this.loading = null;\n  }\n  load() {\n    return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => {\n      this.loading = null;\n      throw err;\n    }));\n  }\n  static of(spec) {\n    return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, spec.load);\n  }\n  static matchFilename(descs, filename) {\n    for (let d of descs) if (d.filename && d.filename.test(filename)) return d;\n    let ext = (/\\.([^.]+)$/).exec(filename);\n    if (ext) for (let d of descs) if (d.extensions.indexOf(ext[1]) > -1) return d;\n    return null;\n  }\n  static matchLanguageName(descs, name, fuzzy = true) {\n    name = name.toLowerCase();\n    for (let d of descs) if (d.alias.some(a => a == name)) return d;\n    if (fuzzy) for (let d of descs) for (let a of d.alias) {\n      let found = name.indexOf(a);\n      if (found > -1 && (a.length > 2 || !(/\\w/).test(name[found - 1]) && !(/\\w/).test(name[found + a.length]))) return d;\n    }\n    return null;\n  }\n}\nconst indentService = state_1.Facet.define();\nconst indentUnit = state_1.Facet.define({\n  combine: values => {\n    if (!values.length) return \"  \";\n    if (!(/^(?: +|\\t+)$/).test(values[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n    return values[0];\n  }\n});\nfunction getIndentUnit(state) {\n  let unit = state.facet(indentUnit);\n  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\nfunction indentString(state, cols) {\n  let result = \"\", ts = state.tabSize;\n  if (state.facet(indentUnit).charCodeAt(0) == 9) while (cols >= ts) {\n    result += \"\\t\";\n    cols -= ts;\n  }\n  for (let i = 0; i < cols; i++) result += \" \";\n  return result;\n}\nfunction getIndentation(context, pos) {\n  if (context instanceof state_1.EditorState) context = new IndentContext(context);\n  for (let service of context.state.facet(indentService)) {\n    let result = service(context, pos);\n    if (result != null) return result;\n  }\n  let tree = syntaxTree(context.state);\n  return tree ? syntaxIndentation(context, tree, pos) : null;\n}\nclass IndentContext {\n  constructor(state, options = {}) {\n    this.state = state;\n    this.options = options;\n    this.unit = getIndentUnit(state);\n  }\n  textAfterPos(pos) {\n    var _a, _b;\n    let sim = (_a = this.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;\n    if (pos == sim && ((_b = this.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak)) return \"\";\n    return this.state.sliceDoc(pos, Math.min(pos + 100, sim != null && sim > pos ? sim : 1e9, this.state.doc.lineAt(pos).to));\n  }\n  column(pos) {\n    var _a;\n    let line = this.state.doc.lineAt(pos), text = line.text.slice(0, pos - line.from);\n    let result = this.countColumn(text, pos - line.from);\n    let override = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation) ? this.options.overrideIndentation(line.from) : -1;\n    if (override > -1) result += override - this.countColumn(text, text.search(/\\S/));\n    return result;\n  }\n  countColumn(line, pos) {\n    return text_1.countColumn(pos < 0 ? line : line.slice(0, pos), 0, this.state.tabSize);\n  }\n  lineIndent(line) {\n    var _a;\n    let override = (_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation;\n    if (override) {\n      let overriden = override(line.from);\n      if (overriden > -1) return overriden;\n    }\n    return this.countColumn(line.text, line.text.search(/\\S/));\n  }\n}\nconst indentNodeProp = new lezer_tree_1.NodeProp();\nfunction syntaxIndentation(cx, ast, pos) {\n  let tree = ast.resolve(pos);\n  for (let scan = tree, scanPos = pos; ; ) {\n    let last = scan.childBefore(scanPos);\n    if (!last) break;\n    if (last.type.isError && last.from == last.to) {\n      tree = scan;\n      scanPos = last.from;\n    } else {\n      scan = last;\n      scanPos = scan.to + 1;\n    }\n  }\n  return indentFrom(tree, pos, cx);\n}\nfunction ignoreClosed(cx) {\n  var _a, _b;\n  return cx.pos == ((_a = cx.options) === null || _a === void 0 ? void 0 : _a.simulateBreak) && ((_b = cx.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak);\n}\nfunction indentStrategy(tree) {\n  let strategy = tree.type.prop(indentNodeProp);\n  if (strategy) return strategy;\n  let first = tree.firstChild, close;\n  if (first && (close = first.type.prop(lezer_tree_1.NodeProp.closedBy))) {\n    let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n    return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n  }\n  return tree.parent == null ? topIndent : null;\n}\nfunction indentFrom(node, pos, base) {\n  for (; node; node = node.parent) {\n    let strategy = indentStrategy(node);\n    if (strategy) return strategy(new TreeIndentContext(base, pos, node));\n  }\n  return null;\n}\nfunction topIndent() {\n  return 0;\n}\nclass TreeIndentContext extends IndentContext {\n  constructor(base, pos, node) {\n    super(base.state, base.options);\n    this.base = base;\n    this.pos = pos;\n    this.node = node;\n  }\n  get textAfter() {\n    return this.textAfterPos(this.pos);\n  }\n  get baseIndent() {\n    let line = this.state.doc.lineAt(this.node.from);\n    for (; ; ) {\n      let atBreak = this.node.resolve(line.from);\n      while (atBreak.parent && atBreak.parent.from == atBreak.from) atBreak = atBreak.parent;\n      if (isParent(atBreak, this.node)) break;\n      line = this.state.doc.lineAt(atBreak.from);\n    }\n    return this.lineIndent(line);\n  }\n  continue() {\n    let parent = this.node.parent;\n    return parent ? indentFrom(parent, this.pos, this.base) : 0;\n  }\n}\nfunction isParent(parent, of) {\n  for (let cur = of; cur; cur = cur.parent) if (parent == cur) return true;\n  return false;\n}\nfunction bracketedAligned(context) {\n  var _a;\n  let tree = context.node;\n  let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n  if (!openToken) return null;\n  let sim = (_a = context.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;\n  let openLine = context.state.doc.lineAt(openToken.from);\n  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n  for (let pos = openToken.to; ; ) {\n    let next = tree.childAfter(pos);\n    if (!next || next == last) return null;\n    if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;\n    pos = next.to;\n  }\n}\nfunction delimitedIndent({closing, align = true, units = 1}) {\n  return context => delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n  let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n  let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n  let aligned = align ? bracketedAligned(context) : null;\n  if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n  return context.baseIndent + (closed ? 0 : context.unit * units);\n}\nconst flatIndent = context => context.baseIndent;\nfunction continuedIndent({except, units = 1} = {}) {\n  return context => {\n    let matchExcept = except && except.test(context.textAfter);\n    return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n  };\n}\nconst DontIndentBeyond = 200;\nfunction indentOnInput() {\n  return state_1.EditorState.transactionFilter.of(tr => {\n    if (!tr.docChanged || tr.annotation(state_1.Transaction.userEvent) != \"input\") return tr;\n    let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n    if (!rules.length) return tr;\n    let doc = tr.newDoc, {head} = tr.newSelection.main, line = doc.lineAt(head);\n    if (head > line.from + DontIndentBeyond) return tr;\n    let lineStart = doc.sliceString(line.from, head);\n    if (!rules.some(r => r.test(lineStart))) return tr;\n    let {state} = tr, last = -1, changes = [];\n    for (let {head} of state.selection.ranges) {\n      let line = state.doc.lineAt(head);\n      if (line.from == last) continue;\n      last = line.from;\n      let indent = getIndentation(state, line.from);\n      if (indent == null) continue;\n      let cur = (/^\\s*/).exec(line.text)[0];\n      let norm = indentString(state, indent);\n      if (cur != norm) changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n    return changes.length ? [tr, {\n      changes\n    }] : tr;\n  });\n}\nconst foldService = state_1.Facet.define();\nconst foldNodeProp = new lezer_tree_1.NodeProp();\nfunction foldInside(node) {\n  let first = node.firstChild, last = node.lastChild;\n  return first && first.to < last.from ? {\n    from: first.to,\n    to: last.type.isError ? node.to : last.from\n  } : null;\n}\nfunction syntaxFolding(state, start, end) {\n  let tree = syntaxTree(state);\n  if (tree.length == 0) return null;\n  let inner = tree.resolve(end);\n  let found = null;\n  for (let cur = inner; cur; cur = cur.parent) {\n    if (cur.to <= end || cur.from > end) continue;\n    if (found && cur.from < start) break;\n    let prop = cur.type.prop(foldNodeProp);\n    if (prop) {\n      let value = prop(cur, state);\n      if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n    }\n  }\n  return found;\n}\nfunction foldable(state, lineStart, lineEnd) {\n  for (let service of state.facet(foldService)) {\n    let result = service(state, lineStart, lineEnd);\n    if (result) return result;\n  }\n  return syntaxFolding(state, lineStart, lineEnd);\n}\nexports.EditorParseContext = EditorParseContext;\nexports.IndentContext = IndentContext;\nexports.Language = Language;\nexports.LanguageDescription = LanguageDescription;\nexports.LanguageSupport = LanguageSupport;\nexports.LezerLanguage = LezerLanguage;\nexports.TreeIndentContext = TreeIndentContext;\nexports.continuedIndent = continuedIndent;\nexports.defineLanguageFacet = defineLanguageFacet;\nexports.delimitedIndent = delimitedIndent;\nexports.ensureSyntaxTree = ensureSyntaxTree;\nexports.flatIndent = flatIndent;\nexports.foldInside = foldInside;\nexports.foldNodeProp = foldNodeProp;\nexports.foldService = foldService;\nexports.foldable = foldable;\nexports.getIndentUnit = getIndentUnit;\nexports.getIndentation = getIndentation;\nexports.indentNodeProp = indentNodeProp;\nexports.indentOnInput = indentOnInput;\nexports.indentService = indentService;\nexports.indentString = indentString;\nexports.indentUnit = indentUnit;\nexports.language = language;\nexports.languageDataProp = languageDataProp;\nexports.syntaxTree = syntaxTree;\n"}