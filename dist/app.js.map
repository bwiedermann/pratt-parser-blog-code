{"version":3,"sources":["src/lexer.ts","src/typechecker.ts","src/darChecker.ts","src/position.ts","src/findBase.ts","src/parselet.ts","src/tokenstream.ts","src/parser.ts","src/parseResults.ts","src/miniCL.ts","src/visualization.ts","src/devTools.ts","src/index.ts"],"names":["text","tokens","state","line","stack","split","stream","stream_parser_1","string","eol","token","getToken","emitToken","makeEmit","fullToken","undefined","push","start","pos","Error","length","getDefaultToken","type","first_column","last_column","current","eatSpace","match","next","nodes","registeredNodes","errors","map","n","typecheckNode","concat","node","nodeType","checkerMap","check","constructor","message","position","left","right","outputType","valueType","TypeError","operator","arg1Errors","args","arg2Errors","functionName","name","argType","builtins","inputType","predicate","case","consequent","otherwise","predErrors","consErrors","otherErrors","assignmentErrors","assignment","assignmentNode","assignmentId","valueNode","resultType","CheckNumber","CheckBoolean","CheckBinary","CheckFunction","CheckChoose","CheckVariable","CheckIdentifier","CheckIterator","CheckRangeIdentifier","darCheckNode","darCheckerMap","darCheck","value","evaluateOperation","status","console","log","getRange","end","step","out","values","DarCheckNumber","DarCheckAny","DarCheckBinary","DarCheckFunction","DarCheckVariable","DarCheckIdentifier","DarCheckIterator","first_line","last_line","toString","dependsMap","baseMap","findBase","baseList","leftList","findBases","rightList","nodeId","i","consBases","otherBases","BaseNumber","BaseBoolean","BaseBinary","BaseFunction","BaseChoose","BaseVariableAssignment","BaseIdentifier","BaseIterator","parse","_parser","_tokens","varMap","position_1","id","newNode","parseFloat","parser","_token","exp","expectToken","arg1","arg2","arg3","index","tokenType","associativity","ConsequentParselet","bindingPower","last","indexOf","findBase_1","varParselet","VariableAssignmentParselet","lexer_1","filter","t","consume","peek","expectedType","actual","tokenstream_1","Parser","e","bindingPowers","bindingClasses","Object","keys","consequentMap","currentBindingPower","initialParselet","initialMap","consequentParselet","AbstractParser","NUMBER","NumberParselet","TRUE","BooleanParselet","FALSE","ParenParselet","BracketParselet","FUNCTION","FunctionParselet","CHOOSE1","ChooseParselet","IDENTIFIER","IdentifierParselet","BinaryOperatorParselet","classes","state_1","define","create","emptyParseResults","update","tr","docChanged","parseProgram","contents","doc","ast","parser_1","parseErrors","startState","token2tag","view","results","field","parseResults_1","assertMap","darErrors","darChecker_1","typeErrors","typechecker_1","parseDiagnostics","makeDiagnostic","typeDiagnostics","darDiagnostics","severity","error","from","firstLine","to","lastLine","margin","top","bottom","height","width","select","selectAll","remove","viz","append","attr","root","children","treemap","tree","size","separation","treelayout","hierarchy","getChildren","g","link","data","links","linkEnter","enter","connection","descendants","nodeEnter","d","y","x","getFill","isUndefined","style","call","getTextBox","datum","getText","clone","lower","yep","insert","bbox","selection","each","getBBox","linkHorizontal","astJSON","JSON","stringify","replaceContents","astViewer","dependsJSON","dependsViewer","visualization_1","basic_setup_1","extensions","lang_json_1","lint_1","editable","of","newJSONViewerState","parent","document","querySelector","editor","changes","fold_1","miniCLEditor","miniCL_1","dispatch","updateOutput","devTools_1"],"mappings":"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","file":"","sourcesContent":["import {StringStream} from \"@codemirror/stream-parser\"\r\n\r\nexport function getTokens(text: string): Token[] {\r\n  const tokens: Token[] = [];\r\n  const state: State = {line: 1, stack: ['default']};\r\n\r\n  for (const line of text.split('\\n')) {\r\n    const stream = new StringStream(line, 4, 1);\r\n    stream.string = line;\r\n    while (!stream.eol()) {\r\n      const token = getToken(stream, state);\r\n      const emitToken = makeEmit(stream, state);\r\n      const fullToken = emitToken(token as TokenType);\r\n      if (token != undefined) {\r\n        tokens.push(fullToken);\r\n      }\r\n\r\n      if (stream.start == stream.pos) {\r\n        throw new Error(\r\n          `getToken failed to advance stream at position ${\r\n            stream.pos\r\n          } in string ${stream.string}`,\r\n        );\r\n      }\r\n      stream.start = stream.pos;\r\n    }\r\n\r\n    state.line += 1;\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\nexport function getToken(\r\n  stream: StringStream,\r\n  state: State,\r\n): string | undefined {\r\n  //Built for codeMirror streams API\r\n  //State is a stack of states\r\n  switch (state.stack[state.stack.length - 1]) {\r\n    default:\r\n      return getDefaultToken(stream, state);\r\n  }\r\n}\r\n\r\nfunction makeEmit(stream: StringStream, state: State) {\r\n  return function emitToken(type: TokenType): Token {\r\n    return {\r\n      type,\r\n      first_column: stream.start,\r\n      last_column: stream.pos,\r\n      line: state.line,\r\n      text: stream.current(),\r\n    };\r\n  };\r\n}\r\n\r\nexport function getDefaultToken(\r\n  stream: StringStream,\r\n  state: State,\r\n): string | undefined {\r\n  // const emitToken = makeEmit(stream, state);\r\n  if (stream.eatSpace()) {\r\n    // skip whitespace\r\n    return undefined;\r\n  }\r\n\r\n  if (stream.match(/\\+/)) {\r\n    return '+';\r\n  }\r\n\r\n  if (stream.match(/\\-/)) {\r\n    return '-';\r\n  }\r\n\r\n  if (stream.match(/\\*/)) {\r\n    return '*';\r\n  }\r\n\r\n  if (stream.match(/\\//)) {\r\n    return '/';\r\n  }\r\n\r\n  if (stream.match(/\\|/)) {\r\n    return '|';\r\n  }\r\n\r\n  if (stream.match(/\\&/)) {\r\n    return '&';\r\n  }\r\n\r\n  if (stream.match(/\\(/)) {\r\n    return '(';\r\n  }\r\n\r\n  if (stream.match(/\\)/)) {\r\n    return ')';\r\n  }\r\n\r\n  if (stream.match(/\\[/)) {\r\n    return '[';\r\n  }\r\n\r\n  if (stream.match(/\\]/)) {\r\n    return ']';\r\n  }\r\n\r\n  // adding an equals operator\r\n  if (stream.match(/\\=/)) {\r\n    return '=';\r\n  }\r\n\r\n  if (stream.match(/-?[0-9]+(\\.[0-9]+)?/)) {\r\n    return 'NUMBER';\r\n  }\r\n\r\n  if (stream.match(/True/)) {\r\n    return 'TRUE';\r\n  }\r\n\r\n  if (stream.match(/False/)) {\r\n    return 'FALSE';\r\n  }\r\n\r\n  if (stream.match(/#/)) {\r\n    if (!stream.match(/\\n/)) {\r\n      // comment lasts till end of line\r\n      stream.match(/.*/); // if no eol encountered, comment lasts till end of file\r\n    }\r\n    return 'COMMENT';\r\n  }\r\n\r\n  // hardcode when to be a choose node not an identifier to get around parsing\r\n  if (stream.match(/WHEN/)) {\r\n    return 'CHOOSE1';\r\n  }\r\n\r\n  // Remove otherwise clause for now\r\n  if (stream.match(/OTHERWISE/)) {\r\n    return 'CHOOSE2';\r\n  }\r\n\r\n\r\n  if (stream.match(/[A-Z]([a-z|A-Z])*/)) {\r\n    return 'FUNCTION';\r\n  }\r\n\r\n  // Identifiers\r\n  // For now, the form of a valid identifier is: a lower-case alphabetic character,\r\n  // followed by zero or more alpha characters.\r\n  //if (stream.match(/[A-Za-z][\\w$]*(\\.[\\w$]+)?(\\[\\d+])?/)) {\r\n  //  return 'IDENTIFIER';\r\n  //}\r\n  if (stream.match(/[A-Za-z][(\\w|\\%)$]*(\\.[\\w$]+)?(\\[\\d+])?/)) {\r\n    return 'IDENTIFIER';\r\n  }\r\n\r\n\r\n\r\n  stream.next();\r\n  return 'ERROR';\r\n}\r\n\r\nexport type BinaryOperationTokenType =\r\n  | '+'\r\n  | '-'\r\n  | '*'\r\n  | '/'\r\n  | '|' // this is an or\r\n  | '&' // this is an and\r\n\r\nexport type TokenType =\r\n  | BinaryOperationTokenType\r\n  | 'NUM'\r\n  | 'TRUE'\r\n  | 'FALSE'\r\n  | '('\r\n  | ')'\r\n  | 'COMMENT'\r\n  | 'ERROR'\r\n  | 'FUNCTION'\r\n  | 'IDENTIFIER'\r\n  | 'CHOOSE1'\r\n  | 'CHOOSE2'\r\n  | '='\r\n  | 'RANGE'\r\n  | '['\r\n  | ']'\r\n  | 'RANGEIDENTIFIER'\r\n\r\nexport interface Token<T extends TokenType = TokenType> {\r\n  type: T;\r\n  text: string;\r\n  line: number;\r\n  first_column: number;\r\n  last_column: number;\r\n}\r\n\r\ntype Mode = 'default';\r\n\r\nexport interface State {\r\n  stack: Mode[];\r\n  line: number;\r\n}\r\n","import {Position} from './position';\r\nimport * as AST from './ast';\r\nimport {equals} from './equals';\r\n\r\n/***** ITERATION: change all outputType.valueType to simply outputType *****/\r\n\r\nexport function typecheck(nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n  const errors = nodes.map(n => typecheckNode(n, registeredNodes));\r\n  return ([] as TypeError[]).concat(...errors);\r\n}\r\n\r\nfunction typecheckNode(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n\r\n  if (node != undefined && node.nodeType != undefined && checkerMap[node.nodeType] != undefined){\r\n    return checkerMap[node.nodeType]!.check(node, registeredNodes);\r\n  } else {\r\n    return [];\r\n  }\r\n\r\n  \r\n}\r\n\r\nexport class TypeError {\r\n  constructor(public message: string, public position: Position) {}\r\n}\r\n\r\nexport interface TypeChecker {\r\n  check(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[];\r\n}\r\n\r\nclass CheckNumber implements TypeChecker {\r\n  check(node: AST.NumberNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\nclass CheckBoolean implements TypeChecker {\r\n  check(node: AST.BooleanNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\nclass CheckBinary implements TypeChecker {\r\n  check(node: AST.BinaryOperationNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    const errors: TypeError[] = typecheckNode(node.left, registeredNodes).concat(typecheckNode(node.right, registeredNodes));\r\n    \r\n    // Check if same operand type (both numbers, both booleans)\r\n    if (node.left?.outputType?.valueType != node.right?.outputType?.valueType) {\r\n      errors.push(new TypeError(\"incompatible types for binary operator\", node.pos));\r\n    }\r\n    // Check if incorrect combination of operator and operands\r\n    else if (node.right?.outputType?.valueType == 'boolean' && (node.operator != \"|\" && node.operator != '&')) {\r\n      errors.push(new TypeError(\"incompatible operation for boolean operands\", node.pos));\r\n    }\r\n    else if (node.right?.outputType?.valueType == 'number' && (node.operator == \"|\" || node.operator == '&')) {\r\n      errors.push(new TypeError(\"incompatible operation for number operands\", node.pos));\r\n    }\r\n\r\n    node.outputType!.valueType = node.left?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckFunction implements TypeChecker {\r\n  check(node: AST.FunctionNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    // First typecheck the argument\r\n    const arg1Errors = typecheckNode(node.args[0], registeredNodes);\r\n    errors = errors.concat(arg1Errors);\r\n    if (node.args.length > 1) {\r\n      const arg2Errors = typecheckNode(node.args[1], registeredNodes);\r\n      errors = errors.concat(arg2Errors);\r\n      if (node.args[0]?.outputType?.valueType != node.args[1]?.outputType?.valueType) {\r\n\r\n        errors.push(new TypeError(\"arguments must have same type\", node.args[0]!.pos));\r\n      }\r\n    }\r\n\r\n    const functionName = node.name\r\n    const argType = builtins[functionName].inputType;\r\n\r\n    // we found a builtin function\r\n    if (argType) {\r\n\r\n      // typecheck the argument\r\n      // Assume both arguments are the same type (see error produced above)\r\n      if (argType != 'any' && node.args[0]?.outputType?.valueType != argType) {\r\n        errors.push(new TypeError(\"incompatible argument type for \" + functionName, node.pos));\r\n      }\r\n    }\r\n  \r\n    // this is not a known, builtin function\r\n    else {\r\n      errors.push(new TypeError(\"unknown function\", node.pos));\r\n    }    \r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckChoose implements TypeChecker {\r\n  check(node: AST.ChooseNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    const predicate = node.case.predicate;\r\n    const consequent = node.case.consequent;\r\n    const otherwise = node.otherwise;\r\n\r\n    // First typecheck the inner nodes\r\n    const predErrors = typecheckNode(predicate, registeredNodes);\r\n    const consErrors = typecheckNode(consequent, registeredNodes);\r\n    const otherErrors = typecheckNode(otherwise, registeredNodes);\r\n    errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\r\n\r\n    // check return types are the same for both cases\r\n    if (consequent?.outputType?.valueType != otherwise?.outputType?.valueType) {\r\n      errors.push(new TypeError(\"Return types are not the same for both cases\", consequent!.pos));\r\n      errors.push(new TypeError(\"Return types are not the same for both cases\", otherwise!.pos));\r\n    }\r\n\r\n    // check that the predicate returns a boolean\r\n    if (predicate!.outputType!.valueType != 'boolean') {\r\n      errors.push(new TypeError(\"Predicate must return a boolean\", predicate!.pos));\r\n    }\r\n\r\n    node.outputType.valueType = consequent?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckVariable implements TypeChecker {\r\n  check(node: AST.VariableAssignmentNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n    // First typecheck the assignment node\r\n    const assignmentErrors = typecheckNode(node.assignment, registeredNodes);\r\n    errors = errors.concat(assignmentErrors);\r\n\r\n    node.outputType.valueType = node.assignment?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckIdentifier implements TypeChecker {\r\n  check(node: AST.IdentifierNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    // Maybe make assigmentId be valueId?\r\n    let assignmentNode : any = registeredNodes[node.assignmentId];\r\n    let valueNode = assignmentNode.assignment;\r\n    //let valueNode : AST.VariableAssignmentNode = registeredNodes[node.assignmentId]!.assignment;\r\n\r\n    // If this assignmentId is not found in the AST, throw an error\r\n    if (valueNode == undefined) {\r\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\r\n    }\r\n\r\n    node.outputType.valueType = valueNode.outputType.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckIterator implements TypeChecker {\r\n  check(node: AST.IteratorNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\n\r\nclass CheckRangeIdentifier implements TypeChecker {\r\n  check(node: AST.IteratorNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\n// Dictionary of builtin functions that maps a function name to the type of its argument\r\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType} } = {\r\n  \"IsDefined\": {inputType: 'any', resultType: 'boolean'},\r\n  \"Inverse\": {inputType: 'number', resultType: 'number'},\r\n  \"Input\": {inputType: 'number', resultType: 'number'},\r\n  \"Sink\": {inputType: 'any', resultType: 'any'},\r\n  \"RandomChoice\": {inputType: 'number', resultType: 'number'},\r\n  \"TestConstant\": {inputType: 'any', resultType: 'any'},\r\n  \"ParseOrderedPair\": {inputType: 'number', resultType: 'pair'},\r\n  \"X\": {inputType: 'pair', resultType: 'number'},\r\n  \"Y\": {inputType: 'pair', resultType: 'number'}\r\n}\r\n\r\nconst checkerMap: Partial<{[K in AST.NodeType]: TypeChecker}> = {\r\n  'Number' : new CheckNumber(),\r\n  'Boolean' : new CheckBoolean(),\r\n  'BinaryOperation' : new CheckBinary(),\r\n  'Function' : new CheckFunction(),\r\n  'Choose': new CheckChoose(),\r\n  'VariableAssignment': new CheckVariable(),\r\n  'Identifier': new CheckIdentifier(),\r\n  'Iterator': new CheckIterator(),\r\n  'RangeIdentifier': new CheckRangeIdentifier(),\r\n}","import {Position} from './position';\r\nimport * as AST from './ast';\r\nimport {equals} from './equals';\r\n\r\n\r\n\r\nexport function darCheck(nodes: AST.Node[],  registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    const errors = nodes.map(n => darCheckNode(n, nodes, registeredNodes));\r\n    return ([] as TypeError[]).concat(...errors);\r\n}\r\n\r\nfunction darCheckNode(node: AST.Node, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    if (darCheckerMap != undefined && node != undefined && node.nodeType != undefined && darCheckerMap[node.nodeType] == undefined){\r\n        return [];\r\n    }else{\r\n        return darCheckerMap[node!.nodeType]!.darCheck(node, nodes, registeredNodes);\r\n    }\r\n}\r\n\r\nexport class TypeError {\r\n    constructor(public message: string, public position: Position) {}\r\n  }\r\n\r\nexport interface DarChecker {\r\n\r\n    darCheck(node: AST.Node,\r\n            nodes: AST.Node[], \r\n            registeredNodes: {[key: string]: AST.Node},): TypeError[];\r\n  }\r\n\r\nclass DarCheckNumber implements DarChecker {\r\n    darCheck(node: AST.NumberNode): TypeError[] {\r\n\r\n        //set the value in the outputType\r\n        node.outputType.value = node.value;\r\n        return [];\r\n    }\r\n  }\r\n\r\n\r\n  class DarCheckFunction implements DarChecker{\r\n      darCheck(node: AST.FunctionNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}) : TypeError[]{\r\n        const errors: TypeError[] = [];\r\n        \r\n        if (node.name == \"TestConstant\"){\r\n            //do our test constant demo\r\n\r\n            //pre-check the arg (to assign value)\r\n            darCheckNode(node.args[0], nodes, registeredNodes)\r\n\r\n            //check if the argument has a value\r\n            if (node?.args[0]?.outputType?.value == undefined){\r\n                errors.push(new TypeError(\"Input to TestConstant() is not constant\", node.pos));\r\n            }\r\n\r\n        }\r\n        return errors;\r\n      }\r\n  }\r\n\r\nclass DarCheckBinary implements DarChecker {\r\n\r\n    evaluateOperation(left : number, right : number, operator : string): number | undefined {\r\n\r\n        //check to make sure left & right are numbers\r\n        if (typeof(left) == 'number' && typeof(right) == 'number' ){\r\n            if (operator == \"+\"){\r\n                return left + right\r\n            } else if (operator == \"-\"){\r\n                return left - right\r\n            } else if (operator == \"*\"){\r\n                return left * right\r\n            } else if (operator ==\"/\"){\r\n                return left / right\r\n            } else {\r\n                return 999999\r\n            }\r\n        } else {\r\n            //one or both sides is a non-number. We only care about numbers\r\n            return undefined\r\n        }\r\n    }\r\n\r\n    darCheck(node: AST.BinaryOperationNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n        const errors: TypeError[] = darCheckNode(node.left, nodes, registeredNodes).concat(darCheckNode(node.right, nodes, registeredNodes));\r\n        \r\n        //check if outputType of both left and right is constant\r\n        if (node.left?.outputType?.value != undefined && node.right?.outputType?.value != undefined){\r\n            \r\n            //evaluate the operation and set the value\r\n            node.outputType = {\r\n                status : node.outputType!.status,\r\n                valueType: node.left?.outputType?.valueType,\r\n                value: this.evaluateOperation(node.left?.outputType.value, node.right?.outputType.value, node.operator) \r\n            }\r\n            \r\n   \r\n        } else{\r\n            //One or both of the left + right does NOT have a value\r\n            console.log(\"One or both sides has no 'value'\");\r\n        }\r\n   \r\n        return errors;\r\n    }\r\n}\r\n\r\nclass DarCheckVariable implements DarChecker {\r\n    darCheck(node: AST.VariableAssignmentNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n\r\n\r\n        //check the assignment (and propagate value, if applicable)\r\n        darCheckNode(node.assignment, nodes, registeredNodes);\r\n\r\n        //does the assignment node have a value\r\n        if (node.assignment?.outputType?.value != undefined){\r\n            //set value of this node to the value of the assignment\r\n            node.outputType.value = node.assignment.outputType.value;\r\n        }\r\n\r\n        return [];\r\n    }\r\n}\r\n\r\nclass DarCheckIdentifier implements DarChecker {\r\n    darCheck(node: AST.IdentifierNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n\r\n        //grab the assignment node that this ident refrences\r\n        const assignmentNode = registeredNodes[node.assignmentId];\r\n\r\n        if (assignmentNode?.outputType?.value != undefined){\r\n            //set value of this node to the value of the assignment\r\n            node.outputType.value = assignmentNode.outputType.value;\r\n        }\r\n\r\n        return [];\r\n    }\r\n  }\r\n\r\n  class DarCheckIterator implements DarChecker {\r\n\r\n    getRange(start: number, end: number, step: number): number[]{\r\n        let current = start;\r\n        let out = [];\r\n        while (current < end){\r\n            out.push(current);\r\n            current += step;\r\n        }\r\n        return out;\r\n    }\r\n    darCheck(node: AST.IteratorNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n        const errors: TypeError[] = [];\r\n\r\n        //pre-check nodes\r\n        darCheckNode(node.start, nodes, registeredNodes);\r\n        darCheckNode(node.end, nodes, registeredNodes);\r\n        darCheckNode(node.step, nodes, registeredNodes);\r\n\r\n\r\n        //calculate range\r\n\r\n        if (node.start?.outputType?.value != undefined && node.end?.outputType?.value != undefined && node.step?.outputType?.value != undefined){\r\n            //if start, end, and step all are constant numbers\r\n\r\n            const start = node.start?.outputType?.value;\r\n            const end = node.end?.outputType?.value;\r\n            const step = node.step?.outputType?.value;\r\n\r\n            console.log(\"start, end, step:\", start, end, step);\r\n\r\n            node.values = this.getRange(start, end, step);\r\n        } else {\r\n            console.log(\"Iterator used with non constant stuff\")\r\n            errors.push(new TypeError(\"Non constant value used in iterator decleration\", node.pos));\r\n        }\r\n\r\n\r\n        return errors;\r\n    }\r\n  }\r\n\r\n\r\nclass DarCheckAny implements DarChecker {\r\n    darCheck(node: AST.Node): TypeError[] {\r\n        return [];\r\n    }\r\n}\r\n\r\nconst darCheckerMap: Partial<{[K in AST.NodeType]: DarChecker}> = {\r\n'Number' : new DarCheckNumber(),\r\n'Boolean' : new DarCheckAny(),\r\n'BinaryOperation' : new DarCheckBinary(),\r\n'Function' : new DarCheckFunction(),\r\n'Choose': new DarCheckAny(),\r\n'VariableAssignment': new DarCheckVariable(),\r\n'Identifier': new DarCheckIdentifier(),\r\n'Iterator': new DarCheckIterator(),\r\n'RangeIdentifier': new DarCheckAny(),\r\n'SinkAssignment': new DarCheckAny(),\r\n'String': new DarCheckAny(),\r\n'Pair': new DarCheckAny(),\r\n'CalculatorReference': new DarCheckAny(),\r\n'Program': new DarCheckAny(),\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import { Token } from './lexer';\r\n\r\nexport type Position = {\r\n  first_line: number;\r\n  first_column: number;\r\n  last_line: number;\r\n  last_column: number;\r\n};\r\n\r\nexport function token2pos(token: Token): Position {\r\n  return {\r\n    first_line: token.line,\r\n    last_line: token.line,\r\n    first_column: token.first_column,\r\n    last_column: token.last_column\r\n  }\r\n}\r\n\r\nexport function join(start: Position, end: Position) {\r\n  return {\r\n    first_line: start.first_line,\r\n    last_line: end.last_line,\r\n    first_column: start.first_column,\r\n    last_column: end.last_column\r\n  };\r\n}\r\n\r\nexport function pos2string(pos: Position): string {\r\n  return pos.first_line.toString() + \".\" +\r\n         pos.first_column.toString() + \".\" +\r\n         pos.last_line.toString() + \".\" +\r\n         pos.last_column.toString();\r\n}\r\n\r\n// note, extending Error in the browser is problematic\r\n// https://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node\r\nexport class ParseError {\r\n  constructor(public message: string, public position: Position) {}\r\n}\r\n","import * as AST from './ast';\r\n\r\nexport function findBases(node: AST.Node, dependsMap: {[key: string]: string[]}): string[] {\r\n\r\n    if (node == undefined || node.nodeType == undefined){\r\n        return [];\r\n    } else{\r\n        return baseMap[node.nodeType]!.findBase(node, dependsMap); \r\n    }\r\n\r\n    \r\n}\r\n\r\nexport interface BaseFinder {\r\n  findBase(node: AST.Node, dependsMap: {[key: string]: string[]}): string[];\r\n}\r\n\r\nclass BaseNumber implements BaseFinder {\r\n  findBase(node: AST.NumberNode): string[] {\r\n    return []\r\n  }\r\n}\r\n\r\nclass BaseBoolean implements BaseFinder {\r\n    findBase(node: AST.BooleanNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\nclass BaseBinary implements BaseFinder {\r\n    findBase(node: AST.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        let baseList: string[] = [];\r\n        // recursively call findBases on left and right\r\n        let leftList = findBases(node.left, dependsMap);\r\n        baseList = baseList.concat(leftList);\r\n        let rightList = findBases(node.right, dependsMap)\r\n        baseList = baseList.concat(rightList);\r\n        return baseList;\r\n    }\r\n}\r\n\r\n// examples: x = Input(3); x = IsDefined(Input(3)); z = Inverse(x)\r\n// need dependsMap for the third example\r\nclass BaseFunction implements BaseFinder {\r\n    findBase(node: AST.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        console.log(\"in base function\");\r\n        let baseList: string[] = [];\r\n        if (node.name == \"Input\") {\r\n            // this is a base\r\n            baseList.push(node.nodeId);\r\n        }\r\n        else {\r\n            // recursively call findBases on argument(s)\r\n            for (let i = 0; i < node.args.length; i++) {\r\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\r\n            }\r\n        }\r\n        return baseList;\r\n    }\r\n}\r\n\r\n// assume that choose nodes will never create their own bases\r\n// they can still error check previously defined bases\r\nclass BaseChoose implements BaseFinder {\r\n    findBase(node: AST.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        let baseList: string[] = [];\r\n        // the bases of the cons and the otherwise\r\n        letÂ consBases = findBases(node.case.consequent, dependsMap);\r\n        baseList = baseList.concat(consBases);\r\n        let otherBases = findBases(node.otherwise, dependsMap);\r\n        baseList = baseList.concat(otherBases);\r\n        return baseList;\r\n    }\r\n}\r\n\r\nclass BaseVariableAssignment implements BaseFinder {\r\n    findBase(node: AST.VariableAssignmentNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\nclass BaseIdentifier implements BaseFinder {\r\n    findBase(node: AST.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        // follow the chain in the dependsMap\r\n        return dependsMap[node.assignmentId];\r\n    }\r\n}\r\n\r\nclass BaseIterator implements BaseFinder {\r\n    findBase(node: AST.IteratorNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\n\r\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\r\n  'Number' : new BaseNumber(),\r\n  'Boolean' : new BaseBoolean(),\r\n  'BinaryOperation' : new BaseBinary(),\r\n  'Function' : new BaseFunction(),\r\n  'Choose': new BaseChoose(),\r\n  'VariableAssignment': new BaseVariableAssignment(),\r\n  'Identifier': new BaseIdentifier(),\r\n  'Iterator': new BaseIterator()\r\n}\r\n","import { TokenStream } from './tokenstream';\r\nimport { Token, TokenType, BinaryOperationTokenType} from './lexer';\r\nimport * as AST from './ast';\r\nimport { AbstractParser } from './parser';\r\nimport {ParseError, token2pos, join, pos2string} from './position';\r\nimport {findBases} from './findBase';\r\n\r\nexport interface InitialParselet {\r\n  parse(parser: AbstractParser,\r\n        tokens: TokenStream, token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}): AST.Node;\r\n}\r\n\r\n\r\nexport class NumberParselet implements InitialParselet {\r\n  parse(_parser: AbstractParser,\r\n        _tokens: TokenStream,\r\n        token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // add node to the map\r\n    let newNode : AST.NumberNode = {\r\n      nodeType: 'Number' as 'Number',\r\n      value: parseFloat(token.text),\r\n      outputType: { status: 'Definitely' as 'Definitely',\r\n                    valueType: 'number' as 'number',\r\n                    value: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class BooleanParselet implements InitialParselet {\r\n  constructor(private value: boolean) {}\r\n  parse(_parser: AbstractParser,\r\n        _tokens: TokenStream, token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    let newNode = {\r\n      nodeType: 'Boolean' as 'Boolean',\r\n      value: this.value,\r\n      outputType: { status: 'Definitely' as 'Definitely',\r\n                    valueType: 'boolean' as 'boolean',\r\n                    value: undefined},\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class ParenParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    _token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const exp = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    tokens.expectToken(')');\r\n\r\n    return exp;\r\n  }\r\n}\r\n\r\nexport class BracketParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream, token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    const arg3 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    tokens.expectToken(']');\r\n\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // add node to the map\r\n    let newNode : AST.IteratorNode = {\r\n      nodeType: 'Iterator' as 'Iterator',\r\n      outputType: undefined,\r\n      pos: position,\r\n      nodeId: id,\r\n      index: 0,\r\n      values: [],\r\n      start: arg1,\r\n      end: arg2,\r\n      step: arg3,\r\n    };\r\n\r\n    console.log(\"The Iterator parslet is running!\")\r\n    registeredNodes[id] = newNode;\r\n\r\n\r\n    return newNode;\r\n\r\n  }\r\n}\r\n\r\nexport abstract class ConsequentParselet {\r\n  constructor(\r\n    readonly tokenType: TokenType,\r\n    readonly associativity: 'left' | 'right'\r\n  ) {}\r\n  abstract parse(\r\n    parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    left: AST.Node,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}\r\n  ): AST.Node;\r\n}\r\n\r\nexport class BinaryOperatorParselet extends ConsequentParselet {\r\n  constructor(\r\n    public tokenType: BinaryOperationTokenType,\r\n    associativity: 'left' | 'right'\r\n  ) {\r\n    super(tokenType, associativity);\r\n  }\r\n\r\n  parse(\r\n    parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    left: Exclude<Exclude<AST.Node, AST.ProgramNode>, undefined>,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}\r\n  ): AST.Node {\r\n    const bindingPower = parser.bindingPower(token);\r\n\r\n    const right = parser.parse(\r\n      tokens,\r\n      this.associativity == 'left' ? bindingPower : bindingPower - 1,\r\n      varMap,\r\n      registeredNodes,\r\n      dependsMap\r\n    );\r\n    const position = join(left.pos, token2pos(tokens.last()));\r\n    const id = pos2string(position);\r\n    let newNode = {\r\n      nodeType: 'BinaryOperation' as 'BinaryOperation',\r\n      operator: this.tokenType,\r\n      left,\r\n      right,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined,\r\n                    value: undefined},\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n\r\n    return newNode;\r\n  }\r\n}\r\n\r\n// Parse function calls\r\n// Limitation: Functions are allowed to take exactly one argument\r\nexport class FunctionParselet implements InitialParselet {\r\n  \r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    tokens.expectToken('(');\r\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    let args = [arg1];\r\n    if (token.text == \"ParseOrderedPair\") {\r\n      const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for second argument\r\n      args.push(arg2);\r\n    }\r\n    tokens.expectToken(')');\r\n    let newNode = {\r\n      nodeType: 'Function' as 'Function',\r\n      name: token.text,\r\n      args: args,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined,\r\n                    value: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class ChooseParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n\r\n    const predicate = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    const consequent = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    tokens.expectToken('CHOOSE2');\r\n    const otherwise = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n\r\n    let newNode = {\r\n      nodeType: 'Choose' as 'Choose',\r\n      case: { predicate: predicate, consequent: consequent },\r\n      otherwise: otherwise,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined,\r\n                    value: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class VariableAssignmentParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    \r\n    //is this a special '%' assignment or identifier?\r\n\r\n\r\n    \r\n\r\n    // deal with variable assignment\r\n    tokens.expectToken('=');\r\n    const assignment = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n\r\n\r\n    // need to save the variable and its assignment in a lookup table\r\n    varMap[token.text] = id;\r\n\r\n    if (token.text.indexOf(\"%\") != -1){\r\n\r\n      let newNode = {\r\n        nodeType: 'VariableAssignment' as 'VariableAssignment',\r\n        name: token.text,\r\n        assignment: assignment,\r\n        outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                      valueType: assignment?.outputType?.valueType,\r\n                      value: undefined },\r\n        pos: position,\r\n        nodeId: id\r\n      };\r\n      registeredNodes[id] = newNode;\r\n      dependsMap[id] = findBases(assignment, dependsMap); // NEW FUNCTION HERE\r\n      return newNode;\r\n\r\n    } else {\r\n      let newNode = {\r\n        nodeType: 'VariableAssignment' as 'VariableAssignment',\r\n        name: token.text,\r\n        assignment: assignment,\r\n        outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                      valueType: assignment?.outputType?.valueType,\r\n                      value: undefined },\r\n        pos: position,\r\n        nodeId: id\r\n      };\r\n      registeredNodes[id] = newNode;\r\n      dependsMap[id] = findBases(assignment, dependsMap); // NEW FUNCTION HERE\r\n      return newNode;\r\n    }\r\n\r\n \r\n\r\n  }\r\n}\r\n\r\nexport class IdentifierParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n    \r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // need to look up known variables in a lookup table (map?)\r\n\r\n\r\n    const assignmentId = varMap[token.text];\r\n\r\n    if (!assignmentId) {\r\n      //if the variable is an assignment\r\n      const varParselet = new VariableAssignmentParselet();\r\n      return varParselet.parse(parser, tokens, token, varMap, registeredNodes, dependsMap);\r\n\r\n    }\r\n    else {\r\n      if (token.text.indexOf(\"%\") != -1){\r\n        let newNode = {\r\n          nodeType: 'RangeIdentifier' as 'RangeIdentifier',\r\n          name: token.text,\r\n          assignmentId: assignmentId,\r\n          outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                        valueType: undefined,\r\n                        value: undefined },\r\n          pos: position,\r\n          nodeId: id\r\n        };\r\n        registeredNodes[id] = newNode;\r\n        return newNode;\r\n      } else {\r\n        let newNode = {\r\n          nodeType: 'Identifier' as 'Identifier',\r\n          name: token.text,\r\n          assignmentId: assignmentId,\r\n          outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                        valueType: undefined,\r\n                        value: undefined },\r\n          pos: position,\r\n          nodeId: id\r\n        };\r\n        registeredNodes[id] = newNode;\r\n        return newNode;\r\n      }\r\n\r\n    }\r\n  }\r\n}\r\n","import {Token, TokenType, getTokens} from './lexer';\r\nimport {ParseError, token2pos} from './position';\r\n\r\nexport class TokenStream {\r\n  tokens: Token[];\r\n  pos: number = 0;\r\n\r\n  constructor(text: string) {\r\n    this.tokens = getTokens(text).filter(t => t.type != 'COMMENT');\r\n  }\r\n\r\n  consume(): Token | undefined {\r\n    const token = this.tokens[this.pos];\r\n    if (token) {\r\n      this.pos += 1;\r\n    }\r\n    return token;\r\n  }\r\n\r\n  peek(): Token | undefined {\r\n    return this.tokens[this.pos];\r\n  }\r\n\r\n  last(): Token {\r\n    return this.tokens[this.pos - 1];\r\n  }\r\n\r\n  expectToken<T extends TokenType>(expectedType: T): Token<T> {\r\n    const actual = this.consume();\r\n\r\n    if (!actual) {\r\n      throw new ParseError(\r\n        `Expected \"${expectedType}\" token but found none.`,\r\n        token2pos(this.last()),\r\n      );\r\n    }\r\n\r\n    if (actual.type != expectedType) {\r\n      throw new ParseError(\r\n        `Expected \"${expectedType}\" token type but found \"${actual.type}\".`,\r\n        token2pos(actual),\r\n      );\r\n    }\r\n\r\n    return actual as Token<T>;\r\n  }\r\n}\r\n","import * as Parselet from './parselet';\r\nimport {Token, TokenType} from './lexer';\r\nimport {TokenStream} from './tokenstream';\r\nimport {ParseError, token2pos} from './position';\r\nimport * as AST from './ast';\r\n\r\nexport function parse(text: string,\r\n                      varMap: {[key: string]: string},\r\n                      registeredNodes: {[key: string]: AST.Node},\r\n                      dependsMap: {[key: string]: string[]}): \r\n                      {nodes: AST.Node[]; errors: ParseError[]} {\r\n  const nodes: AST.Node[] = [];\r\n\r\n  const tokens = new TokenStream(text);\r\n  const parser = new Parser();\r\n  while (tokens.peek()) {\r\n    try {\r\n      nodes.push(parser.parse(tokens, 0, varMap, registeredNodes, dependsMap));\r\n    } catch (e) {\r\n      return {\r\n        nodes,\r\n        errors: [e],\r\n      };\r\n    }\r\n  }\r\n\r\n  return {nodes, errors: []};\r\n}\r\n\r\nexport abstract class AbstractParser {\r\n  public bindingPowers: {[tokenType in TokenType]: number};\r\n\r\n  protected abstract initialMap(): Partial<\r\n    {[K in TokenType]: Parselet.InitialParselet}\r\n  >;\r\n  protected abstract consequentMap(): Partial<\r\n    {[K in TokenType]: Parselet.ConsequentParselet}\r\n  >;\r\n  protected abstract bindingClasses(): TokenType[][];\r\n\r\n  constructor() {\r\n    this.bindingPowers = {} as any;\r\n\r\n    const bindingClasses = this.bindingClasses();\r\n    for (let i = 0; i < bindingClasses.length; i++) {\r\n      for (const tokenType of bindingClasses[i]) {\r\n        this.bindingPowers[tokenType] = 10 * i + 9;\r\n      }\r\n    }\r\n\r\n    for (const tokenType of Object.keys(this.consequentMap) as TokenType[]) {\r\n      if (this.bindingPowers[tokenType] == undefined) {\r\n        throw new Error(\r\n          `Token ${tokenType} defined in consequentMap has no associated binding power.\r\n          Make sure it is also listed in bindingClasses.`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  bindingPower(token: Token): number {\r\n    if (this.bindingPowers[token.type] != undefined) {\r\n      return this.bindingPowers[token.type];\r\n    } else {\r\n      throw new ParseError(\r\n        `Unexpected token type ${token.type}.`,\r\n        token2pos(token),\r\n      );\r\n    }\r\n  }\r\n\r\n  parse(tokens: TokenStream,\r\n        currentBindingPower: number,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}): AST.Node {\r\n    const token = tokens.consume();\r\n    if (!token) {\r\n      throw new ParseError(\r\n        `Unexpected end of tokens.`,\r\n        token2pos(tokens.last()),\r\n      );\r\n    }\r\n\r\n    const initialParselet = this.initialMap()[token.type];\r\n\r\n    if (!initialParselet) {\r\n      throw new ParseError(\r\n        `Unexpected token type ${token.type}`,\r\n        token2pos(token),\r\n      );\r\n    }\r\n\r\n    let left = initialParselet.parse(this, tokens, token, varMap, registeredNodes, dependsMap);\r\n\r\n    while (true) {\r\n      const next = tokens.peek();\r\n      if (!next) {\r\n        break;\r\n      }\r\n\r\n      const consequentParselet = this.consequentMap()[next.type];\r\n\r\n      if (!consequentParselet) {\r\n        break;\r\n      }\r\n\r\n      if (currentBindingPower >= this.bindingPower(next)) {\r\n        break;\r\n      }\r\n\r\n      tokens.consume();\r\n      left = consequentParselet.parse(this, tokens, left, next, varMap, registeredNodes, dependsMap);\r\n    }\r\n\r\n    return left;\r\n  }\r\n}\r\n\r\nexport class Parser extends AbstractParser {\r\n  initialMap() : any { //TODO: Setting this to any is hacky...\r\n    return {\r\n      NUMBER: new Parselet.NumberParselet(),\r\n      TRUE: new Parselet.BooleanParselet(true),\r\n      FALSE: new Parselet.BooleanParselet(false),\r\n      '(': new Parselet.ParenParselet(),\r\n      '[': new Parselet.BracketParselet(),\r\n      FUNCTION: new Parselet.FunctionParselet(),\r\n      CHOOSE1: new Parselet.ChooseParselet(),\r\n      IDENTIFIER: new Parselet.IdentifierParselet()\r\n    };\r\n  }\r\n\r\n\r\n  consequentMap() {\r\n    return {\r\n      '+': new Parselet.BinaryOperatorParselet('+', 'left'),\r\n      '-': new Parselet.BinaryOperatorParselet('-', 'left'),\r\n      '*': new Parselet.BinaryOperatorParselet('*', 'left'),\r\n      '/': new Parselet.BinaryOperatorParselet('/', 'left'),\r\n      '|': new Parselet.BinaryOperatorParselet('|', 'right'),\r\n      '&': new Parselet.BinaryOperatorParselet('&', 'right')\r\n    };\r\n  }\r\n\r\n  bindingClasses() {\r\n    const classes: TokenType[][] = [['+', '-'], ['*', '/'], ['|', '&']];\r\n    return classes;\r\n  }\r\n}\r\n","import {StateField} from \"@codemirror/state\"\r\nimport {Transaction} from \"@codemirror/state\"\r\nimport * as AST from './ast';\r\nimport {parse} from './parser';\r\nimport {ParseError} from './position';\r\n\r\n/**\r\n * A State field that holds the results of parsing\r\n */\r\nexport const parseResults: StateField<ParseResults> = StateField.define({\r\n  create() { return emptyParseResults },\r\n  update(value, tr) { return tr.docChanged ? parseProgram(tr) : value }\r\n})\r\n\r\n/**\r\n * Parse the program created from a transaction, returning a ParseResults object\r\n */\r\nfunction parseProgram(tr: Transaction) : ParseResults {\r\n  const contents = tr.state.doc.toString()\r\n\r\n  let varMap: {[key: string]: string} = {}\r\n  let registeredNodes: {[key: string]: AST.Node} = {}\r\n  let dependsMap: {[key: string]: string[]} = {}\r\n  const ast = parse(contents, varMap, registeredNodes, dependsMap)\r\n\r\n  return {\r\n    nodes: ast.nodes,\r\n    parseErrors: ast.errors,\r\n    varMap: varMap,\r\n    registeredNodes: registeredNodes,\r\n    dependsMap: dependsMap\r\n  }\r\n}\r\n\r\n/**\r\n * Type that describes the results of parsing\r\n */\r\nexport type ParseResults = {\r\n  nodes: AST.Node[];\r\n  parseErrors: ParseError[];\r\n  varMap: {[key: string]: string};\r\n  registeredNodes: {[key: string]: AST.Node};\r\n  dependsMap: {[key: string]: string[]};\r\n}\r\n\r\n/**\r\n * Can be used as the initial results of parsing\r\n */\r\nconst emptyParseResults: ParseResults = {\r\n  nodes: [],\r\n  parseErrors: [],\r\n  varMap: {},\r\n  registeredNodes: {},\r\n  dependsMap: {}\r\n}\r\n","import {StreamParser, StringStream} from \"@codemirror/stream-parser\"\r\nimport {Diagnostic} from \"@codemirror/lint\"\r\nimport {EditorView} from \"@codemirror/view\"\r\nimport {State, getDefaultToken} from './lexer'\r\nimport {ParseError} from './position'\r\nimport {typecheck} from './typechecker';\r\n//import {mudCheck} from './mudChecker';\r\nimport {darCheck} from './darChecker';\r\nimport {parseResults} from './parseResults';\r\n\r\n/**\r\n * The extension for our language\r\n */\r\nexport const miniCL: StreamParser<State> = {\r\n  startState: function (): State {\r\n    return {line: 1, stack: ['default']};\r\n  },\r\n  token: function (stream: StringStream, state: State): string | undefined {\r\n    if (stream.eatSpace()) return null;\r\n    return token2tag(getDefaultToken(stream, state));\r\n  }\r\n};\r\n\r\n/**\r\n * The linter for our language\r\n */\r\n export const miniCLLinter = () => (view: EditorView): Diagnostic[] => {\r\n\r\n  // Get the result types\r\n  const results = view.state.field(parseResults);\r\n\r\n  // Error checking\r\n  let assertMap: string[] = [];\r\n  //const mudErrors = mudCheck(results.nodes, results.registeredNodes, results.dependsMap, assertMap);\r\n  const darErrors = darCheck(results.nodes, results.registeredNodes);\r\n  const typeErrors = typecheck(results.nodes, results.registeredNodes);\r\n  \r\n\r\n  // Create a diagnostic for each kind of error\r\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\r\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\r\n  //const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\r\n  const darDiagnostics = darErrors.map(makeDiagnostic(view, 'warning'));\r\n\r\n  return parseDiagnostics.concat(typeDiagnostics).concat(darDiagnostics);\r\n}\r\n\r\n/**\r\n * Create a diagnostic from an error\r\n */\r\nconst makeDiagnostic = (view: EditorView, severity: 'error' | 'info' | 'warning' = 'error') => \r\n  (error): Diagnostic => {\r\n    return {\r\n      from: firstLine(view, error) + error.position.first_column,\r\n      to: lastLine(view, error) + error.position.last_column,\r\n      message: error.message,\r\n      severity: severity\r\n    }\r\n}\r\n\r\n/**\r\n * @returns the line number for the start of the error\r\n */\r\nfunction firstLine(view: EditorView, error: ParseError) {\r\n  return view.state.doc.line(error.position.first_line).from;\r\n}\r\n\r\n/**\r\n * @returns the line number for the end of the error\r\n */\r\nfunction lastLine (view: EditorView, error: ParseError) {\r\n  return view.state.doc.line(error.position.last_line).from;    \r\n}\r\n\r\n/**\r\n * Convert our bespoke parser Token type to a token type that is recognized by CodeMirror\r\n */\r\nfunction token2tag(token: string): string | undefined {\r\n  switch (token) {\r\n    case 'NUMBER':\r\n      return 'number';\r\n\r\n    case 'TRUE':\r\n      return 'boolean';\r\n\r\n    case 'FALSE':\r\n      return 'boolean';\r\n\r\n    case '(':\r\n    case ')':\r\n      return 'bracket';\r\n\r\n    case '+':\r\n    case '-':\r\n    case '*':\r\n    case '/':\r\n    case '|':\r\n    case '&':\r\n    case '=':\r\n      return 'operator';\r\n\r\n    case 'COMMENT':\r\n      return 'comment';\r\n\r\n    case 'CHOOSE1':\r\n    case 'CHOOSE2':\r\n      return 'choose';\r\n\r\n    case 'FUNCTION':\r\n      return 'function';\r\n\r\n    case 'IDENTIFIER':\r\n      return 'variable';\r\n\r\n    case 'ERROR':\r\n      return 'error';\r\n\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n","import * as d3Hierarchy from 'd3-hierarchy';\r\nimport * as d3Select from 'd3-selection';\r\nimport * as d3shape from 'd3-shape';\r\nimport * as AST from './ast';\r\n\r\nexport function visualize(nodes: AST.Node[]): void {\r\n\r\n    // Placement and size of tree\r\n    const margin = {top: 20, right: 90, bottom: 20, left: 90};\r\n    const height = 300 - margin.top - margin.bottom;\r\n    const width  = 500 - margin.left - margin.right;\r\n  \r\n    // Make the svg\r\n    d3Select.select('#viz').selectAll('svg').remove();\r\n    const viz = d3Select.select('#viz').append('svg');\r\n  \r\n    // Remove existing visualizations\r\n    viz.selectAll('*').remove();\r\n  \r\n    // Add a new visualization\r\n    viz.attr('width', width + margin.left + margin.right)\r\n       .attr('height', height + margin.top + margin.bottom);\r\n\r\n    const root: Node = {nodeType: 'Program', children: nodes}\r\n\r\n    // Visualize all the statements\r\n    // for (var statement of nodes) {\r\n\r\n      // Create the tree and layout\r\n      const treemap = d3Hierarchy.tree()\r\n        .size([height, width])\r\n        .separation(() => 1);\r\n      const treelayout = d3Hierarchy.hierarchy(root, getChildren);\r\n      const tree = treemap(treelayout);\r\n  \r\n      // Add a new graph element for this statement\r\n      const g = viz.append('g')\r\n                  //  .attr(\"transform\", `translate(${root.dy / 3},${root.dx - x0})`);\r\n                   .attr('transform', `translate(${margin.left}, ${margin.top})`)\r\n                   .attr(\"font-family\", \"sans-serif\")\r\n                   .attr(\"font-size\", 12)\r\n               \r\n      // Edge updates\r\n      const link = g.selectAll('path.link').data(tree.links());\r\n\r\n      // Edge entry\r\n      const linkEnter = link.enter().append('path', 'g');\r\n        \r\n      // general edge attributes\r\n      linkEnter.attr('class', 'link')\r\n               .attr('fill', 'none')\r\n               .attr(\"stroke-opacity\", 0.4)\r\n               .attr('stroke', '#555')\r\n               .attr(\"stroke-width\", 1.5)\r\n               .attr('d', connection);\r\n\r\n        \r\n      // Node updates\r\n      const node = g.selectAll('g.node').data(tree.descendants());\r\n\r\n      // Node entry\r\n      const nodeEnter = node.enter().append('g');\r\n\r\n      // general node attributes\r\n      nodeEnter.attr('class', 'node')\r\n               .attr('transform', d => `translate(${d.y}, ${d.x})`);\r\n\r\n      nodeEnter.append('circle')\r\n               .attr(\"fill\", getFill)\r\n               .attr('r', '2.5')\r\n               .attr('stroke-width', 10);\r\n\r\n      // add text\r\n      nodeEnter.append('text')\r\n                // .attr('dy', '-10px')\r\n                .attr(\"dy\", \"0.31em\")\r\n                .attr(\"x\", d => d.children ? -8 : 8)\r\n                .attr(\"text-anchor\", d => d.children ? \"end\" : \"start\")\r\n                .attr('fill', d => isUndefined(d) ? '#fc6666' : 'black')\r\n                .style(\"fill-opacity\", 1)\r\n                .call(getTextBox)\r\n                .datum(d => d.data)\r\n                .text(getText)\r\n          .clone(true).lower()\r\n            .attr(\"stroke\", \"white\");\r\n    \r\n      // Highlight undefined -- not working\r\n      // Inspired in part by https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\r\n      nodeEnter.filter((d,i) => isUndefined(d))\r\n        .call(yep)\r\n        .insert('rect', 'text')\r\n        .attr(\"x\", function(d){return d.bbox.x})\r\n        .attr(\"y\", function(d){return d.bbox.y})\r\n        .attr(\"width\", function(d){return d.bbox.width})\r\n        .attr(\"height\", function(d){return d.bbox.height}) \r\n        .attr('fill', 'black')             \r\n    // }\r\n}\r\n\r\n// From https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\r\nfunction getTextBox(selection : any) {\r\n  selection.each(function(d : any){d.bbox = this.getBBox();})\r\n}\r\n\r\nfunction yep(selection : any) {\r\n  // console.log(selection.nodes().map((d)=>d.bbox));\r\n}\r\n\r\n\r\nconst connection = d3shape.linkHorizontal().x(d => d.y).y(d => d.x)\r\n\r\nfunction getChildren(node: AST.Node): AST.Node[] {\r\n  var children: AST.Node[] = [];\r\n  switch (node!.nodeType) {\r\n    case 'Program':\r\n      node = node as AST.ProgramNode;\r\n      children = node!.children;\r\n      break;\r\n    case 'Function':\r\n      node = node as AST.FunctionNode;\r\n      children = node!.args;\r\n      break;\r\n    case 'Choose':\r\n      node = node as AST.ChooseNode;\r\n      children = [node!.case.predicate, node!.case.consequent, node!.otherwise];\r\n      break;\r\n    case 'BinaryOperation':\r\n      node = node as AST.BinaryOperationNode;\r\n      children = [node!.left, node.right];\r\n      break;\r\n    case 'VariableAssignment':\r\n      node = node as AST.VariableAssignmentNode;\r\n      children = [node!.assignment];\r\n      break;\r\n    default:\r\n      children = [];\r\n    }\r\n\r\n  return children;\r\n}\r\n\r\nfunction getText(node: AST.Node) {\r\n  var text = \"\";\r\n  switch (node!.nodeType) {\r\n    case 'Program':\r\n      text = '';\r\n      break;\r\n    case 'Function':\r\n      node = node as AST.FunctionNode;\r\n      text = node.name;\r\n      break;\r\n    case 'Choose':\r\n      text = \"choose\";\r\n      break;\r\n    case 'BinaryOperation':\r\n      node = node as AST.BinaryOperationNode;\r\n      text = node.operator;\r\n      break;\r\n    case 'VariableAssignment':\r\n      node = node as AST.VariableAssignmentNode;\r\n      text = node.name;\r\n      break;\r\n    case 'Identifier':\r\n      node = node as AST.IdentifierNode;\r\n      text = node.name;\r\n      break;\r\n    case 'Number':  \r\n      node = node as AST.NumberNode;\r\n      text = node.value.toString();\r\n      break;\r\n    case 'Boolean':\r\n      node = node as AST.BooleanNode;\r\n      text = node.value.toString();\r\n      break;\r\n    default:\r\n      text = \"\";\r\n  }\r\n\r\n  return text;\r\n}\r\n\r\nfunction getFill(node : AST.ProgramNode): string {\r\n  if (isUndefined(node)) {\r\n    return '#fc6666'\r\n  }\r\n  if (node.children) {\r\n    return '#555'\r\n  } else {\r\n    return '#999'\r\n  }\r\n}\r\n\r\nfunction isUndefined(d : any) {\r\n  return d.data.outputType?.status === 'Maybe-Undefined'\r\n}","import {Transaction} from \"@codemirror/state\"\r\nimport {json, jsonParseLinter} from \"@codemirror/lang-json\"\r\nimport {foldAll} from \"@codemirror/fold\"\r\nimport { visualize } from \"./visualization\"\r\nimport {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\r\nimport {linter} from \"@codemirror/lint\"\r\nimport { parseResults } from \"./parseResults\"\r\n\r\n/**\r\n * Given a transaction, update the developer tools\r\n */\r\n export function updateDevTools(tr: Transaction) {\r\n  const results = tr.state.field(parseResults)\r\n\r\n  // Display JSON for AST\r\n  const astJSON = JSON.stringify(results.nodes, null, 2)\r\n  replaceContents(astViewer, astJSON);\r\n\r\n  // Display JSON for depends map\r\n  const dependsJSON = JSON.stringify(results.dependsMap, null, 2);\r\n  replaceContents(dependsViewer, dependsJSON);\r\n\r\n  // Draw the AST\r\n  visualize(results.nodes);\r\n}\r\n\r\n// Configuration for a read-only JSON viewer with folding, line numbers, etc.\r\nfunction newJSONViewerState(): EditorState {\r\n  return EditorState.create({\r\n    extensions: [\r\n      basicSetup,\r\n      json(),\r\n      linter(jsonParseLinter()),\r\n      EditorView.editable.of(false),\r\n    ],\r\n  })\r\n}\r\n\r\n// JSON viewer for AST\r\nlet astViewer = new EditorView({\r\n  state: newJSONViewerState(),\r\n  parent: document.querySelector(\"#ast-json\") as Element,\r\n});\r\n\r\n// JSON viewer for depends map\r\nlet dependsViewer = new EditorView({\r\n  state: newJSONViewerState(),\r\n  parent: document.querySelector(\"#depends-json\") as Element,\r\n});\r\n\r\n/**\r\n * Replace the entire contents of an editor\r\n */\r\nfunction replaceContents(editor: EditorView, contents: string) {\r\n  const update = editor.state.update({\r\n    changes: {\r\n      from: 0,\r\n      to: editor.state.doc.length,\r\n      insert: contents\r\n    }\r\n  });\r\n  editor.update([update]);\r\n  foldAll(editor);  // By default, fold all levels\r\n}\r\n","import {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\r\nimport {Transaction} from \"@codemirror/state\"\r\nimport {linter} from \"@codemirror/lint\"\r\nimport {miniCL, miniCLLinter} from \"./miniCL\"\r\nimport {StreamLanguage} from \"@codemirror/stream-parser\"\r\nimport {parseResults} from \"./parseResults\"\r\nimport {updateDevTools} from \"./devTools\"\r\nimport \"./styles.css\"\r\nimport \"./desmos_icons.css\"\r\n\r\n// Create the CodeMirror miniCL editor and add it to the document.\r\nlet miniCLEditor = new EditorView({\r\n  state: EditorState.create({\r\n    extensions: [\r\n      basicSetup,                     // https://codemirror.net/6/docs/ref/#basic-setup\r\n      StreamLanguage.define(miniCL),  // syntax coloring for miniCL\r\n      parseResults,                   // field that holds the results of parsing\r\n      linter(miniCLLinter())          // error-checking for miniCL\r\n    ],\r\n  }),\r\n  dispatch: updateOutput,\r\n  parent: document.querySelector(\"#miniCL-editor\") as Element\r\n})\r\n\r\n// When the content changes, update the editor and the dev tools\r\nfunction updateOutput(tr: Transaction) {\r\n  miniCLEditor.update([tr]);\r\n  updateDevTools(tr);\r\n}\r\n"]}