{"version":3,"sources":["src/index.ts","src/miniCL.ts","src/parseResults.ts","src/devTools.ts","src/lexer.ts","src/typechecker.ts","src/mudChecker.ts","src/parser.ts","src/visualization.ts","src/findBase.ts","src/parselet.ts","src/tokenstream.ts","src/position.ts"],"names":["miniCLEditor","basic_setup_1","state","create","extensions","stream_parser_1","define","miniCL_1","parseResults_1","lint_1","dispatch","updateOutput","parent","document","querySelector","tr","update","devTools_1","startState","line","stack","token","stream","eatSpace","token2tag","lexer_1","view","results","field","assertMap","mudErrors","mudChecker_1","nodes","registeredNodes","dependsMap","typeErrors","typechecker_1","parseDiagnostics","parseErrors","map","makeDiagnostic","typeDiagnostics","mudDiagnostics","concat","severity","error","from","firstLine","position","first_column","to","lastLine","last_column","message","doc","first_line","last_line","undefined","state_1","emptyParseResults","value","docChanged","parseProgram","contents","toString","varMap","ast","parser_1","errors","astJSON","JSON","stringify","replaceContents","astViewer","dependsJSON","dependsViewer","visualization_1","lang_json_1","editable","of","newJSONViewerState","editor","changes","length","insert","fold_1","text","tokens","split","string","eol","getToken","emitToken","makeEmit","fullToken","push","start","pos","Error","getDefaultToken","type","current","match","next","n","typecheckNode","node","checkerMap","nodeType","check","constructor","left","right","outputType","valueType","TypeError","operator","arg1Errors","args","arg2Errors","functionName","name","argType","builtins","inputType","predicate","case","consequent","otherwise","predErrors","consErrors","otherErrors","assignmentErrors","assignment","valueNode","assignmentId","resultType","CheckNumber","CheckBoolean","CheckBinary","CheckFunction","CheckChoose","CheckVariable","CheckIdentifier","mudCheckNode","mudCheckerMap","mudCheck","status","returnType","consDef","otherDef","localAsserts","doBinOp","handleAsserts","handleCheck","MudCheckNumber","MudCheckBoolean","MudCheckBinary","MudCheckFunction","MudCheckChoose","MudCheckVariable","MudCheckIdentifier","predBases","findBase_1","k","consBases","contained","i","find","e","consDefLeft","consDefRight","consDefBoth","temp","temp2","resolveFB","resolveBF","resolveFF","resolveBBO","resolveBOB","resolveFBO","resolveBOF","resolveBOBO","tokenstream_1","parser","Parser","peek","parse","bindingPowers","bindingClasses","tokenType","Object","keys","consequentMap","bindingPower","position_1","currentBindingPower","consume","last","initialParselet","initialMap","consequentParselet","AbstractParser","NUMBER","NumberParselet","TRUE","BooleanParselet","FALSE","ParenParselet","FUNCTION","FunctionParselet","CHOOSE1","ChooseParselet","IDENTIFIER","IdentifierParselet","BinaryOperatorParselet","classes","margin","top","bottom","height","width","select","selectAll","remove","viz","append","attr","root","children","treemap","tree","size","separation","treelayout","hierarchy","getChildren","g","link","data","links","linkEnter","enter","connection","descendants","nodeEnter","d","y","x","getFill","isUndefined","style","call","getTextBox","datum","getText","clone","lower","filter","yep","bbox","selection","each","getBBox","linkHorizontal","baseMap","findBase","baseList","leftList","findBases","rightList","console","log","nodeId","otherBases","BaseNumber","BaseBoolean","BaseBinary","BaseFunction","BaseChoose","BaseVariableAssignment","BaseIdentifier","_parser","_tokens","id","newNode","parseFloat","_token","exp","expectToken","associativity","ConsequentParselet","arg1","arg2","varParselet","VariableAssignmentParselet","t","expectedType","actual","end"],"mappings":"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","file":"","sourcesContent":["import {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\nimport {Transaction} from \"@codemirror/state\"\nimport {linter} from \"@codemirror/lint\"\nimport {miniCL, miniCLLinter} from \"./miniCL\"\nimport {StreamLanguage} from \"@codemirror/stream-parser\"\nimport {parseResults} from \"./parseResults\"\nimport {updateDevTools} from \"./devTools\"\nimport \"./styles.css\"\nimport \"./desmos_icons.css\"\n\n// Create the CodeMirror miniCL editor and add it to the document.\nlet miniCLEditor = new EditorView({\n  state: EditorState.create({\n    extensions: [\n      basicSetup,                     // https://codemirror.net/6/docs/ref/#basic-setup\n      StreamLanguage.define(miniCL),  // syntax coloring for miniCL\n      parseResults,                   // field that holds the results of parsing\n      linter(miniCLLinter())          // error-checking for miniCL\n    ],\n  }),\n  dispatch: updateOutput,\n  parent: document.querySelector(\"#miniCL-editor\")\n})\n\n// When the content changes, update the editor and the dev tools\nfunction updateOutput(tr: Transaction) {\n  miniCLEditor.update([tr]);\n  updateDevTools(tr);\n}\n","import {StreamParser, StringStream} from \"@codemirror/stream-parser\"\nimport {Diagnostic} from \"@codemirror/lint\"\nimport {EditorView} from \"@codemirror/view\"\nimport {State, getDefaultToken} from './lexer'\nimport {ParseError} from './position'\nimport {typecheck} from './typechecker';\nimport {mudCheck} from './mudChecker';\nimport {parseResults} from './parseResults';\n\n/**\n * The extension for our language\n */\nexport const miniCL: StreamParser<State> = {\n  startState: function (): State {\n    return {line: 1, stack: ['default']};\n  },\n  token: function (stream: StringStream, state: State): string | undefined {\n    if (stream.eatSpace()) return null;\n    return token2tag(getDefaultToken(stream, state));\n  }\n};\n\n/**\n * The linter for our language\n */\n export const miniCLLinter = () => (view: EditorView): Diagnostic[] => {\n\n  // Get the result types\n  const results = view.state.field(parseResults);\n\n  // Error checking\n  let assertMap: string[] = [];\n  const mudErrors = mudCheck(results.nodes, results.registeredNodes, results.dependsMap, assertMap);\n  const typeErrors = typecheck(results.nodes, results.registeredNodes);\n\n  // Create a diagnostic for each kind of error\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\n  const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\n\n  return parseDiagnostics.concat(typeDiagnostics).concat(mudDiagnostics);\n}\n\n/**\n * Create a diagnostic from an error\n */\nconst makeDiagnostic = (view: EditorView, severity: 'error' | 'info' | 'warning' = 'error') => \n  (error): Diagnostic => {\n    return {\n      from: firstLine(view, error) + error.position.first_column,\n      to: lastLine(view, error) + error.position.last_column,\n      message: error.message,\n      severity: severity\n    }\n}\n\n/**\n * @returns the line number for the start of the error\n */\nfunction firstLine(view: EditorView, error: ParseError) {\n  return view.state.doc.line(error.position.first_line).from;\n}\n\n/**\n * @returns the line number for the end of the error\n */\nfunction lastLine (view: EditorView, error: ParseError) {\n  return view.state.doc.line(error.position.last_line).from;    \n}\n\n/**\n * Convert our bespoke parser Token type to a token type that is recognized by CodeMirror\n */\nfunction token2tag(token: string): string | undefined {\n  switch (token) {\n    case 'NUMBER':\n      return 'number';\n\n    case 'TRUE':\n      return 'boolean';\n\n    case 'FALSE':\n      return 'boolean';\n\n    case '(':\n    case ')':\n      return 'bracket';\n\n    case '+':\n    case '-':\n    case '*':\n    case '/':\n    case '|':\n    case '&':\n    case '=':\n      return 'operator';\n\n    case 'COMMENT':\n      return 'comment';\n\n    case 'CHOOSE1':\n    case 'CHOOSE2':\n      return 'choose';\n\n    case 'FUNCTION':\n      return 'function';\n\n    case 'IDENTIFIER':\n      return 'variable';\n\n    case 'ERROR':\n      return 'error';\n\n    default:\n      return undefined;\n  }\n}\n","import {StateField} from \"@codemirror/state\"\nimport {Transaction} from \"@codemirror/state\"\nimport * as AST from './ast';\nimport {parse} from './parser';\nimport {ParseError} from './position';\n\n/**\n * A State field that holds the results of parsing\n */\nexport const parseResults: StateField<ParseResults> = StateField.define({\n  create() { return emptyParseResults },\n  update(value, tr) { return tr.docChanged ? parseProgram(tr) : value }\n})\n\n/**\n * Parse the program created from a transaction, returning a ParseResults object\n */\nfunction parseProgram(tr: Transaction) : ParseResults {\n  const contents = tr.state.doc.toString()\n\n  let varMap: {[key: string]: string} = {}\n  let registeredNodes: {[key: string]: AST.Node} = {}\n  let dependsMap: {[key: string]: string[]} = {}\n  const ast = parse(contents, varMap, registeredNodes, dependsMap)\n\n  return {\n    nodes: ast.nodes,\n    parseErrors: ast.errors,\n    varMap: varMap,\n    registeredNodes: registeredNodes,\n    dependsMap: dependsMap\n  }\n}\n\n/**\n * Type that describes the results of parsing\n */\nexport type ParseResults = {\n  nodes: AST.Node[];\n  parseErrors: ParseError[];\n  varMap: {[key: string]: string};\n  registeredNodes: {[key: string]: AST.Node};\n  dependsMap: {[key: string]: string[]};\n}\n\n/**\n * Can be used as the initial results of parsing\n */\nconst emptyParseResults: ParseResults = {\n  nodes: [],\n  parseErrors: [],\n  varMap: {},\n  registeredNodes: {},\n  dependsMap: {}\n}\n","import {Transaction} from \"@codemirror/state\"\nimport {json, jsonParseLinter} from \"@codemirror/lang-json\"\nimport {foldAll} from \"@codemirror/fold\"\nimport { visualize } from \"./visualization\"\nimport {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\nimport {linter} from \"@codemirror/lint\"\nimport { parseResults } from \"./parseResults\"\n\n/**\n * Given a transaction, update the developer tools\n */\n export function updateDevTools(tr: Transaction) {\n  const results = tr.state.field(parseResults)\n\n  // Display JSON for AST\n  const astJSON = JSON.stringify(results.nodes, null, 2)\n  replaceContents(astViewer, astJSON);\n\n  // Display JSON for depends map\n  const dependsJSON = JSON.stringify(results.dependsMap, null, 2);\n  replaceContents(dependsViewer, dependsJSON);\n\n  // Draw the AST\n  visualize(results.nodes);\n}\n\n// Configuration for a read-only JSON viewer with folding, line numbers, etc.\nfunction newJSONViewerState(): EditorState {\n  return EditorState.create({\n    extensions: [\n      basicSetup,\n      json(),\n      linter(jsonParseLinter()),\n      EditorView.editable.of(false),\n    ],\n  })\n}\n\n// JSON viewer for AST\nlet astViewer = new EditorView({\n  state: newJSONViewerState(),\n  parent: document.querySelector(\"#ast-json\"),\n});\n\n// JSON viewer for depends map\nlet dependsViewer = new EditorView({\n  state: newJSONViewerState(),\n  parent: document.querySelector(\"#depends-json\"),\n});\n\n/**\n * Replace the entire contents of an editor\n */\nfunction replaceContents(editor: EditorView, contents: string) {\n  const update = editor.state.update({\n    changes: {\n      from: 0,\n      to: editor.state.doc.length,\n      insert: contents\n    }\n  });\n  editor.update([update]);\n  foldAll(editor);  // By default, fold all levels\n}\n","import {StringStream} from \"@codemirror/stream-parser\"\n\nexport function getTokens(text: string): Token[] {\n  const tokens: Token[] = [];\n  const state: State = {line: 1, stack: ['default']};\n\n  for (const line of text.split('\\n')) {\n    const stream = new StringStream();\n    stream.string = line;\n    while (!stream.eol()) {\n      const token = getToken(stream, state);\n      const emitToken = makeEmit(stream, state);\n      const fullToken = emitToken(token as TokenType);\n      if (token != undefined) {\n        tokens.push(fullToken);\n      }\n\n      if (stream.start == stream.pos) {\n        throw new Error(\n          `getToken failed to advance stream at position ${\n            stream.pos\n          } in string ${stream.string}`,\n        );\n      }\n      stream.start = stream.pos;\n    }\n\n    state.line += 1;\n  }\n\n  return tokens;\n}\n\nexport function getToken(\n  stream: StringStream,\n  state: State,\n): string | undefined {\n  //Built for codeMirror streams API\n  //State is a stack of states\n  switch (state.stack[state.stack.length - 1]) {\n    default:\n      return getDefaultToken(stream, state);\n  }\n}\n\nfunction makeEmit(stream: StringStream, state: State) {\n  return function emitToken(type: TokenType): Token {\n    return {\n      type,\n      first_column: stream.start,\n      last_column: stream.pos,\n      line: state.line,\n      text: stream.current(),\n    };\n  };\n}\n\nexport function getDefaultToken(\n  stream: StringStream,\n  state: State,\n): string | undefined {\n  // const emitToken = makeEmit(stream, state);\n  if (stream.eatSpace()) {\n    // skip whitespace\n    return undefined;\n  }\n\n  if (stream.match(/\\+/)) {\n    return '+';\n  }\n\n  if (stream.match(/\\-/)) {\n    return '-';\n  }\n\n  if (stream.match(/\\*/)) {\n    return '*';\n  }\n\n  if (stream.match(/\\//)) {\n    return '/';\n  }\n\n  if (stream.match(/\\|/)) {\n    return '|';\n  }\n\n  if (stream.match(/\\&/)) {\n    return '&';\n  }\n\n  if (stream.match(/\\(/)) {\n    return '(';\n  }\n\n  if (stream.match(/\\)/)) {\n    return ')';\n  }\n\n  // adding an equals operator\n  if (stream.match(/\\=/)) {\n    return '=';\n  }\n\n  if (stream.match(/-?[0-9]+(\\.[0-9]+)?/)) {\n    return 'NUMBER';\n  }\n\n  if (stream.match(/True/)) {\n    return 'TRUE';\n  }\n\n  if (stream.match(/False/)) {\n    return 'FALSE';\n  }\n\n  if (stream.match(/#/)) {\n    if (!stream.match(/\\n/)) {\n      // comment lasts till end of line\n      stream.match(/.*/); // if no eol encountered, comment lasts till end of file\n    }\n    return 'COMMENT';\n  }\n\n  // hardcode when to be a choose node not an identifier to get around parsing\n  if (stream.match(/WHEN/)) {\n    return 'CHOOSE1';\n  }\n\n  // Remove otherwise clause for now\n  if (stream.match(/OTHERWISE/)) {\n    return 'CHOOSE2';\n  }\n\n  if (stream.match(/[A-Z]([a-z|A-Z])*/)) {\n    return 'FUNCTION';\n  }\n\n  // Identifiers\n  // For now, the form of a valid identifier is: a lower-case alphabetic character,\n  // followed by zero or more alpha characters.\n  if (stream.match(/[a-z]([a-z|A-Z])*/)) {\n    return 'IDENTIFIER';\n  }\n  \n\n  stream.next();\n  return 'ERROR';\n}\n\nexport type BinaryOperationTokenType =\n  | '+'\n  | '-'\n  | '*'\n  | '/'\n  | '|' // this is an or\n  | '&' // this is an and\n\nexport type TokenType =\n  | BinaryOperationTokenType\n  | 'NUM'\n  | 'TRUE'\n  | 'FALSE'\n  | '('\n  | ')'\n  | 'COMMENT'\n  | 'ERROR'\n  | 'FUNCTION'\n  | 'IDENTIFIER'\n  | 'CHOOSE1'\n  | 'CHOOSE2'\n  | '='\n\nexport interface Token<T extends TokenType = TokenType> {\n  type: T;\n  text: string;\n  line: number;\n  first_column: number;\n  last_column: number;\n}\n\ntype Mode = 'default';\n\nexport interface State {\n  stack: Mode[];\n  line: number;\n}\n","import {Position} from './position';\nimport * as AST from './ast';\nimport {equals} from './equals';\n\n/***** ITERATION: change all outputType.valueType to simply outputType *****/\n\nexport function typecheck(nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\n  const errors = nodes.map(n => typecheckNode(n, registeredNodes));\n  return ([] as TypeError[]).concat(...errors);\n}\n\nfunction typecheckNode(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\n  return checkerMap[node.nodeType].check(node, registeredNodes);\n}\n\nexport class TypeError {\n  constructor(public message: string, public position: Position) {}\n}\n\nexport interface TypeChecker {\n  check(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[];\n}\n\nclass CheckNumber implements TypeChecker {\n  check(node: AST.NumberNode): TypeError[] {\n    return [];\n  }\n}\n\nclass CheckBoolean implements TypeChecker {\n  check(node: AST.BooleanNode): TypeError[] {\n    return [];\n  }\n}\n\nclass CheckBinary implements TypeChecker {\n  check(node: AST.BinaryOperationNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\n    const errors: TypeError[] = typecheckNode(node.left, registeredNodes).concat(typecheckNode(node.right, registeredNodes));\n    \n    // Check if same operand type (both numbers, both booleans)\n    if (node.left?.outputType?.valueType != node.right?.outputType?.valueType) {\n      errors.push(new TypeError(\"incompatible types for binary operator\", node.pos));\n    }\n    // Check if incorrect combination of operator and operands\n    else if (node.right?.outputType?.valueType == 'boolean' && (node.operator != \"|\" && node.operator != '&')) {\n      errors.push(new TypeError(\"incompatible operation for boolean operands\", node.pos));\n    }\n    else if (node.right?.outputType?.valueType == 'number' && (node.operator == \"|\" || node.operator == '&')) {\n      errors.push(new TypeError(\"incompatible operation for number operands\", node.pos));\n    }\n\n    node.outputType.valueType = node.left?.outputType?.valueType;\n\n    return errors;\n  }\n}\n\nclass CheckFunction implements TypeChecker {\n  check(node: AST.FunctionNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\n    let errors: TypeError[] = [];\n\n    // First typecheck the argument\n    const arg1Errors = typecheckNode(node.args[0], registeredNodes);\n    errors = errors.concat(arg1Errors);\n    if (node.args.length > 1) {\n      const arg2Errors = typecheckNode(node.args[1], registeredNodes);\n      errors = errors.concat(arg2Errors);\n      if (node.args[0]?.outputType?.valueType != node.args[1]?.outputType?.valueType) {\n        errors.push(new TypeError(\"arguments must have same type\", node.args[0].pos));\n      }\n    }\n\n    const functionName = node.name\n    const argType = builtins[functionName].inputType;\n\n    // we found a builtin function\n    if (argType) {\n\n      // typecheck the argument\n      // Assume both arguments are the same type (see error produced above)\n      if (argType != 'any' && node.args[0]?.outputType?.valueType != argType) {\n        errors.push(new TypeError(\"incompatible argument type for \" + functionName, node.pos));\n      }\n    }\n  \n    // this is not a known, builtin function\n    else {\n      errors.push(new TypeError(\"unknown function\", node.pos));\n    }    \n\n    return errors;\n  }\n}\n\nclass CheckChoose implements TypeChecker {\n  check(node: AST.ChooseNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\n    let errors: TypeError[] = [];\n\n    const predicate = node.case.predicate;\n    const consequent = node.case.consequent;\n    const otherwise = node.otherwise;\n\n    // First typecheck the inner nodes\n    const predErrors = typecheckNode(predicate, registeredNodes);\n    const consErrors = typecheckNode(consequent, registeredNodes);\n    const otherErrors = typecheckNode(otherwise, registeredNodes);\n    errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\n\n    // check return types are the same for both cases\n    if (consequent?.outputType?.valueType != otherwise?.outputType?.valueType) {\n      errors.push(new TypeError(\"Return types are not the same for both cases\", consequent.pos));\n      errors.push(new TypeError(\"Return types are not the same for both cases\", otherwise.pos));\n    }\n\n    // check that the predicate returns a boolean\n    if (predicate.outputType.valueType != 'boolean') {\n      errors.push(new TypeError(\"Predicate must return a boolean\", predicate.pos));\n    }\n\n    node.outputType.valueType = consequent?.outputType?.valueType;\n\n    return errors;\n  }\n}\n\nclass CheckVariable implements TypeChecker {\n  check(node: AST.VariableAssignmentNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\n    let errors: TypeError[] = [];\n    // First typecheck the assignment node\n    const assignmentErrors = typecheckNode(node.assignment, registeredNodes);\n    errors = errors.concat(assignmentErrors);\n\n    node.outputType.valueType = node.assignment?.outputType?.valueType;\n\n    return errors;\n  }\n}\n\nclass CheckIdentifier implements TypeChecker {\n  check(node: AST.IdentifierNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\n    let errors: TypeError[] = [];\n\n    // Maybe make assigmentId be valueId?\n    let valueNode = registeredNodes[node.assignmentId].assignment;\n\n    // If this assignmentId is not found in the AST, throw an error\n    if (valueNode == undefined) {\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\n    }\n\n    node.outputType.valueType = valueNode.outputType.valueType;\n\n    return errors;\n  }\n}\n\n// Dictionary of builtin functions that maps a function name to the type of its argument\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType} } = {\n  \"IsDefined\": {inputType: 'any', resultType: 'boolean'},\n  \"Inverse\": {inputType: 'number', resultType: 'number'},\n  \"Input\": {inputType: 'number', resultType: 'number'},\n  \"Sink\": {inputType: 'any', resultType: 'any'},\n  \"ParseOrderedPair\": {inputType: 'number', resultType: 'pair'},\n  \"X\": {inputType: 'pair', resultType: 'number'},\n  \"Y\": {inputType: 'pair', resultType: 'number'}\n}\n\nconst checkerMap: Partial<{[K in AST.NodeType]: TypeChecker}> = {\n  'Number' : new CheckNumber(),\n  'Boolean' : new CheckBoolean(),\n  'BinaryOperation' : new CheckBinary(),\n  'Function' : new CheckFunction(),\n  'Choose': new CheckChoose(),\n  'VariableAssignment': new CheckVariable(),\n  'Identifier': new CheckIdentifier()\n}","import {Position} from './position';\nimport * as AST from './ast';\nimport {equals} from './equals';\nimport {findBases} from './findBase';\n\nexport function mudCheck(nodes: AST.Node[], \n                        registeredNodes: {[key: string]: AST.Node},\n                        dependsMap: {[key: string]: string[]},\n                        assertMap: string[]): TypeError[] {\n  const errors = nodes.map(n => mudCheckNode(n, nodes, registeredNodes, dependsMap, assertMap));\n  return ([] as TypeError[]).concat(...errors);\n}\n\nfunction mudCheckNode(node: AST.Node, \n                    nodes: AST.Node[], \n                    registeredNodes: {[key: string]: AST.Node},\n                    dependsMap: {[key: string]: string[]},\n                    assertMap: string[]): TypeError[] {\n  return mudCheckerMap[node.nodeType].mudCheck(node, nodes, registeredNodes, dependsMap, assertMap);\n}\n\nexport class TypeError {\n  constructor(public message: string, public position: Position) {}\n}\n\nexport interface MudChecker {\n  mudCheck(node: AST.Node, \n          nodes: AST.Node[], \n          registeredNodes: {[key: string]: AST.Node},\n          dependsMap: {[key: string]: string[]},\n          assertMap: string[]): TypeError[];\n}\n\nclass MudCheckNumber implements MudChecker {\n  mudCheck(node: AST.NumberNode): TypeError[] {\n    return [];\n  }\n}\n\nclass MudCheckBoolean implements MudChecker {\n    mudCheck(node: AST.BooleanNode): TypeError[] {\n    return [];\n  }\n}\n\nclass MudCheckBinary implements MudChecker {\n    mudCheck(node: AST.BinaryOperationNode, \n            nodes: AST.Node[], \n            registeredNodes: {[key: string]: AST.Node},\n            dependsMap: {[key: string]: string[]},\n            assertMap: string[]): TypeError[] {\n        const errors: TypeError[] = mudCheckNode(node.left, nodes, registeredNodes, dependsMap, assertMap)\n        .concat(mudCheckNode(node.right, nodes, registeredNodes, dependsMap, assertMap));\n\n        // If no type errors, update the output type of this node, based on the outputType of its inputs\n        if (node.right?.outputType?.status == 'Maybe-Undefined' || node.left?.outputType?.status == 'Maybe-Undefined') {\n            node.outputType = {status: 'Maybe-Undefined',\n                              valueType: node.left?.outputType?.valueType };\n        } else {\n            node.outputType = {status: 'Definitely',\n                            valueType: node.left?.outputType?.valueType };\n        }\n\n        return errors;\n    }\n}\n\nclass MudCheckFunction implements MudChecker {\n    mudCheck(node: AST.FunctionNode, \n            nodes: AST.Node[], \n            registeredNodes: {[key: string]: AST.Node},\n            dependsMap: {[key: string]: string[]},\n            assertMap: string[]): TypeError[] {\n        let errors: TypeError[] = [];\n\n        if (node.name == 'Sink') {\n          assertMap = [];\n        }\n        \n        // First typecheck the argument\n        const arg1Errors = mudCheckNode(node.args[0], nodes, registeredNodes, dependsMap, assertMap);\n        errors = errors.concat(arg1Errors);\n        if (node.args.length > 1) {\n        const arg2Errors = mudCheckNode(node.args[1], nodes, registeredNodes, dependsMap, assertMap);\n        errors = errors.concat(arg2Errors);\n        }\n\n        const functionName = node.name\n        const argType = builtins[functionName].inputType;\n        const returnType = builtins[functionName].resultType;\n\n        // only show error if in sink \"node\"\n        if (functionName == 'Sink') {\n        // if sink \"node\" takes in possibly undefined values, warn the author\n        // a sink has one argument\n        if (node.args[0]?.outputType?.status == 'Maybe-Undefined') {\n            errors.push(new TypeError(\"User facing content could be undefined.\", node.args[0].pos));\n        }\n        }\n\n        // If no type errors, update the output type of this node, based on the outputType of its argument\n        if (node.args[0]?.outputType?.status == 'Maybe-Undefined' || functionName == 'Input') {\n            // IsDefined should always output a definitely regardless of argument status\n            if (functionName != 'IsDefined') {\n            node.outputType.status = 'Maybe-Undefined';\n            }\n            else {\n            node.outputType.status = 'Definitely';\n            }\n        } else if (node.args.length > 1) {\n            if (node.args[1].outputType.status == 'Maybe-Undefined') {\n            // Note: IsDefined only has one argument, so we don't need to check for that here\n            node.outputType.status = 'Maybe-Undefined';\n            } else {\n            node.outputType.status = 'Definitely';\n            }\n        } else {\n            node.outputType.status = 'Definitely';\n        }\n\n        node.outputType.valueType = returnType;\n\n        return errors;\n    }\n}\n\nclass MudCheckChoose implements MudChecker {\n    mudCheck(node: AST.ChooseNode, \n            nodes: AST.Node[], \n            registeredNodes: {[key: string]: AST.Node},\n            dependsMap: {[key: string]: string[]},\n            assertMap: string[]): TypeError[] {\n        let errors: TypeError[] = [];\n\n        const predicate = node.case.predicate;\n        const consequent = node.case.consequent;\n        const otherwise = node.otherwise;\n\n        // add stuff to the assertMap\n\n        // First typecheck the inner nodes\n        const predErrors = mudCheckNode(predicate, nodes, registeredNodes, dependsMap, assertMap);\n        const consErrors = mudCheckNode(consequent, nodes, registeredNodes, dependsMap, assertMap);\n        const otherErrors = mudCheckNode(otherwise, nodes, registeredNodes, dependsMap, assertMap);\n        errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\n\n        node.outputType.valueType = consequent.outputType.valueType;\n\n        // DEFUALT status = maybe-undefined\n\n        let consDef = false;\n        let otherDef = false;\n        let localAsserts: string[] = [];\n\n        if (otherwise.outputType.status == 'Definitely') {\n          otherDef = true;\n        }\n\n        // consequent in MU and we have a binary predicate\n        if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'BinaryOperation') {\n          // Cases: both bool *******************************\n          //        bool, function (and vice versa) *********\n          //        bool, binary op (and vice versa) IN PROGRESS\n          //        function, binary op (and vice versa)\n          //        both function ***************************\n          //        both binary op\n\n          // no need for bool, bool\n\n          consDef = doBinOp(predicate, consequent, dependsMap, assertMap);\n\n        }\n\n\n        // propagate maybe-undefined type, or change to definitely\n        // if the predicate is not a function, we cannot error check its type\n        if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'Function') {\n          // we can only errorr check with IsDefined function\n          // IsDefined has only one argument\n          if (predicate.name == 'IsDefined') {\n            handleAsserts(predicate, dependsMap, assertMap);\n            consDef = handleCheck(consequent, dependsMap, assertMap);\n          }\n        }\n\n        if (consequent?.outputType.status == 'Definitely') {\n          consDef = true;\n        }\n\n        if (consDef && otherDef) {\n          node.outputType.status = 'Definitely';\n        }\n\n        return errors;\n    }\n}\n\nclass MudCheckVariable implements MudChecker {\n    mudCheck(node: AST.VariableAssignmentNode, \n            nodes: AST.Node[], \n            registeredNodes: {[key: string]: AST.Node},\n            dependsMap: {[key: string]: string[]},\n            assertMap: string[]): TypeError[] {\n    let errors: TypeError[] = [];\n    // First typecheck the assignment node\n    const assignmentErrors = mudCheckNode(node.assignment, nodes, registeredNodes, dependsMap, assertMap);\n    errors = errors.concat(assignmentErrors);\n\n    // Set variable assignment node output type to the same as it's assignment\n    node.outputType.status = node.assignment.outputType.status;\n    node.outputType.valueType = node.assignment.outputType.valueType;\n\n    return errors;\n  }\n}\n\nclass MudCheckIdentifier implements MudChecker {\n    mudCheck(node: AST.IdentifierNode, \n            nodes: AST.Node[], \n            registeredNodes: {[key: string]: AST.Node},\n            dependsMap: {[key: string]: string[]}): TypeError[] {\n    let errors: TypeError[] = [];\n\n    // Maybe make assigmentId be valueId?\n    let valueNode = registeredNodes[node.assignmentId].assignment;\n\n    // If this assignmentId is not found in the AST, throw an error\n    if (valueNode == undefined) {\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\n    } else {\n      // If we found the assignment node, set the output type of the identifier\n      node.outputType.status = valueNode.outputType.status;\n      node.outputType.valueType = valueNode.outputType.valueType;\n    }\n\n    return errors;\n  }\n}\n\n// Dictionary of builtin functions that maps a function name to the type of its argument\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType} } = {\n  \"IsDefined\": {inputType: 'any', resultType: 'boolean'},\n  \"Inverse\": {inputType: 'number', resultType: 'number'},\n  \"Input\": {inputType: 'number', resultType: 'number'},\n  \"Sink\": {inputType: 'any', resultType: 'any'},\n  \"ParseOrderedPair\": {inputType: 'number', resultType: 'pair'},\n  \"X\": {inputType: 'pair', resultType: 'number'},\n  \"Y\": {inputType: 'pair', resultType: 'number'}\n}\n\nconst mudCheckerMap: Partial<{[K in AST.NodeType]: MudChecker}> = {\n  'Number' : new MudCheckNumber(),\n  'Boolean' : new MudCheckBoolean(),\n  'BinaryOperation' : new MudCheckBinary(),\n  'Function' : new MudCheckFunction(),\n  'Choose': new MudCheckChoose(),\n  'VariableAssignment': new MudCheckVariable(),\n  'Identifier': new MudCheckIdentifier()\n}\n\nfunction handleAsserts(predicate: AST.Node,\n                      dependsMap: {[key: string]: string[]},\n                      assertMap: string[]): void {\n\n    // look up the bases of the predicate\n    let predBases = findBases(predicate, dependsMap);\n    // set outputType to Definitely if consBases are contained in predBases\n    // add to assertMap\n    for (let k = 0; k < predBases.length; k++) {\n      assertMap.push(predBases[k]);\n    }\n}\n\nfunction handleCheck(consequent: AST.Node,\n                    dependsMap: {[key: string]: string[]},\n                    assertMap: string[]): boolean {\n\n  let consBases = findBases(consequent, dependsMap);\n\n  let contained = true;\n    for (let i = 0; i < consBases.length; i++) {\n      if (!assertMap.find(e => e == consBases[i])) {\n        contained = false;\n      }\n    }\n\n    return contained;\n}\n\nfunction resolveBF(predicate: AST.Node,\n                  consequent: AST.Node,\n                  dependsMap: {[key: string]: string[]},\n                  assertMap: string[]): boolean {\n\n  // boolean, function\n  if (predicate.right.name == 'IsDefined') {\n    handleAsserts(predicate.right, dependsMap, assertMap);\n    return handleCheck(consequent, dependsMap, assertMap);\n  }\n  else {\n    return false;\n  }\n\n}\n\nfunction resolveFB(predicate: AST.Node,\n                  consequent: AST.Node,\n                  dependsMap: {[key: string]: string[]},\n                  assertMap: string[]): boolean {\n  // function, boolean\n  if (predicate.left.name == 'IsDefined') {\n    handleAsserts(predicate.left, dependsMap, assertMap);\n    return handleCheck(consequent, dependsMap, assertMap);\n  }\n  else {\n    return false;\n  }\n}\n\nfunction resolveFF(predicate: AST.Node,\n                  consequent: AST.Node,\n                  dependsMap: {[key: string]: string[]},\n                  assertMap: string[]): boolean {\n  // function, function\n  let consDefLeft = false;\n  let consDefRight = false;\n  let consDefBoth = false;\n  let localAsserts: string[] = [];\n\n  if (predicate.left.name == 'IsDefined') {\n    handleAsserts(predicate.left, dependsMap, localAsserts);\n    consDefLeft = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefLeft) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n\n  if (predicate.right.name == 'IsDefined') {\n    handleAsserts(predicate.right, dependsMap, localAsserts);\n    consDefRight = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefRight) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n\n  if (predicate.left.name == 'IsDefined' && predicate.right.name == 'IsDefined' && predicate.operator == '&') {\n    handleAsserts(predicate.left, dependsMap, localAsserts);\n    handleAsserts(predicate.right, dependsMap, localAsserts);\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefBoth) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n\n  if (predicate.operator == '&') {\n    return consDefLeft || consDefRight || consDefBoth;\n  }\n  else if (predicate.operator == '|') {\n    return consDefLeft && consDefRight;\n  }\n  else {\n    return false;\n  }\n}\n\nfunction resolveBBO(predicate: AST.Node,\n  consequent: AST.Node,\n  dependsMap: {[key: string]: string[]},\n  assertMap: string[]): boolean {\n  // boolean, binary operation\n  // recurse on the right\n  let consDefRight = doBinOp(predicate.right, consequent, dependsMap, assertMap);\n  if (predicate.left.value == false && predicate.operator == '|') {\n    return consDefRight;\n  }\n  if (predicate.left.value == true && predicate.operator == '&') {\n    return consDefRight;\n  }\n  else {\n    // this may change to true\n    return false;\n  }\n\n}\n\nfunction resolveBOB(predicate: AST.Node,\n  consequent: AST.Node,\n  dependsMap: {[key: string]: string[]},\n  assertMap: string[]): boolean {\n  // binary operation, boolean\n  let consDefLeft = doBinOp(predicate.left, consequent, dependsMap, assertMap);\n  if (predicate.right.value == false && predicate.operator == '|') {\n    return consDefLeft;\n  }\n  if (predicate.right.value == true && predicate.operator == '&') {\n    return consDefLeft;\n  }\n  else {\n    // this may change to true\n    return false;\n  }\n}\n\nfunction resolveBOF(predicate: AST.Node,\n  consequent: AST.Node,\n  dependsMap: {[key: string]: string[]},\n  assertMap: string[]): boolean {\n  // binary operation, function\n  // recurse on the left with local asserts\n  let consDefLeft = false;\n  let consDefRight = false;\n  let consDefBoth = false;\n  let localAsserts: string[] = [];\n\n  consDefLeft = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\n  if (consDefLeft) {\n    assertMap = assertMap.concat(localAsserts);\n  }\n  localAsserts = [];\n\n  if (predicate.right.name == 'IsDefined') {\n    handleAsserts(predicate.right, dependsMap, localAsserts);\n    consDefRight = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefRight) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n\n  if (predicate.right.name == 'IsDefined' && predicate.operator == '&') {\n    let temp = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\n    handleAsserts(predicate.right, dependsMap, localAsserts);\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefBoth) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n\n  if (predicate.operator == '&') {\n    return consDefLeft || consDefRight || consDefBoth;\n  }\n  else if (predicate.operator == '|') {\n    return consDefLeft && consDefRight;\n  }\n  else {\n    return false;\n  }\n  \n}\n\nfunction resolveFBO(predicate: AST.Node,\n  consequent: AST.Node,\n  dependsMap: {[key: string]: string[]},\n  assertMap: string[]): boolean {\n  // function, binary operation\n  // recurse on the left with local asserts\n  let consDefLeft = false;\n  let consDefRight = false;\n  let consDefBoth = false;\n  let localAsserts: string[] = [];\n\n  consDefRight = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\n  if (consDefRight) {\n    assertMap = assertMap.concat(localAsserts);\n  }\n  localAsserts = [];\n\n  if (predicate.left.name == 'IsDefined') {\n    handleAsserts(predicate.left, dependsMap, localAsserts);\n    consDefLeft = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefLeft) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n\n  if (predicate.left.name == 'IsDefined' && predicate.operator == '&') {\n    let temp = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\n    handleAsserts(predicate.left, dependsMap, localAsserts);\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefBoth) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n\n  if (predicate.operator == '&') {\n    return consDefLeft || consDefRight || consDefBoth;\n  }\n  else if (predicate.operator == '|') {\n    return consDefLeft && consDefRight;\n  }\n  else {\n    return false;\n  }\n}\n\nfunction resolveBOBO(predicate: AST.Node,\n  consequent: AST.Node,\n  dependsMap: {[key: string]: string[]},\n  assertMap: string[]): boolean {\n  // binary operation, binary operation\n  let consDefLeft = false;\n  let consDefRight = false;\n  let consDefBoth = false;\n  let localAsserts: string[] = [];\n\n  consDefRight = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\n  if (consDefRight) {\n    assertMap = assertMap.concat(localAsserts);\n  }\n  localAsserts = [];\n\n  consDefLeft = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\n  if (consDefLeft) {\n    assertMap = assertMap.concat(localAsserts);\n  }\n  localAsserts = [];\n\n  if (predicate.operator == '&') {\n    let temp = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\n    let temp2 = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\n    if (consDefBoth) {\n      assertMap = assertMap.concat(localAsserts);\n    }\n    localAsserts = [];\n  }\n\n  if (predicate.operator == '&') {\n    return consDefLeft || consDefRight || consDefBoth;\n  }\n  else if (predicate.operator == '|') {\n    return consDefLeft && consDefRight;\n  }\n  else {\n    return false;\n  }\n}\n\nfunction doBinOp(predicate: AST.Node,\n  consequent: AST.Node,\n  dependsMap: {[key: string]: string[]},\n  assertMap: string[]): boolean {\n  let consDef = false;\n  // function, boolean\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'Boolean') {\n    consDef = resolveFB(predicate, consequent, dependsMap, assertMap);\n  }\n\n  // boolean, function\n  if (predicate.left.nodeType == 'Boolean' && predicate.right.nodeType == 'Function') {\n    consDef = resolveBF(predicate, consequent, dependsMap, assertMap);\n  }\n\n  // function, function\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'Function') {\n    consDef = resolveFF(predicate, consequent, dependsMap, assertMap);\n\n  }\n\n  // bool, binary op\n  if (predicate.left.nodeType == 'Boolean' && predicate.right.nodeType == 'BinaryOperation') {\n    consDef = resolveBBO(predicate, consequent, dependsMap, assertMap);\n  }\n\n  // binary op, bool\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'Boolean') {\n    consDef = resolveBOB(predicate, consequent, dependsMap, assertMap);\n  }\n\n  // function, binary op\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'BinaryOperation') {\n    consDef = resolveFBO(predicate, consequent, dependsMap, assertMap);\n  }\n\n  // binary op, function\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'Function') {\n    consDef = resolveBOF(predicate, consequent, dependsMap, assertMap);\n  }\n\n  // binary op, binary op\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'BinaryOperation') {\n    consDef = resolveBOBO(predicate, consequent, dependsMap, assertMap);\n  }\n\n  return consDef;\n}","import * as Parselet from './parselet';\nimport {Token, TokenType} from './lexer';\nimport {TokenStream} from './tokenstream';\nimport {ParseError, token2pos} from './position';\nimport * as AST from './ast';\n\nexport function parse(text: string,\n                      varMap: {[key: string]: string},\n                      registeredNodes: {[key: string]: AST.Node},\n                      dependsMap: {[key: string]: string[]}): \n                      {nodes: AST.Node[]; errors: ParseError[]} {\n  const nodes: AST.Node[] = [];\n\n  const tokens = new TokenStream(text);\n  const parser = new Parser();\n  while (tokens.peek()) {\n    try {\n      nodes.push(parser.parse(tokens, 0, varMap, registeredNodes, dependsMap));\n    } catch (e) {\n      return {\n        nodes,\n        errors: [e],\n      };\n    }\n  }\n\n  return {nodes, errors: []};\n}\n\nexport abstract class AbstractParser {\n  public bindingPowers: {[tokenType in TokenType]: number};\n\n  protected abstract initialMap(): Partial<\n    {[K in TokenType]: Parselet.InitialParselet}\n  >;\n  protected abstract consequentMap(): Partial<\n    {[K in TokenType]: Parselet.ConsequentParselet}\n  >;\n  protected abstract bindingClasses(): TokenType[][];\n\n  constructor() {\n    this.bindingPowers = {} as any;\n\n    const bindingClasses = this.bindingClasses();\n    for (let i = 0; i < bindingClasses.length; i++) {\n      for (const tokenType of bindingClasses[i]) {\n        this.bindingPowers[tokenType] = 10 * i + 9;\n      }\n    }\n\n    for (const tokenType of Object.keys(this.consequentMap) as TokenType[]) {\n      if (this.bindingPowers[tokenType] == undefined) {\n        throw new Error(\n          `Token ${tokenType} defined in consequentMap has no associated binding power.\n          Make sure it is also listed in bindingClasses.`,\n        );\n      }\n    }\n  }\n\n  bindingPower(token: Token): number {\n    if (this.bindingPowers[token.type] != undefined) {\n      return this.bindingPowers[token.type];\n    } else {\n      throw new ParseError(\n        `Unexpected token type ${token.type}.`,\n        token2pos(token),\n      );\n    }\n  }\n\n  parse(tokens: TokenStream,\n        currentBindingPower: number,\n        varMap: {[key: string]: string},\n        registeredNodes: {[key: string]: AST.Node},\n        dependsMap: {[key: string]: string[]}): AST.Node {\n    const token = tokens.consume();\n    if (!token) {\n      throw new ParseError(\n        `Unexpected end of tokens.`,\n        token2pos(tokens.last()),\n      );\n    }\n\n    const initialParselet = this.initialMap()[token.type];\n\n    if (!initialParselet) {\n      throw new ParseError(\n        `Unexpected token type ${token.type}`,\n        token2pos(token),\n      );\n    }\n\n    let left = initialParselet.parse(this, tokens, token, varMap, registeredNodes, dependsMap);\n\n    while (true) {\n      const next = tokens.peek();\n      if (!next) {\n        break;\n      }\n\n      const consequentParselet = this.consequentMap()[next.type];\n\n      if (!consequentParselet) {\n        break;\n      }\n\n      if (currentBindingPower >= this.bindingPower(next)) {\n        break;\n      }\n\n      tokens.consume();\n      left = consequentParselet.parse(this, tokens, left, next, varMap, registeredNodes, dependsMap);\n    }\n\n    return left;\n  }\n}\n\nexport class Parser extends AbstractParser {\n  initialMap() {\n    return {\n      NUMBER: new Parselet.NumberParselet(),\n      TRUE: new Parselet.BooleanParselet(true),\n      FALSE: new Parselet.BooleanParselet(false),\n      '(': new Parselet.ParenParselet(),\n      FUNCTION: new Parselet.FunctionParselet(),\n      CHOOSE1: new Parselet.ChooseParselet(),\n      IDENTIFIER: new Parselet.IdentifierParselet()\n    };\n  }\n\n  consequentMap() {\n    return {\n      '+': new Parselet.BinaryOperatorParselet('+', 'left'),\n      '-': new Parselet.BinaryOperatorParselet('-', 'left'),\n      '*': new Parselet.BinaryOperatorParselet('*', 'left'),\n      '/': new Parselet.BinaryOperatorParselet('/', 'left'),\n      '|': new Parselet.BinaryOperatorParselet('|', 'right'),\n      '&': new Parselet.BinaryOperatorParselet('&', 'right')\n    };\n  }\n\n  bindingClasses() {\n    const classes: TokenType[][] = [['+', '-'], ['*', '/'], ['|', '&']];\n    return classes;\n  }\n}\n","import * as d3Hierarchy from 'd3-hierarchy';\nimport * as d3Select from 'd3-selection';\nimport * as d3shape from 'd3-shape';\nimport * as AST from './ast';\n\nexport function visualize(nodes: AST.Node[]): void {\n\n    // Placement and size of tree\n    const margin = {top: 20, right: 90, bottom: 20, left: 90};\n    const height = 300 - margin.top - margin.bottom;\n    const width  = 500 - margin.left - margin.right;\n  \n    // Make the svg\n    d3Select.select('#viz').selectAll('svg').remove();\n    const viz = d3Select.select('#viz').append('svg');\n  \n    // Remove existing visualizations\n    viz.selectAll('*').remove();\n  \n    // Add a new visualization\n    viz.attr('width', width + margin.left + margin.right)\n       .attr('height', height + margin.top + margin.bottom);\n\n    const root: Node = {nodeType: 'Program', children: nodes}\n\n    // Visualize all the statements\n    // for (var statement of nodes) {\n\n      // Create the tree and layout\n      const treemap = d3Hierarchy.tree()\n        .size([height, width])\n        .separation(() => 1);\n      const treelayout = d3Hierarchy.hierarchy(root, getChildren);\n      const tree = treemap(treelayout);\n  \n      // Add a new graph element for this statement\n      const g = viz.append('g')\n                  //  .attr(\"transform\", `translate(${root.dy / 3},${root.dx - x0})`);\n                   .attr('transform', `translate(${margin.left}, ${margin.top})`)\n                   .attr(\"font-family\", \"sans-serif\")\n                   .attr(\"font-size\", 12)\n               \n      // Edge updates\n      const link = g.selectAll('path.link').data(tree.links());\n\n      // Edge entry\n      const linkEnter = link.enter().append('path', 'g');\n        \n      // general edge attributes\n      linkEnter.attr('class', 'link')\n               .attr('fill', 'none')\n               .attr(\"stroke-opacity\", 0.4)\n               .attr('stroke', '#555')\n               .attr(\"stroke-width\", 1.5)\n               .attr('d', connection);\n\n        \n      // Node updates\n      const node = g.selectAll('g.node').data(tree.descendants());\n\n      // Node entry\n      const nodeEnter = node.enter().append('g');\n\n      // general node attributes\n      nodeEnter.attr('class', 'node')\n               .attr('transform', d => `translate(${d.y}, ${d.x})`);\n\n      nodeEnter.append('circle')\n               .attr(\"fill\", getFill)\n               .attr('r', '2.5')\n               .attr('stroke-width', 10);\n\n      // add text\n      nodeEnter.append('text')\n                // .attr('dy', '-10px')\n                .attr(\"dy\", \"0.31em\")\n                .attr(\"x\", d => d.children ? -8 : 8)\n                .attr(\"text-anchor\", d => d.children ? \"end\" : \"start\")\n                .attr('fill', d => isUndefined(d) ? '#fc6666' : 'black')\n                .style(\"fill-opacity\", 1)\n                .call(getTextBox)\n                .datum(d => d.data)\n                .text(getText)\n          .clone(true).lower()\n            .attr(\"stroke\", \"white\");\n    \n      // Highlight undefined -- not working\n      // Inspired in part by https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\n      nodeEnter.filter((d,i) => isUndefined(d))\n        .call(yep)\n        .insert('rect', 'text')\n        .attr(\"x\", function(d){return d.bbox.x})\n        .attr(\"y\", function(d){return d.bbox.y})\n        .attr(\"width\", function(d){return d.bbox.width})\n        .attr(\"height\", function(d){return d.bbox.height}) \n        .attr('fill', 'black')             \n    // }\n}\n\n// From https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\nfunction getTextBox(selection) {\n  selection.each(function(d){d.bbox = this.getBBox();})\n}\n\nfunction yep(selection) {\n  // console.log(selection.nodes().map((d)=>d.bbox));\n}\n\n\nconst connection = d3shape.linkHorizontal().x(d => d.y).y(d => d.x)\n\nfunction getChildren(node: AST.Node): AST.Node[] {\n  var children: AST.Node[] = [];\n  switch (node.nodeType) {\n    case 'Program':\n      children = node.children;\n      break;\n    case 'Function':\n      children = node.args;\n      break;\n    case 'Choose':\n      children = [node.case.predicate, node.case.consequent, node.otherwise];\n      break;\n    case 'BinaryOperation':\n      children = [node.left, node.right];\n      break;\n    case 'VariableAssignment':\n      children = [node.assignment];\n      break;\n    default:\n      children = [];\n    }\n\n  return children;\n}\n\nfunction getText(node) {\n  var text = \"\";\n  switch (node.nodeType) {\n    case 'Program':\n      text = '';\n      break;\n    case 'Function':\n      text = node.name;\n      break;\n    case 'Choose':\n      text = \"choose\";\n      break;\n    case 'BinaryOperation':\n      text = node.operator;\n      break;\n    case 'VariableAssignment':\n      text = node.name;\n      break;\n    case 'Identifier':\n      text = node.name;\n      break;\n    case 'Number':  \n      text = node.value.toString();\n      break;\n    case 'Boolean':\n      text = node.value.toString();\n      break;\n    default:\n      text = \"\";\n  }\n\n  return text;\n}\n\nfunction getFill(node): string {\n  if (isUndefined(node)) {\n    return '#fc6666'\n  }\n  if (node.children) {\n    return '#555'\n  } else {\n    return '#999'\n  }\n}\n\nfunction isUndefined(d) {\n  return d.data.outputType?.status === 'Maybe-Undefined'\n}","import * as AST from './ast';\n\nexport function findBases(node: AST.Node, dependsMap: {[key: string]: string[]}): string[] {\n    return baseMap[node.nodeType].findBase(node, dependsMap); \n}\n\nexport interface BaseFinder {\n  findBase(node: AST.Node, dependsMap: {[key: string]: string[]}): string[];\n}\n\nclass BaseNumber implements BaseFinder {\n  findBase(node: AST.NumberNode): string[] {\n    return []\n  }\n}\n\nclass BaseBoolean implements BaseFinder {\n    findBase(node: AST.BooleanNode): string[] {\n        return []\n    }\n}\n\nclass BaseBinary implements BaseFinder {\n    findBase(node: AST.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\n        let baseList: string[] = [];\n        // recursively call findBases on left and right\n        let leftList = findBases(node.left, dependsMap);\n        baseList = baseList.concat(leftList);\n        let rightList = findBases(node.right, dependsMap)\n        baseList = baseList.concat(rightList);\n        return baseList;\n    }\n}\n\n// examples: x = Input(3); x = IsDefined(Input(3)); z = Inverse(x)\n// need dependsMap for the third example\nclass BaseFunction implements BaseFinder {\n    findBase(node: AST.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\n        console.log(\"in base function\");\n        let baseList: string[] = [];\n        if (node.name == \"Input\") {\n            // this is a base\n            baseList.push(node.nodeId);\n        }\n        else {\n            // recursively call findBases on argument(s)\n            for (let i = 0; i < node.args.length; i++) {\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\n            }\n        }\n        return baseList;\n    }\n}\n\n// assume that choose nodes will never create their own bases\n// they can still error check previously defined bases\nclass BaseChoose implements BaseFinder {\n    findBase(node: AST.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\n        let baseList: string[] = [];\n        // the bases of the cons and the otherwise\n        let consBases = findBases(node.case.consequent, dependsMap);\n        baseList = baseList.concat(consBases);\n        let otherBases = findBases(node.otherwise, dependsMap);\n        baseList = baseList.concat(otherBases);\n        return baseList;\n    }\n}\n\nclass BaseVariableAssignment implements BaseFinder {\n    findBase(node: AST.VariableAssignmentNode): string[] {\n        return []\n    }\n}\n\nclass BaseIdentifier implements BaseFinder {\n    findBase(node: AST.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\n        // follow the chain in the dependsMap\n        return dependsMap[node.assignmentId];\n    }\n}\n\n\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\n  'Number' : new BaseNumber(),\n  'Boolean' : new BaseBoolean(),\n  'BinaryOperation' : new BaseBinary(),\n  'Function' : new BaseFunction(),\n  'Choose': new BaseChoose(),\n  'VariableAssignment': new BaseVariableAssignment(),\n  'Identifier': new BaseIdentifier()\n}\n","import { TokenStream } from './tokenstream';\nimport { Token, TokenType, BinaryOperationTokenType} from './lexer';\nimport * as AST from './ast';\nimport { AbstractParser } from './parser';\nimport {ParseError, token2pos, join, pos2string} from './position';\nimport {findBases} from './findBase';\n\nexport interface InitialParselet {\n  parse(parser: AbstractParser,\n        tokens: TokenStream, token: Token,\n        varMap: {[key: string]: string},\n        registeredNodes: {[key: string]: AST.Node},\n        dependsMap: {[key: string]: string[]}): AST.Node;\n}\n\n\nexport class NumberParselet implements InitialParselet {\n  parse(_parser: AbstractParser,\n        _tokens: TokenStream,\n        token: Token,\n        varMap: {[key: string]: string},\n        registeredNodes: {[key: string]: AST.Node},\n        dependsMap: {[key: string]: string[]}) {\n    const position = token2pos(token);\n    const id = pos2string(position);\n    // add node to the map\n    let newNode = {\n      nodeType: 'Number' as 'Number',\n      value: parseFloat(token.text),\n      outputType: { status: 'Definitely' as 'Definitely',\n                    valueType: 'number' as 'number' },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\n\nexport class BooleanParselet implements InitialParselet {\n  constructor(private value: boolean) {}\n  parse(_parser: AbstractParser,\n        _tokens: TokenStream, token: Token,\n        varMap: {[key: string]: string},\n        registeredNodes: {[key: string]: AST.Node},\n        dependsMap: {[key: string]: string[]}) {\n    const position = token2pos(token);\n    const id = pos2string(position);\n    let newNode = {\n      nodeType: 'Boolean' as 'Boolean',\n      value: this.value,\n      outputType: { status: 'Definitely' as 'Definitely',\n                    valueType: 'boolean' as 'boolean' },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\n\nexport class ParenParselet implements InitialParselet {\n  parse(parser: AbstractParser,\n    tokens: TokenStream,\n    _token: Token,\n    varMap: {[key: string]: string},\n    registeredNodes: {[key: string]: AST.Node},\n    dependsMap: {[key: string]: string[]}) {\n\n    const exp = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    tokens.expectToken(')');\n\n    return exp;\n  }\n}\n\nexport abstract class ConsequentParselet {\n  constructor(\n    readonly tokenType: TokenType,\n    readonly associativity: 'left' | 'right'\n  ) {}\n  abstract parse(\n    parser: AbstractParser,\n    tokens: TokenStream,\n    left: AST.Node,\n    token: Token,\n    varMap: {[key: string]: string},\n    registeredNodes: {[key: string]: AST.Node},\n    dependsMap: {[key: string]: string[]}\n  ): AST.Node;\n}\n\nexport class BinaryOperatorParselet extends ConsequentParselet {\n  constructor(\n    public tokenType: BinaryOperationTokenType,\n    associativity: 'left' | 'right'\n  ) {\n    super(tokenType, associativity);\n  }\n\n  parse(\n    parser: AbstractParser,\n    tokens: TokenStream,\n    left: AST.Node,\n    token: Token,\n    varMap: {[key: string]: string},\n    registeredNodes: {[key: string]: AST.Node},\n    dependsMap: {[key: string]: string[]}\n  ): AST.Node {\n    const bindingPower = parser.bindingPower(token);\n\n    const right = parser.parse(\n      tokens,\n      this.associativity == 'left' ? bindingPower : bindingPower - 1,\n      varMap,\n      registeredNodes,\n      dependsMap\n    );\n    const position = join(left.pos, token2pos(tokens.last()));\n    const id = pos2string(position);\n    let newNode = {\n      nodeType: 'BinaryOperation' as 'BinaryOperation',\n      operator: this.tokenType,\n      left,\n      right,\n      outputType: undefined,\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n\n    return newNode;\n  }\n}\n\n// Parse function calls\n// Limitation: Functions are allowed to take exactly one argument\nexport class FunctionParselet implements InitialParselet {\n  \n  parse(parser: AbstractParser,\n    tokens: TokenStream,\n    token: Token,\n    varMap: {[key: string]: string},\n    registeredNodes: {[key: string]: AST.Node},\n    dependsMap: {[key: string]: string[]}) {\n\n    const position = token2pos(token);\n    const id = pos2string(position);\n    tokens.expectToken('(');\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\n    let args = [arg1];\n    if (token.text == \"ParseOrderedPair\") {\n      const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for second argument\n      args.push(arg2);\n    }\n    tokens.expectToken(')');\n    let newNode = {\n      nodeType: 'Function' as 'Function',\n      name: token.text,\n      args: args,\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\n                    valueType: undefined },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\n\nexport class ChooseParselet implements InitialParselet {\n  parse(parser: AbstractParser,\n    tokens: TokenStream,\n    token: Token,\n    varMap: {[key: string]: string},\n    registeredNodes: {[key: string]: AST.Node},\n    dependsMap: {[key: string]: string[]}) {\n    const position = token2pos(token);\n    const id = pos2string(position);\n\n    const predicate = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    const consequent = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n    tokens.expectToken('CHOOSE2');\n    const otherwise = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n\n    let newNode = {\n      nodeType: 'Choose' as 'Choose',\n      case: { predicate: predicate, consequent: consequent },\n      otherwise: otherwise,\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\n                    valueType: undefined },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    return newNode;\n  }\n}\n\nexport class VariableAssignmentParselet implements InitialParselet {\n  parse(parser: AbstractParser,\n    tokens: TokenStream,\n    token: Token,\n    varMap: {[key: string]: string},\n    registeredNodes: {[key: string]: AST.Node},\n    dependsMap: {[key: string]: string[]}) {\n\n    const position = token2pos(token);\n    const id = pos2string(position);\n    \n    // deal with variable assignment\n    tokens.expectToken('=');\n    const assignment = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\n\n    // need to save the variable and its assignment in a lookup table\n    varMap[token.text] = id;\n    let newNode = {\n      nodeType: 'VariableAssignment' as 'VariableAssignment',\n      name: token.text,\n      assignment: assignment,\n      outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\n                    valueType: assignment?.outputType?.valueType },\n      pos: position,\n      nodeId: id\n    };\n    registeredNodes[id] = newNode;\n    dependsMap[id] = findBases(assignment, dependsMap); // NEW FUNCTION HERE\n\n    return newNode;\n  }\n}\n\nexport class IdentifierParselet implements InitialParselet {\n  parse(parser: AbstractParser,\n    tokens: TokenStream,\n    token: Token,\n    varMap: {[key: string]: string},\n    registeredNodes: {[key: string]: AST.Node},\n    dependsMap: {[key: string]: string[]}) {\n    \n    const position = token2pos(token);\n    const id = pos2string(position);\n    // need to look up known variables in a lookup table (map?)\n\n    const assignmentId = varMap[token.text];\n\n    if (!assignmentId) {\n      const varParselet = new VariableAssignmentParselet();\n      return varParselet.parse(parser, tokens, token, varMap, registeredNodes, dependsMap);\n    }\n    else {\n      let newNode = {\n        nodeType: 'Identifier' as 'Identifier',\n        name: token.text,\n        assignmentId: assignmentId,\n        outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\n                      valueType: undefined },\n        pos: position,\n        nodeId: id\n      };\n      registeredNodes[id] = newNode;\n      return newNode;\n    }\n  }\n}\n","import {Token, TokenType, getTokens} from './lexer';\nimport {ParseError, token2pos} from './position';\n\nexport class TokenStream {\n  tokens: Token[];\n  pos: number = 0;\n\n  constructor(text: string) {\n    this.tokens = getTokens(text).filter(t => t.type != 'COMMENT');\n  }\n\n  consume(): Token | undefined {\n    const token = this.tokens[this.pos];\n    if (token) {\n      this.pos += 1;\n    }\n    return token;\n  }\n\n  peek(): Token | undefined {\n    return this.tokens[this.pos];\n  }\n\n  last(): Token {\n    return this.tokens[this.pos - 1];\n  }\n\n  expectToken<T extends TokenType>(expectedType: T): Token<T> {\n    const actual = this.consume();\n\n    if (!actual) {\n      throw new ParseError(\n        `Expected \"${expectedType}\" token but found none.`,\n        token2pos(this.last()),\n      );\n    }\n\n    if (actual.type != expectedType) {\n      throw new ParseError(\n        `Expected \"${expectedType}\" token type but found \"${actual.type}\".`,\n        token2pos(actual),\n      );\n    }\n\n    return actual as Token<T>;\n  }\n}\n","import { Token } from './lexer';\n\nexport type Position = {\n  first_line: number;\n  first_column: number;\n  last_line: number;\n  last_column: number;\n};\n\nexport function token2pos(token: Token): Position {\n  return {\n    first_line: token.line,\n    last_line: token.line,\n    first_column: token.first_column,\n    last_column: token.last_column\n  }\n}\n\nexport function join(start: Position, end: Position) {\n  return {\n    first_line: start.first_line,\n    last_line: end.last_line,\n    first_column: start.first_column,\n    last_column: end.last_column\n  };\n}\n\nexport function pos2string(pos: Position): string {\n  return pos.first_line.toString() + \".\" +\n         pos.first_column.toString() + \".\" +\n         pos.last_line.toString() + \".\" +\n         pos.last_column.toString();\n}\n\n// note, extending Error in the browser is problematic\n// https://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node\nexport class ParseError {\n  constructor(public message: string, public position: Position) {}\n}\n"]}