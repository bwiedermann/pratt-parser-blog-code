{"version":3,"sources":["src/position.ts","src/findBase.ts","src/parselet.ts","src/lexer.ts","src/tokenstream.ts","src/parser.ts","src/parseResults.ts","src/typechecker.ts","src/darChecker.ts","src/miniCL.ts","src/visualization.ts","src/devTools.ts","src/index.ts"],"names":["token","first_line","line","last_line","first_column","last_column","start","end","pos","toString","constructor","message","position","node","dependsMap","baseMap","nodeType","findBase","baseList","leftList","findBases","left","concat","rightList","right","console","log","name","push","nodeId","i","args","length","consBases","case","consequent","otherBases","otherwise","assignmentId","BaseNumber","BaseBoolean","BaseBinary","BaseFunction","BaseChoose","BaseVariableAssignment","BaseIdentifier","BaseIterator","parse","_parser","_tokens","varMap","registeredNodes","position_1","id","newNode","value","parseFloat","text","outputType","status","valueType","parser","tokens","_token","exp","expectToken","arg1","arg2","arg3","index","values","step","tokenType","associativity","ConsequentParselet","bindingPower","last","operator","undefined","predicate","assignment","findBase_1","varParselet","VariableAssignmentParselet","state","stack","split","stream","stream_parser_1","string","eol","getToken","emitToken","makeEmit","fullToken","Error","getDefaultToken","type","current","eatSpace","match","next","lexer_1","filter","t","consume","peek","expectedType","actual","nodes","tokenstream_1","Parser","e","errors","bindingPowers","bindingClasses","Object","keys","consequentMap","currentBindingPower","initialParselet","initialMap","consequentParselet","AbstractParser","NUMBER","NumberParselet","TRUE","BooleanParselet","FALSE","ParenParselet","BracketParselet","FUNCTION","FunctionParselet","CHOOSE1","ChooseParselet","IDENTIFIER","IdentifierParselet","BinaryOperatorParselet","classes","state_1","define","create","emptyParseResults","update","tr","docChanged","parseProgram","contents","doc","ast","parser_1","parseErrors","map","n","typecheckNode","checkerMap","check","TypeError","arg1Errors","arg2Errors","functionName","argType","builtins","inputType","predErrors","consErrors","otherErrors","assignmentErrors","valueNode","resultType","CheckNumber","CheckBoolean","CheckBinary","CheckFunction","CheckChoose","CheckVariable","CheckIdentifier","CheckIterator","darCheckNode","darCheckerMap","darCheck","evaluateOperation","assignmentNode","getRange","out","DarCheckNumber","DarCheckBinary","DarCheckFunction","DarCheckVariable","DarCheckIdentifier","DarCheckIterator","startState","token2tag","view","results","field","parseResults_1","assertMap","darErrors","darChecker_1","typeErrors","typechecker_1","parseDiagnostics","makeDiagnostic","typeDiagnostics","darDiagnostics","severity","error","from","firstLine","to","lastLine","margin","top","bottom","height","width","select","selectAll","remove","viz","append","attr","root","children","treemap","tree","size","separation","treelayout","hierarchy","getChildren","g","link","data","links","linkEnter","enter","connection","descendants","nodeEnter","d","y","x","getFill","isUndefined","style","call","getTextBox","datum","getText","clone","lower","yep","insert","bbox","selection","each","getBBox","linkHorizontal","astJSON","JSON","stringify","replaceContents","astViewer","dependsJSON","dependsViewer","visualization_1","basic_setup_1","extensions","lang_json_1","lint_1","editable","of","newJSONViewerState","parent","document","querySelector","editor","changes","fold_1","miniCLEditor","miniCL_1","dispatch","updateOutput","devTools_1"],"mappings":"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","file":"","sourcesContent":["import { Token } from './lexer';\r\n\r\nexport type Position = {\r\n  first_line: number;\r\n  first_column: number;\r\n  last_line: number;\r\n  last_column: number;\r\n};\r\n\r\nexport function token2pos(token: Token): Position {\r\n  return {\r\n    first_line: token.line,\r\n    last_line: token.line,\r\n    first_column: token.first_column,\r\n    last_column: token.last_column\r\n  }\r\n}\r\n\r\nexport function join(start: Position, end: Position) {\r\n  return {\r\n    first_line: start.first_line,\r\n    last_line: end.last_line,\r\n    first_column: start.first_column,\r\n    last_column: end.last_column\r\n  };\r\n}\r\n\r\nexport function pos2string(pos: Position): string {\r\n  return pos.first_line.toString() + \".\" +\r\n         pos.first_column.toString() + \".\" +\r\n         pos.last_line.toString() + \".\" +\r\n         pos.last_column.toString();\r\n}\r\n\r\n// note, extending Error in the browser is problematic\r\n// https://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node\r\nexport class ParseError {\r\n  constructor(public message: string, public position: Position) {}\r\n}\r\n","import * as AST from './ast';\r\n\r\nexport function findBases(node: AST.Node, dependsMap: {[key: string]: string[]}): string[] {\r\n    return baseMap[node.nodeType].findBase(node, dependsMap); \r\n}\r\n\r\nexport interface BaseFinder {\r\n  findBase(node: AST.Node, dependsMap: {[key: string]: string[]}): string[];\r\n}\r\n\r\nclass BaseNumber implements BaseFinder {\r\n  findBase(node: AST.NumberNode): string[] {\r\n    return []\r\n  }\r\n}\r\n\r\nclass BaseBoolean implements BaseFinder {\r\n    findBase(node: AST.BooleanNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\nclass BaseBinary implements BaseFinder {\r\n    findBase(node: AST.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        let baseList: string[] = [];\r\n        // recursively call findBases on left and right\r\n        let leftList = findBases(node.left, dependsMap);\r\n        baseList = baseList.concat(leftList);\r\n        let rightList = findBases(node.right, dependsMap)\r\n        baseList = baseList.concat(rightList);\r\n        return baseList;\r\n    }\r\n}\r\n\r\n// examples: x = Input(3); x = IsDefined(Input(3)); z = Inverse(x)\r\n// need dependsMap for the third example\r\nclass BaseFunction implements BaseFinder {\r\n    findBase(node: AST.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        console.log(\"in base function\");\r\n        let baseList: string[] = [];\r\n        if (node.name == \"Input\") {\r\n            // this is a base\r\n            baseList.push(node.nodeId);\r\n        }\r\n        else {\r\n            // recursively call findBases on argument(s)\r\n            for (let i = 0; i < node.args.length; i++) {\r\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\r\n            }\r\n        }\r\n        return baseList;\r\n    }\r\n}\r\n\r\n// assume that choose nodes will never create their own bases\r\n// they can still error check previously defined bases\r\nclass BaseChoose implements BaseFinder {\r\n    findBase(node: AST.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        let baseList: string[] = [];\r\n        // the bases of the cons and the otherwise\r\n        letÂ consBases = findBases(node.case.consequent, dependsMap);\r\n        baseList = baseList.concat(consBases);\r\n        let otherBases = findBases(node.otherwise, dependsMap);\r\n        baseList = baseList.concat(otherBases);\r\n        return baseList;\r\n    }\r\n}\r\n\r\nclass BaseVariableAssignment implements BaseFinder {\r\n    findBase(node: AST.VariableAssignmentNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\nclass BaseIdentifier implements BaseFinder {\r\n    findBase(node: AST.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        // follow the chain in the dependsMap\r\n        return dependsMap[node.assignmentId];\r\n    }\r\n}\r\n\r\nclass BaseIterator implements BaseFinder {\r\n    findBase(node: AST.IteratorNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\n\r\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\r\n  'Number' : new BaseNumber(),\r\n  'Boolean' : new BaseBoolean(),\r\n  'BinaryOperation' : new BaseBinary(),\r\n  'Function' : new BaseFunction(),\r\n  'Choose': new BaseChoose(),\r\n  'VariableAssignment': new BaseVariableAssignment(),\r\n  'Identifier': new BaseIdentifier(),\r\n  'Iterator': new BaseIterator()\r\n}\r\n","import { TokenStream } from './tokenstream';\r\nimport { Token, TokenType, BinaryOperationTokenType} from './lexer';\r\nimport * as AST from './ast';\r\nimport { AbstractParser } from './parser';\r\nimport {ParseError, token2pos, join, pos2string} from './position';\r\nimport {findBases} from './findBase';\r\n\r\nexport interface InitialParselet {\r\n  parse(parser: AbstractParser,\r\n        tokens: TokenStream, token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}): AST.Node;\r\n}\r\n\r\n\r\nexport class NumberParselet implements InitialParselet {\r\n  parse(_parser: AbstractParser,\r\n        _tokens: TokenStream,\r\n        token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // add node to the map\r\n    let newNode = {\r\n      nodeType: 'Number' as 'Number',\r\n      value: parseFloat(token.text),\r\n      outputType: { status: 'Definitely' as 'Definitely',\r\n                    valueType: 'number' as 'number' },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    console.log(\"The number parslet is running now!\")\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class BooleanParselet implements InitialParselet {\r\n  constructor(private value: boolean) {}\r\n  parse(_parser: AbstractParser,\r\n        _tokens: TokenStream, token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    let newNode = {\r\n      nodeType: 'Boolean' as 'Boolean',\r\n      value: this.value,\r\n      outputType: { status: 'Definitely' as 'Definitely',\r\n                    valueType: 'boolean' as 'boolean' },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class ParenParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    _token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const exp = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    tokens.expectToken(')');\r\n\r\n    return exp;\r\n  }\r\n}\r\n\r\nexport class BracketParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream, token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    const arg3 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    tokens.expectToken(']');\r\n\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // add node to the map\r\n    let newNode = {\r\n      nodeType: 'Iterator' as 'Iterator',\r\n      outputType: { status: 'Definitely' as 'Definitely',\r\n                    valueType: 'number' as 'number' },\r\n      pos: position,\r\n      nodeId: id,\r\n      index: 0,\r\n      values: [],\r\n      start: arg1,\r\n      end: arg2,\r\n      step: arg3,\r\n    };\r\n\r\n    console.log(\"The Iterator parslet is running!\")\r\n    registeredNodes[id] = newNode;\r\n\r\n\r\n    return newNode;\r\n\r\n  }\r\n}\r\n\r\nexport abstract class ConsequentParselet {\r\n  constructor(\r\n    readonly tokenType: TokenType,\r\n    readonly associativity: 'left' | 'right'\r\n  ) {}\r\n  abstract parse(\r\n    parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    left: AST.Node,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}\r\n  ): AST.Node;\r\n}\r\n\r\nexport class BinaryOperatorParselet extends ConsequentParselet {\r\n  constructor(\r\n    public tokenType: BinaryOperationTokenType,\r\n    associativity: 'left' | 'right'\r\n  ) {\r\n    super(tokenType, associativity);\r\n  }\r\n\r\n  parse(\r\n    parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    left: AST.Node,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}\r\n  ): AST.Node {\r\n    const bindingPower = parser.bindingPower(token);\r\n\r\n    const right = parser.parse(\r\n      tokens,\r\n      this.associativity == 'left' ? bindingPower : bindingPower - 1,\r\n      varMap,\r\n      registeredNodes,\r\n      dependsMap\r\n    );\r\n    const position = join(left.pos, token2pos(tokens.last()));\r\n    const id = pos2string(position);\r\n    let newNode = {\r\n      nodeType: 'BinaryOperation' as 'BinaryOperation',\r\n      operator: this.tokenType,\r\n      left,\r\n      right,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n\r\n    return newNode;\r\n  }\r\n}\r\n\r\n// Parse function calls\r\n// Limitation: Functions are allowed to take exactly one argument\r\nexport class FunctionParselet implements InitialParselet {\r\n  \r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    tokens.expectToken('(');\r\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    let args = [arg1];\r\n    if (token.text == \"ParseOrderedPair\") {\r\n      const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for second argument\r\n      args.push(arg2);\r\n    }\r\n    tokens.expectToken(')');\r\n    let newNode = {\r\n      nodeType: 'Function' as 'Function',\r\n      name: token.text,\r\n      args: args,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class ChooseParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n\r\n    const predicate = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    const consequent = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    tokens.expectToken('CHOOSE2');\r\n    const otherwise = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n\r\n    let newNode = {\r\n      nodeType: 'Choose' as 'Choose',\r\n      case: { predicate: predicate, consequent: consequent },\r\n      otherwise: otherwise,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class VariableAssignmentParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    \r\n    // deal with variable assignment\r\n    tokens.expectToken('=');\r\n    const assignment = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n\r\n\r\n    // need to save the variable and its assignment in a lookup table\r\n    varMap[token.text] = id;\r\n    let newNode = {\r\n      nodeType: 'VariableAssignment' as 'VariableAssignment',\r\n      name: token.text,\r\n      assignment: assignment,\r\n      outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                    valueType: assignment?.outputType?.valueType },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    dependsMap[id] = findBases(assignment, dependsMap); // NEW FUNCTION HERE\r\n\r\n \r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class IdentifierParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n    \r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // need to look up known variables in a lookup table (map?)\r\n\r\n    const assignmentId = varMap[token.text];\r\n\r\n    if (!assignmentId) {\r\n      const varParselet = new VariableAssignmentParselet();\r\n      return varParselet.parse(parser, tokens, token, varMap, registeredNodes, dependsMap);\r\n    }\r\n    else {\r\n      let newNode = {\r\n        nodeType: 'Identifier' as 'Identifier',\r\n        name: token.text,\r\n        assignmentId: assignmentId,\r\n        outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                      valueType: undefined },\r\n        pos: position,\r\n        nodeId: id\r\n      };\r\n      registeredNodes[id] = newNode;\r\n      return newNode;\r\n    }\r\n  }\r\n}\r\n","import {StringStream} from \"@codemirror/stream-parser\"\r\n\r\nexport function getTokens(text: string): Token[] {\r\n  const tokens: Token[] = [];\r\n  const state: State = {line: 1, stack: ['default']};\r\n\r\n  for (const line of text.split('\\n')) {\r\n    const stream = new StringStream();\r\n    stream.string = line;\r\n    while (!stream.eol()) {\r\n      const token = getToken(stream, state);\r\n      const emitToken = makeEmit(stream, state);\r\n      const fullToken = emitToken(token as TokenType);\r\n      if (token != undefined) {\r\n        tokens.push(fullToken);\r\n      }\r\n\r\n      if (stream.start == stream.pos) {\r\n        throw new Error(\r\n          `getToken failed to advance stream at position ${\r\n            stream.pos\r\n          } in string ${stream.string}`,\r\n        );\r\n      }\r\n      stream.start = stream.pos;\r\n    }\r\n\r\n    state.line += 1;\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\nexport function getToken(\r\n  stream: StringStream,\r\n  state: State,\r\n): string | undefined {\r\n  //Built for codeMirror streams API\r\n  //State is a stack of states\r\n  switch (state.stack[state.stack.length - 1]) {\r\n    default:\r\n      return getDefaultToken(stream, state);\r\n  }\r\n}\r\n\r\nfunction makeEmit(stream: StringStream, state: State) {\r\n  return function emitToken(type: TokenType): Token {\r\n    return {\r\n      type,\r\n      first_column: stream.start,\r\n      last_column: stream.pos,\r\n      line: state.line,\r\n      text: stream.current(),\r\n    };\r\n  };\r\n}\r\n\r\nexport function getDefaultToken(\r\n  stream: StringStream,\r\n  state: State,\r\n): string | undefined {\r\n  // const emitToken = makeEmit(stream, state);\r\n  if (stream.eatSpace()) {\r\n    // skip whitespace\r\n    return undefined;\r\n  }\r\n\r\n  if (stream.match(/\\+/)) {\r\n    return '+';\r\n  }\r\n\r\n  if (stream.match(/\\-/)) {\r\n    return '-';\r\n  }\r\n\r\n  if (stream.match(/\\*/)) {\r\n    return '*';\r\n  }\r\n\r\n  if (stream.match(/\\//)) {\r\n    return '/';\r\n  }\r\n\r\n  if (stream.match(/\\|/)) {\r\n    return '|';\r\n  }\r\n\r\n  if (stream.match(/\\&/)) {\r\n    return '&';\r\n  }\r\n\r\n  if (stream.match(/\\(/)) {\r\n    return '(';\r\n  }\r\n\r\n  if (stream.match(/\\)/)) {\r\n    return ')';\r\n  }\r\n\r\n  if (stream.match(/\\[/)) {\r\n    return '[';\r\n  }\r\n\r\n  if (stream.match(/\\]/)) {\r\n    return ']';\r\n  }\r\n\r\n  // adding an equals operator\r\n  if (stream.match(/\\=/)) {\r\n    return '=';\r\n  }\r\n\r\n  if (stream.match(/-?[0-9]+(\\.[0-9]+)?/)) {\r\n    return 'NUMBER';\r\n  }\r\n\r\n  if (stream.match(/True/)) {\r\n    return 'TRUE';\r\n  }\r\n\r\n  if (stream.match(/False/)) {\r\n    return 'FALSE';\r\n  }\r\n\r\n  if (stream.match(/#/)) {\r\n    if (!stream.match(/\\n/)) {\r\n      // comment lasts till end of line\r\n      stream.match(/.*/); // if no eol encountered, comment lasts till end of file\r\n    }\r\n    return 'COMMENT';\r\n  }\r\n\r\n  // hardcode when to be a choose node not an identifier to get around parsing\r\n  if (stream.match(/WHEN/)) {\r\n    return 'CHOOSE1';\r\n  }\r\n\r\n  // Remove otherwise clause for now\r\n  if (stream.match(/OTHERWISE/)) {\r\n    return 'CHOOSE2';\r\n  }\r\n\r\n  if (stream.match(/[A-Z]([a-z|A-Z])*/)) {\r\n    return 'FUNCTION';\r\n  }\r\n\r\n  // Identifiers\r\n  // For now, the form of a valid identifier is: a lower-case alphabetic character,\r\n  // followed by zero or more alpha characters.\r\n  if (stream.match(/[a-z]([a-z|A-Z])*/)) {\r\n    return 'IDENTIFIER';\r\n  }\r\n  \r\n\r\n  stream.next();\r\n  return 'ERROR';\r\n}\r\n\r\nexport type BinaryOperationTokenType =\r\n  | '+'\r\n  | '-'\r\n  | '*'\r\n  | '/'\r\n  | '|' // this is an or\r\n  | '&' // this is an and\r\n\r\nexport type TokenType =\r\n  | BinaryOperationTokenType\r\n  | 'NUM'\r\n  | 'TRUE'\r\n  | 'FALSE'\r\n  | '('\r\n  | ')'\r\n  | 'COMMENT'\r\n  | 'ERROR'\r\n  | 'FUNCTION'\r\n  | 'IDENTIFIER'\r\n  | 'CHOOSE1'\r\n  | 'CHOOSE2'\r\n  | '='\r\n  | 'RANGE'\r\n  | '['\r\n  | ']'\r\n\r\nexport interface Token<T extends TokenType = TokenType> {\r\n  type: T;\r\n  text: string;\r\n  line: number;\r\n  first_column: number;\r\n  last_column: number;\r\n}\r\n\r\ntype Mode = 'default';\r\n\r\nexport interface State {\r\n  stack: Mode[];\r\n  line: number;\r\n}\r\n","import {Token, TokenType, getTokens} from './lexer';\r\nimport {ParseError, token2pos} from './position';\r\n\r\nexport class TokenStream {\r\n  tokens: Token[];\r\n  pos: number = 0;\r\n\r\n  constructor(text: string) {\r\n    this.tokens = getTokens(text).filter(t => t.type != 'COMMENT');\r\n  }\r\n\r\n  consume(): Token | undefined {\r\n    const token = this.tokens[this.pos];\r\n    if (token) {\r\n      this.pos += 1;\r\n    }\r\n    return token;\r\n  }\r\n\r\n  peek(): Token | undefined {\r\n    return this.tokens[this.pos];\r\n  }\r\n\r\n  last(): Token {\r\n    return this.tokens[this.pos - 1];\r\n  }\r\n\r\n  expectToken<T extends TokenType>(expectedType: T): Token<T> {\r\n    const actual = this.consume();\r\n\r\n    if (!actual) {\r\n      throw new ParseError(\r\n        `Expected \"${expectedType}\" token but found none.`,\r\n        token2pos(this.last()),\r\n      );\r\n    }\r\n\r\n    if (actual.type != expectedType) {\r\n      throw new ParseError(\r\n        `Expected \"${expectedType}\" token type but found \"${actual.type}\".`,\r\n        token2pos(actual),\r\n      );\r\n    }\r\n\r\n    return actual as Token<T>;\r\n  }\r\n}\r\n","import * as Parselet from './parselet';\r\nimport {Token, TokenType} from './lexer';\r\nimport {TokenStream} from './tokenstream';\r\nimport {ParseError, token2pos} from './position';\r\nimport * as AST from './ast';\r\n\r\nexport function parse(text: string,\r\n                      varMap: {[key: string]: string},\r\n                      registeredNodes: {[key: string]: AST.Node},\r\n                      dependsMap: {[key: string]: string[]}): \r\n                      {nodes: AST.Node[]; errors: ParseError[]} {\r\n  const nodes: AST.Node[] = [];\r\n\r\n  const tokens = new TokenStream(text);\r\n  const parser = new Parser();\r\n  while (tokens.peek()) {\r\n    try {\r\n      nodes.push(parser.parse(tokens, 0, varMap, registeredNodes, dependsMap));\r\n    } catch (e) {\r\n      return {\r\n        nodes,\r\n        errors: [e],\r\n      };\r\n    }\r\n  }\r\n\r\n  return {nodes, errors: []};\r\n}\r\n\r\nexport abstract class AbstractParser {\r\n  public bindingPowers: {[tokenType in TokenType]: number};\r\n\r\n  protected abstract initialMap(): Partial<\r\n    {[K in TokenType]: Parselet.InitialParselet}\r\n  >;\r\n  protected abstract consequentMap(): Partial<\r\n    {[K in TokenType]: Parselet.ConsequentParselet}\r\n  >;\r\n  protected abstract bindingClasses(): TokenType[][];\r\n\r\n  constructor() {\r\n    this.bindingPowers = {} as any;\r\n\r\n    const bindingClasses = this.bindingClasses();\r\n    for (let i = 0; i < bindingClasses.length; i++) {\r\n      for (const tokenType of bindingClasses[i]) {\r\n        this.bindingPowers[tokenType] = 10 * i + 9;\r\n      }\r\n    }\r\n\r\n    for (const tokenType of Object.keys(this.consequentMap) as TokenType[]) {\r\n      if (this.bindingPowers[tokenType] == undefined) {\r\n        throw new Error(\r\n          `Token ${tokenType} defined in consequentMap has no associated binding power.\r\n          Make sure it is also listed in bindingClasses.`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  bindingPower(token: Token): number {\r\n    if (this.bindingPowers[token.type] != undefined) {\r\n      return this.bindingPowers[token.type];\r\n    } else {\r\n      throw new ParseError(\r\n        `Unexpected token type ${token.type}.`,\r\n        token2pos(token),\r\n      );\r\n    }\r\n  }\r\n\r\n  parse(tokens: TokenStream,\r\n        currentBindingPower: number,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}): AST.Node {\r\n    const token = tokens.consume();\r\n    if (!token) {\r\n      throw new ParseError(\r\n        `Unexpected end of tokens.`,\r\n        token2pos(tokens.last()),\r\n      );\r\n    }\r\n\r\n    const initialParselet = this.initialMap()[token.type];\r\n\r\n    if (!initialParselet) {\r\n      throw new ParseError(\r\n        `Unexpected token type ${token.type}`,\r\n        token2pos(token),\r\n      );\r\n    }\r\n\r\n    let left = initialParselet.parse(this, tokens, token, varMap, registeredNodes, dependsMap);\r\n\r\n    while (true) {\r\n      const next = tokens.peek();\r\n      if (!next) {\r\n        break;\r\n      }\r\n\r\n      const consequentParselet = this.consequentMap()[next.type];\r\n\r\n      if (!consequentParselet) {\r\n        break;\r\n      }\r\n\r\n      if (currentBindingPower >= this.bindingPower(next)) {\r\n        break;\r\n      }\r\n\r\n      tokens.consume();\r\n      left = consequentParselet.parse(this, tokens, left, next, varMap, registeredNodes, dependsMap);\r\n    }\r\n\r\n    return left;\r\n  }\r\n}\r\n\r\nexport class Parser extends AbstractParser {\r\n  initialMap() {\r\n    return {\r\n      NUMBER: new Parselet.NumberParselet(),\r\n      TRUE: new Parselet.BooleanParselet(true),\r\n      FALSE: new Parselet.BooleanParselet(false),\r\n      '(': new Parselet.ParenParselet(),\r\n      '[': new Parselet.BracketParselet(),\r\n      FUNCTION: new Parselet.FunctionParselet(),\r\n      CHOOSE1: new Parselet.ChooseParselet(),\r\n      IDENTIFIER: new Parselet.IdentifierParselet()\r\n    };\r\n  }\r\n\r\n  consequentMap() {\r\n    return {\r\n      '+': new Parselet.BinaryOperatorParselet('+', 'left'),\r\n      '-': new Parselet.BinaryOperatorParselet('-', 'left'),\r\n      '*': new Parselet.BinaryOperatorParselet('*', 'left'),\r\n      '/': new Parselet.BinaryOperatorParselet('/', 'left'),\r\n      '|': new Parselet.BinaryOperatorParselet('|', 'right'),\r\n      '&': new Parselet.BinaryOperatorParselet('&', 'right')\r\n    };\r\n  }\r\n\r\n  bindingClasses() {\r\n    const classes: TokenType[][] = [['+', '-'], ['*', '/'], ['|', '&']];\r\n    return classes;\r\n  }\r\n}\r\n","import {StateField} from \"@codemirror/state\"\r\nimport {Transaction} from \"@codemirror/state\"\r\nimport * as AST from './ast';\r\nimport {parse} from './parser';\r\nimport {ParseError} from './position';\r\n\r\n/**\r\n * A State field that holds the results of parsing\r\n */\r\nexport const parseResults: StateField<ParseResults> = StateField.define({\r\n  create() { return emptyParseResults },\r\n  update(value, tr) { return tr.docChanged ? parseProgram(tr) : value }\r\n})\r\n\r\n/**\r\n * Parse the program created from a transaction, returning a ParseResults object\r\n */\r\nfunction parseProgram(tr: Transaction) : ParseResults {\r\n  const contents = tr.state.doc.toString()\r\n\r\n  let varMap: {[key: string]: string} = {}\r\n  let registeredNodes: {[key: string]: AST.Node} = {}\r\n  let dependsMap: {[key: string]: string[]} = {}\r\n  const ast = parse(contents, varMap, registeredNodes, dependsMap)\r\n\r\n  return {\r\n    nodes: ast.nodes,\r\n    parseErrors: ast.errors,\r\n    varMap: varMap,\r\n    registeredNodes: registeredNodes,\r\n    dependsMap: dependsMap\r\n  }\r\n}\r\n\r\n/**\r\n * Type that describes the results of parsing\r\n */\r\nexport type ParseResults = {\r\n  nodes: AST.Node[];\r\n  parseErrors: ParseError[];\r\n  varMap: {[key: string]: string};\r\n  registeredNodes: {[key: string]: AST.Node};\r\n  dependsMap: {[key: string]: string[]};\r\n}\r\n\r\n/**\r\n * Can be used as the initial results of parsing\r\n */\r\nconst emptyParseResults: ParseResults = {\r\n  nodes: [],\r\n  parseErrors: [],\r\n  varMap: {},\r\n  registeredNodes: {},\r\n  dependsMap: {}\r\n}\r\n","import {Position} from './position';\r\nimport * as AST from './ast';\r\nimport {equals} from './equals';\r\n\r\n/***** ITERATION: change all outputType.valueType to simply outputType *****/\r\n\r\nexport function typecheck(nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n  const errors = nodes.map(n => typecheckNode(n, registeredNodes));\r\n  return ([] as TypeError[]).concat(...errors);\r\n}\r\n\r\nfunction typecheckNode(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n  return checkerMap[node.nodeType].check(node, registeredNodes);\r\n}\r\n\r\nexport class TypeError {\r\n  constructor(public message: string, public position: Position) {}\r\n}\r\n\r\nexport interface TypeChecker {\r\n  check(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[];\r\n}\r\n\r\nclass CheckNumber implements TypeChecker {\r\n  check(node: AST.NumberNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\nclass CheckBoolean implements TypeChecker {\r\n  check(node: AST.BooleanNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\nclass CheckBinary implements TypeChecker {\r\n  check(node: AST.BinaryOperationNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    const errors: TypeError[] = typecheckNode(node.left, registeredNodes).concat(typecheckNode(node.right, registeredNodes));\r\n    \r\n    // Check if same operand type (both numbers, both booleans)\r\n    if (node.left?.outputType?.valueType != node.right?.outputType?.valueType) {\r\n      errors.push(new TypeError(\"incompatible types for binary operator\", node.pos));\r\n    }\r\n    // Check if incorrect combination of operator and operands\r\n    else if (node.right?.outputType?.valueType == 'boolean' && (node.operator != \"|\" && node.operator != '&')) {\r\n      errors.push(new TypeError(\"incompatible operation for boolean operands\", node.pos));\r\n    }\r\n    else if (node.right?.outputType?.valueType == 'number' && (node.operator == \"|\" || node.operator == '&')) {\r\n      errors.push(new TypeError(\"incompatible operation for number operands\", node.pos));\r\n    }\r\n\r\n    node.outputType!.valueType = node.left?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckFunction implements TypeChecker {\r\n  check(node: AST.FunctionNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    // First typecheck the argument\r\n    const arg1Errors = typecheckNode(node.args[0], registeredNodes);\r\n    errors = errors.concat(arg1Errors);\r\n    if (node.args.length > 1) {\r\n      const arg2Errors = typecheckNode(node.args[1], registeredNodes);\r\n      errors = errors.concat(arg2Errors);\r\n      if (node.args[0]?.outputType?.valueType != node.args[1]?.outputType?.valueType) {\r\n        errors.push(new TypeError(\"arguments must have same type\", node.args[0].pos));\r\n      }\r\n    }\r\n\r\n    const functionName = node.name\r\n    const argType = builtins[functionName].inputType;\r\n\r\n    // we found a builtin function\r\n    if (argType) {\r\n\r\n      // typecheck the argument\r\n      // Assume both arguments are the same type (see error produced above)\r\n      if (argType != 'any' && node.args[0]?.outputType?.valueType != argType) {\r\n        errors.push(new TypeError(\"incompatible argument type for \" + functionName, node.pos));\r\n      }\r\n    }\r\n  \r\n    // this is not a known, builtin function\r\n    else {\r\n      errors.push(new TypeError(\"unknown function\", node.pos));\r\n    }    \r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckChoose implements TypeChecker {\r\n  check(node: AST.ChooseNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    const predicate = node.case.predicate;\r\n    const consequent = node.case.consequent;\r\n    const otherwise = node.otherwise;\r\n\r\n    // First typecheck the inner nodes\r\n    const predErrors = typecheckNode(predicate, registeredNodes);\r\n    const consErrors = typecheckNode(consequent, registeredNodes);\r\n    const otherErrors = typecheckNode(otherwise, registeredNodes);\r\n    errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\r\n\r\n    // check return types are the same for both cases\r\n    if (consequent?.outputType?.valueType != otherwise?.outputType?.valueType) {\r\n      errors.push(new TypeError(\"Return types are not the same for both cases\", consequent.pos));\r\n      errors.push(new TypeError(\"Return types are not the same for both cases\", otherwise.pos));\r\n    }\r\n\r\n    // check that the predicate returns a boolean\r\n    if (predicate.outputType.valueType != 'boolean') {\r\n      errors.push(new TypeError(\"Predicate must return a boolean\", predicate.pos));\r\n    }\r\n\r\n    node.outputType.valueType = consequent?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckVariable implements TypeChecker {\r\n  check(node: AST.VariableAssignmentNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n    // First typecheck the assignment node\r\n    const assignmentErrors = typecheckNode(node.assignment, registeredNodes);\r\n    errors = errors.concat(assignmentErrors);\r\n\r\n    node.outputType.valueType = node.assignment?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckIdentifier implements TypeChecker {\r\n  check(node: AST.IdentifierNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    // Maybe make assigmentId be valueId?\r\n    let valueNode = registeredNodes[node.assignmentId].assignment;\r\n\r\n    // If this assignmentId is not found in the AST, throw an error\r\n    if (valueNode == undefined) {\r\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\r\n    }\r\n\r\n    node.outputType.valueType = valueNode.outputType.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckIterator implements TypeChecker {\r\n  check(node: AST.IteratorNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\n// Dictionary of builtin functions that maps a function name to the type of its argument\r\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType} } = {\r\n  \"IsDefined\": {inputType: 'any', resultType: 'boolean'},\r\n  \"Inverse\": {inputType: 'number', resultType: 'number'},\r\n  \"Input\": {inputType: 'number', resultType: 'number'},\r\n  \"Sink\": {inputType: 'any', resultType: 'any'},\r\n  \"RandomChoice\": {inputType: 'number', resultType: 'number'},\r\n  \"TestConstant\": {inputType: 'any', resultType: 'any'},\r\n  \"ParseOrderedPair\": {inputType: 'number', resultType: 'pair'},\r\n  \"X\": {inputType: 'pair', resultType: 'number'},\r\n  \"Y\": {inputType: 'pair', resultType: 'number'}\r\n}\r\n\r\nconst checkerMap: Partial<{[K in AST.NodeType]: TypeChecker}> = {\r\n  'Number' : new CheckNumber(),\r\n  'Boolean' : new CheckBoolean(),\r\n  'BinaryOperation' : new CheckBinary(),\r\n  'Function' : new CheckFunction(),\r\n  'Choose': new CheckChoose(),\r\n  'VariableAssignment': new CheckVariable(),\r\n  'Identifier': new CheckIdentifier(),\r\n  'Iterator': new CheckIterator(),\r\n}","import {Position} from './position';\r\nimport * as AST from './ast';\r\nimport {equals} from './equals';\r\n\r\n\r\n\r\n\r\n\r\nexport function darCheck(nodes: AST.Node[],  registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    const errors = nodes.map(n => darCheckNode(n, nodes, registeredNodes));\r\n    return ([] as TypeError[]).concat(...errors);\r\n}\r\n\r\nfunction darCheckNode(node: AST.Node, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    if (darCheckerMap != undefined && node.nodeType != undefined && darCheckerMap[node.nodeType] == undefined){\r\n        return [];\r\n    }else{\r\n        return darCheckerMap[node.nodeType].darCheck(node, nodes, registeredNodes);\r\n    }\r\n}\r\n\r\nexport class TypeError {\r\n    constructor(public message: string, public position: Position) {}\r\n  }\r\n\r\nexport interface DarChecker {\r\n\r\n    darCheck(node: AST.Node,\r\n            nodes: AST.Node[], \r\n            registeredNodes: {[key: string]: AST.Node},): TypeError[];\r\n  }\r\n\r\nclass DarCheckNumber implements DarChecker {\r\n    darCheck(node: AST.NumberNode): TypeError[] {\r\n\r\n        //set the value in the outputType\r\n        node.outputType.value = node.value;\r\n        return [];\r\n    }\r\n  }\r\n\r\n\r\n  class DarCheckFunction implements DarChecker{\r\n      darCheck(node: AST.FunctionNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}) : TypeError[]{\r\n        const errors: TypeError[] = [];\r\n        \r\n        if (node.name == \"TestConstant\"){\r\n            //do our test constant demo\r\n\r\n            //pre-check the arg (to assign value)\r\n            darCheckNode(node.args[0], nodes, registeredNodes)\r\n\r\n            //check if the argument has a value\r\n            if (node?.args[0]?.outputType?.value == undefined){\r\n                errors.push(new TypeError(\"Input to TestConstant() is not constant\", node.pos));\r\n            }\r\n\r\n        }\r\n        return errors;\r\n      }\r\n  }\r\n\r\nclass DarCheckBinary implements DarChecker {\r\n\r\n\r\n    evaluateOperation(left : number, right : number, operator : string): number | undefined {\r\n\r\n        //check to make sure left & right are numbers\r\n        if (typeof(left) == 'number' && typeof(right) == 'number' ){\r\n            if (operator == \"+\"){\r\n                return left + right\r\n            } else if (operator == \"-\"){\r\n                return left - right\r\n            } else if (operator == \"*\"){\r\n                return left * right\r\n            } else if (operator ==\"/\"){\r\n                return left / right\r\n            } else {\r\n                return 999999\r\n            }\r\n        } else {\r\n            //one or both sides is a non-number. We only care about numbers\r\n            return undefined\r\n        }\r\n    }\r\n\r\n    darCheck(node: AST.BinaryOperationNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n        const errors: TypeError[] = darCheckNode(node.left, nodes, registeredNodes).concat(darCheckNode(node.right, nodes, registeredNodes));\r\n        \r\n        //check if outputType of both left and right is constant\r\n        if (node.left?.outputType?.value != undefined && node.right?.outputType?.value != undefined){\r\n            \r\n            //evaluate the operation and set the value\r\n            node.outputType = {\r\n                status : node.outputType!.status,\r\n                valueType: node.left?.outputType?.valueType,\r\n                value: this.evaluateOperation(node.left?.outputType.value, node.right?.outputType.value, node.operator) \r\n            }\r\n            \r\n   \r\n        } else{\r\n            //One or both of the left + right does NOT have a value\r\n            console.log(\"One or both sides has no 'value'\");\r\n        }\r\n   \r\n        return errors;\r\n    }\r\n}\r\n\r\nclass DarCheckVariable implements DarChecker {\r\n    darCheck(node: AST.VariableAssignmentNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n\r\n\r\n        //check the assignment (and propagate value, if applicable)\r\n        darCheckNode(node.assignment, nodes, registeredNodes);\r\n\r\n        //does the assignment node have a value\r\n        if (node.assignment?.outputType?.value != undefined){\r\n            //set value of this node to the value of the assignment\r\n            node.outputType.value = node.assignment.outputType.value;\r\n        }\r\n\r\n        return [];\r\n    }\r\n}\r\n\r\nclass DarCheckIdentifier implements DarChecker {\r\n    darCheck(node: AST.IdentifierNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n\r\n        //grab the assignment node that this ident refrences\r\n        const assignmentNode = registeredNodes[node.assignmentId];\r\n\r\n        if (assignmentNode?.outputType?.value != undefined){\r\n            //set value of this node to the value of the assignment\r\n            node.outputType.value = assignmentNode.outputType.value;\r\n        }\r\n\r\n        return [];\r\n    }\r\n  }\r\n\r\n  class DarCheckIterator implements DarChecker {\r\n\r\n    getRange(start: number, end: number, step: number): number[]{\r\n        let current = start;\r\n        let out = [];\r\n        while (current < end){\r\n            out.push(current);\r\n            current += step;\r\n        }\r\n        return out;\r\n    }\r\n    darCheck(node: AST.IteratorNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n        const errors: TypeError[] = [];\r\n\r\n        //pre-check nodes\r\n        darCheckNode(node.start, nodes, registeredNodes);\r\n        darCheckNode(node.end, nodes, registeredNodes);\r\n        darCheckNode(node.step, nodes, registeredNodes);\r\n\r\n\r\n        //calculate range\r\n\r\n        if (node.start?.outputType?.value != undefined && node.end?.outputType?.value != undefined && node.step?.outputType?.value != undefined){\r\n            //if start, end, and step all are constant numbers\r\n\r\n            const start = node.start?.outputType?.value;\r\n            const end = node.end?.outputType?.value;\r\n            const step = node.step?.outputType?.value;\r\n\r\n            console.log(\"start, end, step:\", start, end, step);\r\n\r\n            node.values = this.getRange(start, end, step);\r\n        } else {\r\n            console.log(\"Iterator used with non constant stuff\")\r\n            errors.push(new TypeError(\"Non constant value used in iterator decleration\", node.pos));\r\n        }\r\n\r\n\r\n        return errors;\r\n    }\r\n  }\r\n\r\n\r\n\r\nconst darCheckerMap: Partial<{[K in AST.NodeType]: DarChecker}> = {\r\n'Number' : new DarCheckNumber(),\r\n//'Boolean' : new CheckBoolean(),\r\n'BinaryOperation' : new DarCheckBinary(),\r\n'Function' : new DarCheckFunction(),\r\n//'Choose': new CheckChoose(),\r\n'VariableAssignment': new DarCheckVariable(),\r\n'Identifier': new DarCheckIdentifier(),\r\n'Iterator': new DarCheckIterator(),\r\n}","import {StreamParser, StringStream} from \"@codemirror/stream-parser\"\r\nimport {Diagnostic} from \"@codemirror/lint\"\r\nimport {EditorView} from \"@codemirror/view\"\r\nimport {State, getDefaultToken} from './lexer'\r\nimport {ParseError} from './position'\r\nimport {typecheck} from './typechecker';\r\n//import {mudCheck} from './mudChecker';\r\nimport {darCheck} from './darChecker';\r\nimport {parseResults} from './parseResults';\r\n\r\n/**\r\n * The extension for our language\r\n */\r\nexport const miniCL: StreamParser<State> = {\r\n  startState: function (): State {\r\n    return {line: 1, stack: ['default']};\r\n  },\r\n  token: function (stream: StringStream, state: State): string | undefined {\r\n    if (stream.eatSpace()) return null;\r\n    return token2tag(getDefaultToken(stream, state));\r\n  }\r\n};\r\n\r\n/**\r\n * The linter for our language\r\n */\r\n export const miniCLLinter = () => (view: EditorView): Diagnostic[] => {\r\n\r\n  // Get the result types\r\n  const results = view.state.field(parseResults);\r\n\r\n  // Error checking\r\n  let assertMap: string[] = [];\r\n  //const mudErrors = mudCheck(results.nodes, results.registeredNodes, results.dependsMap, assertMap);\r\n  const darErrors = darCheck(results.nodes, results.registeredNodes);\r\n  const typeErrors = typecheck(results.nodes, results.registeredNodes);\r\n  \r\n\r\n  // Create a diagnostic for each kind of error\r\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\r\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\r\n  //const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\r\n  const darDiagnostics = darErrors.map(makeDiagnostic(view, 'warning'));\r\n\r\n  return parseDiagnostics.concat(typeDiagnostics).concat(darDiagnostics);\r\n}\r\n\r\n/**\r\n * Create a diagnostic from an error\r\n */\r\nconst makeDiagnostic = (view: EditorView, severity: 'error' | 'info' | 'warning' = 'error') => \r\n  (error): Diagnostic => {\r\n    return {\r\n      from: firstLine(view, error) + error.position.first_column,\r\n      to: lastLine(view, error) + error.position.last_column,\r\n      message: error.message,\r\n      severity: severity\r\n    }\r\n}\r\n\r\n/**\r\n * @returns the line number for the start of the error\r\n */\r\nfunction firstLine(view: EditorView, error: ParseError) {\r\n  return view.state.doc.line(error.position.first_line).from;\r\n}\r\n\r\n/**\r\n * @returns the line number for the end of the error\r\n */\r\nfunction lastLine (view: EditorView, error: ParseError) {\r\n  return view.state.doc.line(error.position.last_line).from;    \r\n}\r\n\r\n/**\r\n * Convert our bespoke parser Token type to a token type that is recognized by CodeMirror\r\n */\r\nfunction token2tag(token: string): string | undefined {\r\n  switch (token) {\r\n    case 'NUMBER':\r\n      return 'number';\r\n\r\n    case 'TRUE':\r\n      return 'boolean';\r\n\r\n    case 'FALSE':\r\n      return 'boolean';\r\n\r\n    case '(':\r\n    case ')':\r\n      return 'bracket';\r\n\r\n    case '+':\r\n    case '-':\r\n    case '*':\r\n    case '/':\r\n    case '|':\r\n    case '&':\r\n    case '=':\r\n      return 'operator';\r\n\r\n    case 'COMMENT':\r\n      return 'comment';\r\n\r\n    case 'CHOOSE1':\r\n    case 'CHOOSE2':\r\n      return 'choose';\r\n\r\n    case 'FUNCTION':\r\n      return 'function';\r\n\r\n    case 'IDENTIFIER':\r\n      return 'variable';\r\n\r\n    case 'ERROR':\r\n      return 'error';\r\n\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n","import * as d3Hierarchy from 'd3-hierarchy';\r\nimport * as d3Select from 'd3-selection';\r\nimport * as d3shape from 'd3-shape';\r\nimport * as AST from './ast';\r\n\r\nexport function visualize(nodes: AST.Node[]): void {\r\n\r\n    // Placement and size of tree\r\n    const margin = {top: 20, right: 90, bottom: 20, left: 90};\r\n    const height = 300 - margin.top - margin.bottom;\r\n    const width  = 500 - margin.left - margin.right;\r\n  \r\n    // Make the svg\r\n    d3Select.select('#viz').selectAll('svg').remove();\r\n    const viz = d3Select.select('#viz').append('svg');\r\n  \r\n    // Remove existing visualizations\r\n    viz.selectAll('*').remove();\r\n  \r\n    // Add a new visualization\r\n    viz.attr('width', width + margin.left + margin.right)\r\n       .attr('height', height + margin.top + margin.bottom);\r\n\r\n    const root: Node = {nodeType: 'Program', children: nodes}\r\n\r\n    // Visualize all the statements\r\n    // for (var statement of nodes) {\r\n\r\n      // Create the tree and layout\r\n      const treemap = d3Hierarchy.tree()\r\n        .size([height, width])\r\n        .separation(() => 1);\r\n      const treelayout = d3Hierarchy.hierarchy(root, getChildren);\r\n      const tree = treemap(treelayout);\r\n  \r\n      // Add a new graph element for this statement\r\n      const g = viz.append('g')\r\n                  //  .attr(\"transform\", `translate(${root.dy / 3},${root.dx - x0})`);\r\n                   .attr('transform', `translate(${margin.left}, ${margin.top})`)\r\n                   .attr(\"font-family\", \"sans-serif\")\r\n                   .attr(\"font-size\", 12)\r\n               \r\n      // Edge updates\r\n      const link = g.selectAll('path.link').data(tree.links());\r\n\r\n      // Edge entry\r\n      const linkEnter = link.enter().append('path', 'g');\r\n        \r\n      // general edge attributes\r\n      linkEnter.attr('class', 'link')\r\n               .attr('fill', 'none')\r\n               .attr(\"stroke-opacity\", 0.4)\r\n               .attr('stroke', '#555')\r\n               .attr(\"stroke-width\", 1.5)\r\n               .attr('d', connection);\r\n\r\n        \r\n      // Node updates\r\n      const node = g.selectAll('g.node').data(tree.descendants());\r\n\r\n      // Node entry\r\n      const nodeEnter = node.enter().append('g');\r\n\r\n      // general node attributes\r\n      nodeEnter.attr('class', 'node')\r\n               .attr('transform', d => `translate(${d.y}, ${d.x})`);\r\n\r\n      nodeEnter.append('circle')\r\n               .attr(\"fill\", getFill)\r\n               .attr('r', '2.5')\r\n               .attr('stroke-width', 10);\r\n\r\n      // add text\r\n      nodeEnter.append('text')\r\n                // .attr('dy', '-10px')\r\n                .attr(\"dy\", \"0.31em\")\r\n                .attr(\"x\", d => d.children ? -8 : 8)\r\n                .attr(\"text-anchor\", d => d.children ? \"end\" : \"start\")\r\n                .attr('fill', d => isUndefined(d) ? '#fc6666' : 'black')\r\n                .style(\"fill-opacity\", 1)\r\n                .call(getTextBox)\r\n                .datum(d => d.data)\r\n                .text(getText)\r\n          .clone(true).lower()\r\n            .attr(\"stroke\", \"white\");\r\n    \r\n      // Highlight undefined -- not working\r\n      // Inspired in part by https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\r\n      nodeEnter.filter((d,i) => isUndefined(d))\r\n        .call(yep)\r\n        .insert('rect', 'text')\r\n        .attr(\"x\", function(d){return d.bbox.x})\r\n        .attr(\"y\", function(d){return d.bbox.y})\r\n        .attr(\"width\", function(d){return d.bbox.width})\r\n        .attr(\"height\", function(d){return d.bbox.height}) \r\n        .attr('fill', 'black')             \r\n    // }\r\n}\r\n\r\n// From https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\r\nfunction getTextBox(selection) {\r\n  selection.each(function(d){d.bbox = this.getBBox();})\r\n}\r\n\r\nfunction yep(selection) {\r\n  // console.log(selection.nodes().map((d)=>d.bbox));\r\n}\r\n\r\n\r\nconst connection = d3shape.linkHorizontal().x(d => d.y).y(d => d.x)\r\n\r\nfunction getChildren(node: AST.Node): AST.Node[] {\r\n  var children: AST.Node[] = [];\r\n  switch (node.nodeType) {\r\n    case 'Program':\r\n      children = node.children;\r\n      break;\r\n    case 'Function':\r\n      children = node.args;\r\n      break;\r\n    case 'Choose':\r\n      children = [node.case.predicate, node.case.consequent, node.otherwise];\r\n      break;\r\n    case 'BinaryOperation':\r\n      children = [node.left, node.right];\r\n      break;\r\n    case 'VariableAssignment':\r\n      children = [node.assignment];\r\n      break;\r\n    default:\r\n      children = [];\r\n    }\r\n\r\n  return children;\r\n}\r\n\r\nfunction getText(node) {\r\n  var text = \"\";\r\n  switch (node.nodeType) {\r\n    case 'Program':\r\n      text = '';\r\n      break;\r\n    case 'Function':\r\n      text = node.name;\r\n      break;\r\n    case 'Choose':\r\n      text = \"choose\";\r\n      break;\r\n    case 'BinaryOperation':\r\n      text = node.operator;\r\n      break;\r\n    case 'VariableAssignment':\r\n      text = node.name;\r\n      break;\r\n    case 'Identifier':\r\n      text = node.name;\r\n      break;\r\n    case 'Number':  \r\n      text = node.value.toString();\r\n      break;\r\n    case 'Boolean':\r\n      text = node.value.toString();\r\n      break;\r\n    default:\r\n      text = \"\";\r\n  }\r\n\r\n  return text;\r\n}\r\n\r\nfunction getFill(node): string {\r\n  if (isUndefined(node)) {\r\n    return '#fc6666'\r\n  }\r\n  if (node.children) {\r\n    return '#555'\r\n  } else {\r\n    return '#999'\r\n  }\r\n}\r\n\r\nfunction isUndefined(d) {\r\n  return d.data.outputType?.status === 'Maybe-Undefined'\r\n}","import {Transaction} from \"@codemirror/state\"\r\nimport {json, jsonParseLinter} from \"@codemirror/lang-json\"\r\nimport {foldAll} from \"@codemirror/fold\"\r\nimport { visualize } from \"./visualization\"\r\nimport {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\r\nimport {linter} from \"@codemirror/lint\"\r\nimport { parseResults } from \"./parseResults\"\r\n\r\n/**\r\n * Given a transaction, update the developer tools\r\n */\r\n export function updateDevTools(tr: Transaction) {\r\n  const results = tr.state.field(parseResults)\r\n\r\n  // Display JSON for AST\r\n  const astJSON = JSON.stringify(results.nodes, null, 2)\r\n  replaceContents(astViewer, astJSON);\r\n\r\n  // Display JSON for depends map\r\n  const dependsJSON = JSON.stringify(results.dependsMap, null, 2);\r\n  replaceContents(dependsViewer, dependsJSON);\r\n\r\n  // Draw the AST\r\n  visualize(results.nodes);\r\n}\r\n\r\n// Configuration for a read-only JSON viewer with folding, line numbers, etc.\r\nfunction newJSONViewerState(): EditorState {\r\n  return EditorState.create({\r\n    extensions: [\r\n      basicSetup,\r\n      json(),\r\n      linter(jsonParseLinter()),\r\n      EditorView.editable.of(false),\r\n    ],\r\n  })\r\n}\r\n\r\n// JSON viewer for AST\r\nlet astViewer = new EditorView({\r\n  state: newJSONViewerState(),\r\n  parent: document.querySelector(\"#ast-json\"),\r\n});\r\n\r\n// JSON viewer for depends map\r\nlet dependsViewer = new EditorView({\r\n  state: newJSONViewerState(),\r\n  parent: document.querySelector(\"#depends-json\"),\r\n});\r\n\r\n/**\r\n * Replace the entire contents of an editor\r\n */\r\nfunction replaceContents(editor: EditorView, contents: string) {\r\n  const update = editor.state.update({\r\n    changes: {\r\n      from: 0,\r\n      to: editor.state.doc.length,\r\n      insert: contents\r\n    }\r\n  });\r\n  editor.update([update]);\r\n  foldAll(editor);  // By default, fold all levels\r\n}\r\n","import {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\r\nimport {Transaction} from \"@codemirror/state\"\r\nimport {linter} from \"@codemirror/lint\"\r\nimport {miniCL, miniCLLinter} from \"./miniCL\"\r\nimport {StreamLanguage} from \"@codemirror/stream-parser\"\r\nimport {parseResults} from \"./parseResults\"\r\nimport {updateDevTools} from \"./devTools\"\r\nimport \"./styles.css\"\r\nimport \"./desmos_icons.css\"\r\n\r\n// Create the CodeMirror miniCL editor and add it to the document.\r\nlet miniCLEditor = new EditorView({\r\n  state: EditorState.create({\r\n    extensions: [\r\n      basicSetup,                     // https://codemirror.net/6/docs/ref/#basic-setup\r\n      StreamLanguage.define(miniCL),  // syntax coloring for miniCL\r\n      parseResults,                   // field that holds the results of parsing\r\n      linter(miniCLLinter())          // error-checking for miniCL\r\n    ],\r\n  }),\r\n  dispatch: updateOutput,\r\n  parent: document.querySelector(\"#miniCL-editor\")\r\n})\r\n\r\n// When the content changes, update the editor and the dev tools\r\nfunction updateOutput(tr: Transaction) {\r\n  miniCLEditor.update([tr]);\r\n  updateDevTools(tr);\r\n}\r\n"]}