{"version":3,"sources":["src/position.ts","src/findBase.ts","src/parselet.ts","src/lexer.ts","src/tokenstream.ts","src/parser.ts","src/parseResults.ts","src/typechecker.ts","src/mudChecker.ts","src/miniCL.ts","src/visualization.ts","src/devTools.ts","src/index.ts"],"names":["token","first_line","line","last_line","first_column","last_column","start","end","pos","toString","constructor","message","position","node","dependsMap","baseMap","nodeType","findBase","baseList","leftList","findBases","left","concat","rightList","right","console","log","name","push","nodeId","i","args","length","consBases","case","consequent","otherBases","otherwise","assignmentId","BaseNumber","BaseBoolean","BaseBinary","BaseFunction","BaseChoose","BaseVariableAssignment","BaseIdentifier","parse","_parser","_tokens","varMap","registeredNodes","position_1","id","newNode","value","parseFloat","text","outputType","status","valueType","parser","tokens","_token","exp","expectToken","tokenType","associativity","ConsequentParselet","bindingPower","last","operator","undefined","arg1","arg2","predicate","assignment","findBase_1","varParselet","VariableAssignmentParselet","state","stack","split","stream","stream_parser_1","string","eol","getToken","emitToken","makeEmit","fullToken","Error","getDefaultToken","type","current","eatSpace","match","next","lexer_1","filter","t","consume","peek","expectedType","actual","nodes","tokenstream_1","Parser","e","errors","bindingPowers","bindingClasses","Object","keys","consequentMap","currentBindingPower","initialParselet","initialMap","consequentParselet","AbstractParser","NUMBER","NumberParselet","TRUE","BooleanParselet","FALSE","ParenParselet","FUNCTION","FunctionParselet","CHOOSE1","ChooseParselet","IDENTIFIER","IdentifierParselet","BinaryOperatorParselet","classes","state_1","define","create","emptyParseResults","update","tr","docChanged","parseProgram","contents","doc","ast","parser_1","parseErrors","map","n","typecheckNode","checkerMap","check","TypeError","arg1Errors","arg2Errors","functionName","argType","builtins","inputType","predErrors","consErrors","otherErrors","assignmentErrors","valueNode","resultType","CheckNumber","CheckBoolean","CheckBinary","CheckFunction","CheckChoose","CheckVariable","CheckIdentifier","assertMap","mudCheckNode","mudCheckerMap","mudCheck","returnType","consDef","otherDef","localAsserts","doBinOp","handleAsserts","handleCheck","MudCheckNumber","MudCheckBoolean","MudCheckBinary","MudCheckFunction","MudCheckChoose","MudCheckVariable","MudCheckIdentifier","predBases","k","contained","find","consDefLeft","consDefRight","consDefBoth","temp","temp2","resolveFB","resolveBF","resolveFF","resolveBBO","resolveBOB","resolveFBO","resolveBOF","resolveBOBO","startState","token2tag","view","results","field","parseResults_1","mudErrors","mudChecker_1","typeErrors","typechecker_1","darErrors","darChecker_1","parseDiagnostics","makeDiagnostic","typeDiagnostics","mudDiagnostics","darDiagnostics","severity","error","from","firstLine","to","lastLine","margin","top","bottom","height","width","select","selectAll","remove","viz","append","attr","root","children","treemap","tree","size","separation","treelayout","hierarchy","getChildren","g","link","data","links","linkEnter","enter","connection","descendants","nodeEnter","d","y","x","getFill","isUndefined","style","call","getTextBox","datum","getText","clone","lower","yep","insert","bbox","selection","each","getBBox","linkHorizontal","astJSON","JSON","stringify","replaceContents","astViewer","dependsJSON","dependsViewer","visualization_1","basic_setup_1","extensions","lang_json_1","lint_1","editable","of","newJSONViewerState","parent","document","querySelector","editor","changes","fold_1","miniCLEditor","miniCL_1","dispatch","updateOutput","devTools_1"],"mappings":"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","file":"","sourcesContent":["import { Token } from './lexer';\r\n\r\nexport type Position = {\r\n  first_line: number;\r\n  first_column: number;\r\n  last_line: number;\r\n  last_column: number;\r\n};\r\n\r\nexport function token2pos(token: Token): Position {\r\n  return {\r\n    first_line: token.line,\r\n    last_line: token.line,\r\n    first_column: token.first_column,\r\n    last_column: token.last_column\r\n  }\r\n}\r\n\r\nexport function join(start: Position, end: Position) {\r\n  return {\r\n    first_line: start.first_line,\r\n    last_line: end.last_line,\r\n    first_column: start.first_column,\r\n    last_column: end.last_column\r\n  };\r\n}\r\n\r\nexport function pos2string(pos: Position): string {\r\n  return pos.first_line.toString() + \".\" +\r\n         pos.first_column.toString() + \".\" +\r\n         pos.last_line.toString() + \".\" +\r\n         pos.last_column.toString();\r\n}\r\n\r\n// note, extending Error in the browser is problematic\r\n// https://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node\r\nexport class ParseError {\r\n  constructor(public message: string, public position: Position) {}\r\n}\r\n","import * as AST from './ast';\r\n\r\nexport function findBases(node: AST.Node, dependsMap: {[key: string]: string[]}): string[] {\r\n    return baseMap[node.nodeType].findBase(node, dependsMap); \r\n}\r\n\r\nexport interface BaseFinder {\r\n  findBase(node: AST.Node, dependsMap: {[key: string]: string[]}): string[];\r\n}\r\n\r\nclass BaseNumber implements BaseFinder {\r\n  findBase(node: AST.NumberNode): string[] {\r\n    return []\r\n  }\r\n}\r\n\r\nclass BaseBoolean implements BaseFinder {\r\n    findBase(node: AST.BooleanNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\nclass BaseBinary implements BaseFinder {\r\n    findBase(node: AST.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        let baseList: string[] = [];\r\n        // recursively call findBases on left and right\r\n        let leftList = findBases(node.left, dependsMap);\r\n        baseList = baseList.concat(leftList);\r\n        let rightList = findBases(node.right, dependsMap)\r\n        baseList = baseList.concat(rightList);\r\n        return baseList;\r\n    }\r\n}\r\n\r\n// examples: x = Input(3); x = IsDefined(Input(3)); z = Inverse(x)\r\n// need dependsMap for the third example\r\nclass BaseFunction implements BaseFinder {\r\n    findBase(node: AST.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        console.log(\"in base function\");\r\n        let baseList: string[] = [];\r\n        if (node.name == \"Input\") {\r\n            // this is a base\r\n            baseList.push(node.nodeId);\r\n        }\r\n        else {\r\n            // recursively call findBases on argument(s)\r\n            for (let i = 0; i < node.args.length; i++) {\r\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\r\n            }\r\n        }\r\n        return baseList;\r\n    }\r\n}\r\n\r\n// assume that choose nodes will never create their own bases\r\n// they can still error check previously defined bases\r\nclass BaseChoose implements BaseFinder {\r\n    findBase(node: AST.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        let baseList: string[] = [];\r\n        // the bases of the cons and the otherwise\r\n        let consBases = findBases(node.case.consequent, dependsMap);\r\n        baseList = baseList.concat(consBases);\r\n        let otherBases = findBases(node.otherwise, dependsMap);\r\n        baseList = baseList.concat(otherBases);\r\n        return baseList;\r\n    }\r\n}\r\n\r\nclass BaseVariableAssignment implements BaseFinder {\r\n    findBase(node: AST.VariableAssignmentNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\nclass BaseIdentifier implements BaseFinder {\r\n    findBase(node: AST.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        // follow the chain in the dependsMap\r\n        return dependsMap[node.assignmentId];\r\n    }\r\n}\r\n\r\n\r\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\r\n  'Number' : new BaseNumber(),\r\n  'Boolean' : new BaseBoolean(),\r\n  'BinaryOperation' : new BaseBinary(),\r\n  'Function' : new BaseFunction(),\r\n  'Choose': new BaseChoose(),\r\n  'VariableAssignment': new BaseVariableAssignment(),\r\n  'Identifier': new BaseIdentifier()\r\n}\r\n","import { TokenStream } from './tokenstream';\r\nimport { Token, TokenType, BinaryOperationTokenType} from './lexer';\r\nimport * as AST from './ast';\r\nimport { AbstractParser } from './parser';\r\nimport {ParseError, token2pos, join, pos2string} from './position';\r\nimport {findBases} from './findBase';\r\n\r\nexport interface InitialParselet {\r\n  parse(parser: AbstractParser,\r\n        tokens: TokenStream, token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}): AST.Node;\r\n}\r\n\r\n\r\nexport class NumberParselet implements InitialParselet {\r\n  parse(_parser: AbstractParser,\r\n        _tokens: TokenStream,\r\n        token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // add node to the map\r\n    let newNode = {\r\n      nodeType: 'Number' as 'Number',\r\n      value: parseFloat(token.text),\r\n      outputType: { status: 'Definitely' as 'Definitely',\r\n                    valueType: 'number' as 'number' },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class BooleanParselet implements InitialParselet {\r\n  constructor(private value: boolean) {}\r\n  parse(_parser: AbstractParser,\r\n        _tokens: TokenStream, token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    let newNode = {\r\n      nodeType: 'Boolean' as 'Boolean',\r\n      value: this.value,\r\n      outputType: { status: 'Definitely' as 'Definitely',\r\n                    valueType: 'boolean' as 'boolean' },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class ParenParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    _token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const exp = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    tokens.expectToken(')');\r\n\r\n    return exp;\r\n  }\r\n}\r\n\r\nexport abstract class ConsequentParselet {\r\n  constructor(\r\n    readonly tokenType: TokenType,\r\n    readonly associativity: 'left' | 'right'\r\n  ) {}\r\n  abstract parse(\r\n    parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    left: AST.Node,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}\r\n  ): AST.Node;\r\n}\r\n\r\nexport class BinaryOperatorParselet extends ConsequentParselet {\r\n  constructor(\r\n    public tokenType: BinaryOperationTokenType,\r\n    associativity: 'left' | 'right'\r\n  ) {\r\n    super(tokenType, associativity);\r\n  }\r\n\r\n  parse(\r\n    parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    left: AST.Node,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}\r\n  ): AST.Node {\r\n    const bindingPower = parser.bindingPower(token);\r\n\r\n    const right = parser.parse(\r\n      tokens,\r\n      this.associativity == 'left' ? bindingPower : bindingPower - 1,\r\n      varMap,\r\n      registeredNodes,\r\n      dependsMap\r\n    );\r\n    const position = join(left.pos, token2pos(tokens.last()));\r\n    const id = pos2string(position);\r\n    let newNode = {\r\n      nodeType: 'BinaryOperation' as 'BinaryOperation',\r\n      operator: this.tokenType,\r\n      left,\r\n      right,\r\n      outputType: undefined,\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n\r\n    return newNode;\r\n  }\r\n}\r\n\r\n// Parse function calls\r\n// Limitation: Functions are allowed to take exactly one argument\r\nexport class FunctionParselet implements InitialParselet {\r\n  \r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    tokens.expectToken('(');\r\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    let args = [arg1];\r\n    if (token.text == \"ParseOrderedPair\") {\r\n      const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for second argument\r\n      args.push(arg2);\r\n    }\r\n    tokens.expectToken(')');\r\n    let newNode = {\r\n      nodeType: 'Function' as 'Function',\r\n      name: token.text,\r\n      args: args,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class ChooseParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n\r\n    const predicate = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    const consequent = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    tokens.expectToken('CHOOSE2');\r\n    const otherwise = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n\r\n    let newNode = {\r\n      nodeType: 'Choose' as 'Choose',\r\n      case: { predicate: predicate, consequent: consequent },\r\n      otherwise: otherwise,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class VariableAssignmentParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    \r\n    // deal with variable assignment\r\n    tokens.expectToken('=');\r\n    const assignment = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n\r\n    // need to save the variable and its assignment in a lookup table\r\n    varMap[token.text] = id;\r\n    let newNode = {\r\n      nodeType: 'VariableAssignment' as 'VariableAssignment',\r\n      name: token.text,\r\n      assignment: assignment,\r\n      outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                    valueType: assignment?.outputType?.valueType },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    dependsMap[id] = findBases(assignment, dependsMap); // NEW FUNCTION HERE\r\n\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class IdentifierParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n    \r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // need to look up known variables in a lookup table (map?)\r\n\r\n    const assignmentId = varMap[token.text];\r\n\r\n    if (!assignmentId) {\r\n      const varParselet = new VariableAssignmentParselet();\r\n      return varParselet.parse(parser, tokens, token, varMap, registeredNodes, dependsMap);\r\n    }\r\n    else {\r\n      let newNode = {\r\n        nodeType: 'Identifier' as 'Identifier',\r\n        name: token.text,\r\n        assignmentId: assignmentId,\r\n        outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                      valueType: undefined },\r\n        pos: position,\r\n        nodeId: id\r\n      };\r\n      registeredNodes[id] = newNode;\r\n      return newNode;\r\n    }\r\n  }\r\n}\r\n","import {StringStream} from \"@codemirror/stream-parser\"\r\n\r\nexport function getTokens(text: string): Token[] {\r\n  const tokens: Token[] = [];\r\n  const state: State = {line: 1, stack: ['default']};\r\n\r\n  for (const line of text.split('\\n')) {\r\n    const stream = new StringStream();\r\n    stream.string = line;\r\n    while (!stream.eol()) {\r\n      const token = getToken(stream, state);\r\n      const emitToken = makeEmit(stream, state);\r\n      const fullToken = emitToken(token as TokenType);\r\n      if (token != undefined) {\r\n        tokens.push(fullToken);\r\n      }\r\n\r\n      if (stream.start == stream.pos) {\r\n        throw new Error(\r\n          `getToken failed to advance stream at position ${\r\n            stream.pos\r\n          } in string ${stream.string}`,\r\n        );\r\n      }\r\n      stream.start = stream.pos;\r\n    }\r\n\r\n    state.line += 1;\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\nexport function getToken(\r\n  stream: StringStream,\r\n  state: State,\r\n): string | undefined {\r\n  //Built for codeMirror streams API\r\n  //State is a stack of states\r\n  switch (state.stack[state.stack.length - 1]) {\r\n    default:\r\n      return getDefaultToken(stream, state);\r\n  }\r\n}\r\n\r\nfunction makeEmit(stream: StringStream, state: State) {\r\n  return function emitToken(type: TokenType): Token {\r\n    return {\r\n      type,\r\n      first_column: stream.start,\r\n      last_column: stream.pos,\r\n      line: state.line,\r\n      text: stream.current(),\r\n    };\r\n  };\r\n}\r\n\r\nexport function getDefaultToken(\r\n  stream: StringStream,\r\n  state: State,\r\n): string | undefined {\r\n  // const emitToken = makeEmit(stream, state);\r\n  if (stream.eatSpace()) {\r\n    // skip whitespace\r\n    return undefined;\r\n  }\r\n\r\n  if (stream.match(/\\+/)) {\r\n    return '+';\r\n  }\r\n\r\n  if (stream.match(/\\-/)) {\r\n    return '-';\r\n  }\r\n\r\n  if (stream.match(/\\*/)) {\r\n    return '*';\r\n  }\r\n\r\n  if (stream.match(/\\//)) {\r\n    return '/';\r\n  }\r\n\r\n  if (stream.match(/\\|/)) {\r\n    return '|';\r\n  }\r\n\r\n  if (stream.match(/\\&/)) {\r\n    return '&';\r\n  }\r\n\r\n  if (stream.match(/\\(/)) {\r\n    return '(';\r\n  }\r\n\r\n  if (stream.match(/\\)/)) {\r\n    return ')';\r\n  }\r\n\r\n  // adding an equals operator\r\n  if (stream.match(/\\=/)) {\r\n    return '=';\r\n  }\r\n\r\n  if (stream.match(/-?[0-9]+(\\.[0-9]+)?/)) {\r\n    return 'NUMBER';\r\n  }\r\n\r\n  if (stream.match(/True/)) {\r\n    return 'TRUE';\r\n  }\r\n\r\n  if (stream.match(/False/)) {\r\n    return 'FALSE';\r\n  }\r\n\r\n  if (stream.match(/#/)) {\r\n    if (!stream.match(/\\n/)) {\r\n      // comment lasts till end of line\r\n      stream.match(/.*/); // if no eol encountered, comment lasts till end of file\r\n    }\r\n    return 'COMMENT';\r\n  }\r\n\r\n  // hardcode when to be a choose node not an identifier to get around parsing\r\n  if (stream.match(/WHEN/)) {\r\n    return 'CHOOSE1';\r\n  }\r\n\r\n  // Remove otherwise clause for now\r\n  if (stream.match(/OTHERWISE/)) {\r\n    return 'CHOOSE2';\r\n  }\r\n\r\n  if (stream.match(/[A-Z]([a-z|A-Z])*/)) {\r\n    return 'FUNCTION';\r\n  }\r\n\r\n  // Identifiers\r\n  // For now, the form of a valid identifier is: a lower-case alphabetic character,\r\n  // followed by zero or more alpha characters.\r\n  if (stream.match(/[a-z]([a-z|A-Z])*/)) {\r\n    return 'IDENTIFIER';\r\n  }\r\n  \r\n\r\n  stream.next();\r\n  return 'ERROR';\r\n}\r\n\r\nexport type BinaryOperationTokenType =\r\n  | '+'\r\n  | '-'\r\n  | '*'\r\n  | '/'\r\n  | '|' // this is an or\r\n  | '&' // this is an and\r\n\r\nexport type TokenType =\r\n  | BinaryOperationTokenType\r\n  | 'NUM'\r\n  | 'TRUE'\r\n  | 'FALSE'\r\n  | '('\r\n  | ')'\r\n  | 'COMMENT'\r\n  | 'ERROR'\r\n  | 'FUNCTION'\r\n  | 'IDENTIFIER'\r\n  | 'CHOOSE1'\r\n  | 'CHOOSE2'\r\n  | '='\r\n\r\nexport interface Token<T extends TokenType = TokenType> {\r\n  type: T;\r\n  text: string;\r\n  line: number;\r\n  first_column: number;\r\n  last_column: number;\r\n}\r\n\r\ntype Mode = 'default';\r\n\r\nexport interface State {\r\n  stack: Mode[];\r\n  line: number;\r\n}\r\n","import {Token, TokenType, getTokens} from './lexer';\r\nimport {ParseError, token2pos} from './position';\r\n\r\nexport class TokenStream {\r\n  tokens: Token[];\r\n  pos: number = 0;\r\n\r\n  constructor(text: string) {\r\n    this.tokens = getTokens(text).filter(t => t.type != 'COMMENT');\r\n  }\r\n\r\n  consume(): Token | undefined {\r\n    const token = this.tokens[this.pos];\r\n    if (token) {\r\n      this.pos += 1;\r\n    }\r\n    return token;\r\n  }\r\n\r\n  peek(): Token | undefined {\r\n    return this.tokens[this.pos];\r\n  }\r\n\r\n  last(): Token {\r\n    return this.tokens[this.pos - 1];\r\n  }\r\n\r\n  expectToken<T extends TokenType>(expectedType: T): Token<T> {\r\n    const actual = this.consume();\r\n\r\n    if (!actual) {\r\n      throw new ParseError(\r\n        `Expected \"${expectedType}\" token but found none.`,\r\n        token2pos(this.last()),\r\n      );\r\n    }\r\n\r\n    if (actual.type != expectedType) {\r\n      throw new ParseError(\r\n        `Expected \"${expectedType}\" token type but found \"${actual.type}\".`,\r\n        token2pos(actual),\r\n      );\r\n    }\r\n\r\n    return actual as Token<T>;\r\n  }\r\n}\r\n","import * as Parselet from './parselet';\r\nimport {Token, TokenType} from './lexer';\r\nimport {TokenStream} from './tokenstream';\r\nimport {ParseError, token2pos} from './position';\r\nimport * as AST from './ast';\r\n\r\nexport function parse(text: string,\r\n                      varMap: {[key: string]: string},\r\n                      registeredNodes: {[key: string]: AST.Node},\r\n                      dependsMap: {[key: string]: string[]}): \r\n                      {nodes: AST.Node[]; errors: ParseError[]} {\r\n  const nodes: AST.Node[] = [];\r\n\r\n  const tokens = new TokenStream(text);\r\n  const parser = new Parser();\r\n  while (tokens.peek()) {\r\n    try {\r\n      nodes.push(parser.parse(tokens, 0, varMap, registeredNodes, dependsMap));\r\n    } catch (e) {\r\n      return {\r\n        nodes,\r\n        errors: [e],\r\n      };\r\n    }\r\n  }\r\n\r\n  return {nodes, errors: []};\r\n}\r\n\r\nexport abstract class AbstractParser {\r\n  public bindingPowers: {[tokenType in TokenType]: number};\r\n\r\n  protected abstract initialMap(): Partial<\r\n    {[K in TokenType]: Parselet.InitialParselet}\r\n  >;\r\n  protected abstract consequentMap(): Partial<\r\n    {[K in TokenType]: Parselet.ConsequentParselet}\r\n  >;\r\n  protected abstract bindingClasses(): TokenType[][];\r\n\r\n  constructor() {\r\n    this.bindingPowers = {} as any;\r\n\r\n    const bindingClasses = this.bindingClasses();\r\n    for (let i = 0; i < bindingClasses.length; i++) {\r\n      for (const tokenType of bindingClasses[i]) {\r\n        this.bindingPowers[tokenType] = 10 * i + 9;\r\n      }\r\n    }\r\n\r\n    for (const tokenType of Object.keys(this.consequentMap) as TokenType[]) {\r\n      if (this.bindingPowers[tokenType] == undefined) {\r\n        throw new Error(\r\n          `Token ${tokenType} defined in consequentMap has no associated binding power.\r\n          Make sure it is also listed in bindingClasses.`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  bindingPower(token: Token): number {\r\n    if (this.bindingPowers[token.type] != undefined) {\r\n      return this.bindingPowers[token.type];\r\n    } else {\r\n      throw new ParseError(\r\n        `Unexpected token type ${token.type}.`,\r\n        token2pos(token),\r\n      );\r\n    }\r\n  }\r\n\r\n  parse(tokens: TokenStream,\r\n        currentBindingPower: number,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}): AST.Node {\r\n    const token = tokens.consume();\r\n    if (!token) {\r\n      throw new ParseError(\r\n        `Unexpected end of tokens.`,\r\n        token2pos(tokens.last()),\r\n      );\r\n    }\r\n\r\n    const initialParselet = this.initialMap()[token.type];\r\n\r\n    if (!initialParselet) {\r\n      throw new ParseError(\r\n        `Unexpected token type ${token.type}`,\r\n        token2pos(token),\r\n      );\r\n    }\r\n\r\n    let left = initialParselet.parse(this, tokens, token, varMap, registeredNodes, dependsMap);\r\n\r\n    while (true) {\r\n      const next = tokens.peek();\r\n      if (!next) {\r\n        break;\r\n      }\r\n\r\n      const consequentParselet = this.consequentMap()[next.type];\r\n\r\n      if (!consequentParselet) {\r\n        break;\r\n      }\r\n\r\n      if (currentBindingPower >= this.bindingPower(next)) {\r\n        break;\r\n      }\r\n\r\n      tokens.consume();\r\n      left = consequentParselet.parse(this, tokens, left, next, varMap, registeredNodes, dependsMap);\r\n    }\r\n\r\n    return left;\r\n  }\r\n}\r\n\r\nexport class Parser extends AbstractParser {\r\n  initialMap() {\r\n    return {\r\n      NUMBER: new Parselet.NumberParselet(),\r\n      TRUE: new Parselet.BooleanParselet(true),\r\n      FALSE: new Parselet.BooleanParselet(false),\r\n      '(': new Parselet.ParenParselet(),\r\n      FUNCTION: new Parselet.FunctionParselet(),\r\n      CHOOSE1: new Parselet.ChooseParselet(),\r\n      IDENTIFIER: new Parselet.IdentifierParselet()\r\n    };\r\n  }\r\n\r\n  consequentMap() {\r\n    return {\r\n      '+': new Parselet.BinaryOperatorParselet('+', 'left'),\r\n      '-': new Parselet.BinaryOperatorParselet('-', 'left'),\r\n      '*': new Parselet.BinaryOperatorParselet('*', 'left'),\r\n      '/': new Parselet.BinaryOperatorParselet('/', 'left'),\r\n      '|': new Parselet.BinaryOperatorParselet('|', 'right'),\r\n      '&': new Parselet.BinaryOperatorParselet('&', 'right')\r\n    };\r\n  }\r\n\r\n  bindingClasses() {\r\n    const classes: TokenType[][] = [['+', '-'], ['*', '/'], ['|', '&']];\r\n    return classes;\r\n  }\r\n}\r\n","import {StateField} from \"@codemirror/state\"\r\nimport {Transaction} from \"@codemirror/state\"\r\nimport * as AST from './ast';\r\nimport {parse} from './parser';\r\nimport {ParseError} from './position';\r\n\r\n/**\r\n * A State field that holds the results of parsing\r\n */\r\nexport const parseResults: StateField<ParseResults> = StateField.define({\r\n  create() { return emptyParseResults },\r\n  update(value, tr) { return tr.docChanged ? parseProgram(tr) : value }\r\n})\r\n\r\n/**\r\n * Parse the program created from a transaction, returning a ParseResults object\r\n */\r\nfunction parseProgram(tr: Transaction) : ParseResults {\r\n  const contents = tr.state.doc.toString()\r\n\r\n  let varMap: {[key: string]: string} = {}\r\n  let registeredNodes: {[key: string]: AST.Node} = {}\r\n  let dependsMap: {[key: string]: string[]} = {}\r\n  const ast = parse(contents, varMap, registeredNodes, dependsMap)\r\n\r\n  return {\r\n    nodes: ast.nodes,\r\n    parseErrors: ast.errors,\r\n    varMap: varMap,\r\n    registeredNodes: registeredNodes,\r\n    dependsMap: dependsMap\r\n  }\r\n}\r\n\r\n/**\r\n * Type that describes the results of parsing\r\n */\r\nexport type ParseResults = {\r\n  nodes: AST.Node[];\r\n  parseErrors: ParseError[];\r\n  varMap: {[key: string]: string};\r\n  registeredNodes: {[key: string]: AST.Node};\r\n  dependsMap: {[key: string]: string[]};\r\n}\r\n\r\n/**\r\n * Can be used as the initial results of parsing\r\n */\r\nconst emptyParseResults: ParseResults = {\r\n  nodes: [],\r\n  parseErrors: [],\r\n  varMap: {},\r\n  registeredNodes: {},\r\n  dependsMap: {}\r\n}\r\n","import {Position} from './position';\r\nimport * as AST from './ast';\r\nimport {equals} from './equals';\r\n\r\n/***** ITERATION: change all outputType.valueType to simply outputType *****/\r\n\r\nexport function typecheck(nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n  const errors = nodes.map(n => typecheckNode(n, registeredNodes));\r\n  return ([] as TypeError[]).concat(...errors);\r\n}\r\n\r\nfunction typecheckNode(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n  return checkerMap[node.nodeType].check(node, registeredNodes);\r\n}\r\n\r\nexport class TypeError {\r\n  constructor(public message: string, public position: Position) {}\r\n}\r\n\r\nexport interface TypeChecker {\r\n  check(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[];\r\n}\r\n\r\nclass CheckNumber implements TypeChecker {\r\n  check(node: AST.NumberNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\nclass CheckBoolean implements TypeChecker {\r\n  check(node: AST.BooleanNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\nclass CheckBinary implements TypeChecker {\r\n  check(node: AST.BinaryOperationNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    const errors: TypeError[] = typecheckNode(node.left, registeredNodes).concat(typecheckNode(node.right, registeredNodes));\r\n    \r\n    // Check if same operand type (both numbers, both booleans)\r\n    if (node.left?.outputType?.valueType != node.right?.outputType?.valueType) {\r\n      errors.push(new TypeError(\"incompatible types for binary operator\", node.pos));\r\n    }\r\n    // Check if incorrect combination of operator and operands\r\n    else if (node.right?.outputType?.valueType == 'boolean' && (node.operator != \"|\" && node.operator != '&')) {\r\n      errors.push(new TypeError(\"incompatible operation for boolean operands\", node.pos));\r\n    }\r\n    else if (node.right?.outputType?.valueType == 'number' && (node.operator == \"|\" || node.operator == '&')) {\r\n      errors.push(new TypeError(\"incompatible operation for number operands\", node.pos));\r\n    }\r\n\r\n    node.outputType.valueType = node.left?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckFunction implements TypeChecker {\r\n  check(node: AST.FunctionNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    // First typecheck the argument\r\n    const arg1Errors = typecheckNode(node.args[0], registeredNodes);\r\n    errors = errors.concat(arg1Errors);\r\n    if (node.args.length > 1) {\r\n      const arg2Errors = typecheckNode(node.args[1], registeredNodes);\r\n      errors = errors.concat(arg2Errors);\r\n      if (node.args[0]?.outputType?.valueType != node.args[1]?.outputType?.valueType) {\r\n        errors.push(new TypeError(\"arguments must have same type\", node.args[0].pos));\r\n      }\r\n    }\r\n\r\n    const functionName = node.name\r\n    const argType = builtins[functionName].inputType;\r\n\r\n    // we found a builtin function\r\n    if (argType) {\r\n\r\n      // typecheck the argument\r\n      // Assume both arguments are the same type (see error produced above)\r\n      if (argType != 'any' && node.args[0]?.outputType?.valueType != argType) {\r\n        errors.push(new TypeError(\"incompatible argument type for \" + functionName, node.pos));\r\n      }\r\n    }\r\n  \r\n    // this is not a known, builtin function\r\n    else {\r\n      errors.push(new TypeError(\"unknown function\", node.pos));\r\n    }    \r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckChoose implements TypeChecker {\r\n  check(node: AST.ChooseNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    const predicate = node.case.predicate;\r\n    const consequent = node.case.consequent;\r\n    const otherwise = node.otherwise;\r\n\r\n    // First typecheck the inner nodes\r\n    const predErrors = typecheckNode(predicate, registeredNodes);\r\n    const consErrors = typecheckNode(consequent, registeredNodes);\r\n    const otherErrors = typecheckNode(otherwise, registeredNodes);\r\n    errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\r\n\r\n    // check return types are the same for both cases\r\n    if (consequent?.outputType?.valueType != otherwise?.outputType?.valueType) {\r\n      errors.push(new TypeError(\"Return types are not the same for both cases\", consequent.pos));\r\n      errors.push(new TypeError(\"Return types are not the same for both cases\", otherwise.pos));\r\n    }\r\n\r\n    // check that the predicate returns a boolean\r\n    if (predicate.outputType.valueType != 'boolean') {\r\n      errors.push(new TypeError(\"Predicate must return a boolean\", predicate.pos));\r\n    }\r\n\r\n    node.outputType.valueType = consequent?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckVariable implements TypeChecker {\r\n  check(node: AST.VariableAssignmentNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n    // First typecheck the assignment node\r\n    const assignmentErrors = typecheckNode(node.assignment, registeredNodes);\r\n    errors = errors.concat(assignmentErrors);\r\n\r\n    node.outputType.valueType = node.assignment?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckIdentifier implements TypeChecker {\r\n  check(node: AST.IdentifierNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    // Maybe make assigmentId be valueId?\r\n    let valueNode = registeredNodes[node.assignmentId].assignment;\r\n\r\n    // If this assignmentId is not found in the AST, throw an error\r\n    if (valueNode == undefined) {\r\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\r\n    }\r\n\r\n    node.outputType.valueType = valueNode.outputType.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\n// Dictionary of builtin functions that maps a function name to the type of its argument\r\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType} } = {\r\n  \"IsDefined\": {inputType: 'any', resultType: 'boolean'},\r\n  \"Inverse\": {inputType: 'number', resultType: 'number'},\r\n  \"Input\": {inputType: 'number', resultType: 'number'},\r\n  \"Sink\": {inputType: 'any', resultType: 'any'},\r\n  \"ParseOrderedPair\": {inputType: 'number', resultType: 'pair'},\r\n  \"X\": {inputType: 'pair', resultType: 'number'},\r\n  \"Y\": {inputType: 'pair', resultType: 'number'}\r\n}\r\n\r\nconst checkerMap: Partial<{[K in AST.NodeType]: TypeChecker}> = {\r\n  'Number' : new CheckNumber(),\r\n  'Boolean' : new CheckBoolean(),\r\n  'BinaryOperation' : new CheckBinary(),\r\n  'Function' : new CheckFunction(),\r\n  'Choose': new CheckChoose(),\r\n  'VariableAssignment': new CheckVariable(),\r\n  'Identifier': new CheckIdentifier()\r\n}","import {Position} from './position';\r\nimport * as AST from './ast';\r\nimport {equals} from './equals';\r\nimport {findBases} from './findBase';\r\n\r\nexport function mudCheck(nodes: AST.Node[], \r\n                        registeredNodes: {[key: string]: AST.Node},\r\n                        dependsMap: {[key: string]: string[]},\r\n                        assertMap: string[]): TypeError[] {\r\n  const errors = nodes.map(n => mudCheckNode(n, nodes, registeredNodes, dependsMap, assertMap));\r\n  return ([] as TypeError[]).concat(...errors);\r\n}\r\n\r\nfunction mudCheckNode(node: AST.Node, \r\n                    nodes: AST.Node[], \r\n                    registeredNodes: {[key: string]: AST.Node},\r\n                    dependsMap: {[key: string]: string[]},\r\n                    assertMap: string[]): TypeError[] {\r\n  return mudCheckerMap[node.nodeType].mudCheck(node, nodes, registeredNodes, dependsMap, assertMap);\r\n}\r\n\r\nexport class TypeError {\r\n  constructor(public message: string, public position: Position) {}\r\n}\r\n\r\nexport interface MudChecker {\r\n  mudCheck(node: AST.Node, \r\n          nodes: AST.Node[], \r\n          registeredNodes: {[key: string]: AST.Node},\r\n          dependsMap: {[key: string]: string[]},\r\n          assertMap: string[]): TypeError[];\r\n}\r\n\r\nclass MudCheckNumber implements MudChecker {\r\n  mudCheck(node: AST.NumberNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\nclass MudCheckBoolean implements MudChecker {\r\n    mudCheck(node: AST.BooleanNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\nclass MudCheckBinary implements MudChecker {\r\n    mudCheck(node: AST.BinaryOperationNode, \r\n            nodes: AST.Node[], \r\n            registeredNodes: {[key: string]: AST.Node},\r\n            dependsMap: {[key: string]: string[]},\r\n            assertMap: string[]): TypeError[] {\r\n        const errors: TypeError[] = mudCheckNode(node.left, nodes, registeredNodes, dependsMap, assertMap)\r\n        .concat(mudCheckNode(node.right, nodes, registeredNodes, dependsMap, assertMap));\r\n\r\n        // If no type errors, update the output type of this node, based on the outputType of its inputs\r\n        if (node.right?.outputType?.status == 'Maybe-Undefined' || node.left?.outputType?.status == 'Maybe-Undefined') {\r\n            node.outputType = {status: 'Maybe-Undefined',\r\n                              valueType: node.left?.outputType?.valueType };\r\n        } else {\r\n            node.outputType = {status: 'Definitely',\r\n                            valueType: node.left?.outputType?.valueType };\r\n        }\r\n\r\n        return errors;\r\n    }\r\n}\r\n\r\nclass MudCheckFunction implements MudChecker {\r\n    mudCheck(node: AST.FunctionNode, \r\n            nodes: AST.Node[], \r\n            registeredNodes: {[key: string]: AST.Node},\r\n            dependsMap: {[key: string]: string[]},\r\n            assertMap: string[]): TypeError[] {\r\n        let errors: TypeError[] = [];\r\n\r\n        if (node.name == 'Sink') {\r\n          assertMap = [];\r\n        }\r\n        \r\n        // First typecheck the argument\r\n        const arg1Errors = mudCheckNode(node.args[0], nodes, registeredNodes, dependsMap, assertMap);\r\n        errors = errors.concat(arg1Errors);\r\n        if (node.args.length > 1) {\r\n        const arg2Errors = mudCheckNode(node.args[1], nodes, registeredNodes, dependsMap, assertMap);\r\n        errors = errors.concat(arg2Errors);\r\n        }\r\n\r\n        const functionName = node.name\r\n        const argType = builtins[functionName].inputType;\r\n        const returnType = builtins[functionName].resultType;\r\n\r\n        // only show error if in sink \"node\"\r\n        if (functionName == 'Sink') {\r\n        // if sink \"node\" takes in possibly undefined values, warn the author\r\n        // a sink has one argument\r\n        if (node.args[0]?.outputType?.status == 'Maybe-Undefined') {\r\n            errors.push(new TypeError(\"User facing content could be undefined.\", node.args[0].pos));\r\n        }\r\n        }\r\n\r\n        // If no type errors, update the output type of this node, based on the outputType of its argument\r\n        if (node.args[0]?.outputType?.status == 'Maybe-Undefined' || functionName == 'Input') {\r\n            // IsDefined should always output a definitely regardless of argument status\r\n            if (functionName != 'IsDefined') {\r\n            node.outputType.status = 'Maybe-Undefined';\r\n            }\r\n            else {\r\n            node.outputType.status = 'Definitely';\r\n            }\r\n        } else if (node.args.length > 1) {\r\n            if (node.args[1].outputType.status == 'Maybe-Undefined') {\r\n            // Note: IsDefined only has one argument, so we don't need to check for that here\r\n            node.outputType.status = 'Maybe-Undefined';\r\n            } else {\r\n            node.outputType.status = 'Definitely';\r\n            }\r\n        } else {\r\n            node.outputType.status = 'Definitely';\r\n        }\r\n\r\n        node.outputType.valueType = returnType;\r\n\r\n        return errors;\r\n    }\r\n}\r\n\r\nclass MudCheckChoose implements MudChecker {\r\n    mudCheck(node: AST.ChooseNode, \r\n            nodes: AST.Node[], \r\n            registeredNodes: {[key: string]: AST.Node},\r\n            dependsMap: {[key: string]: string[]},\r\n            assertMap: string[]): TypeError[] {\r\n        let errors: TypeError[] = [];\r\n\r\n        const predicate = node.case.predicate;\r\n        const consequent = node.case.consequent;\r\n        const otherwise = node.otherwise;\r\n\r\n        // add stuff to the assertMap\r\n\r\n        // First typecheck the inner nodes\r\n        const predErrors = mudCheckNode(predicate, nodes, registeredNodes, dependsMap, assertMap);\r\n        const consErrors = mudCheckNode(consequent, nodes, registeredNodes, dependsMap, assertMap);\r\n        const otherErrors = mudCheckNode(otherwise, nodes, registeredNodes, dependsMap, assertMap);\r\n        errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\r\n\r\n        node.outputType.valueType = consequent.outputType.valueType;\r\n\r\n        // DEFUALT status = maybe-undefined\r\n\r\n        let consDef = false;\r\n        let otherDef = false;\r\n        let localAsserts: string[] = [];\r\n\r\n        if (otherwise.outputType.status == 'Definitely') {\r\n          otherDef = true;\r\n        }\r\n\r\n        // consequent in MU and we have a binary predicate\r\n        if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'BinaryOperation') {\r\n          // Cases: both bool *******************************\r\n          //        bool, function (and vice versa) *********\r\n          //        bool, binary op (and vice versa) IN PROGRESS\r\n          //        function, binary op (and vice versa)\r\n          //        both function ***************************\r\n          //        both binary op\r\n\r\n          // no need for bool, bool\r\n\r\n          consDef = doBinOp(predicate, consequent, dependsMap, assertMap);\r\n\r\n        }\r\n\r\n\r\n        // propagate maybe-undefined type, or change to definitely\r\n        // if the predicate is not a function, we cannot error check its type\r\n        if (consequent.outputType.status == 'Maybe-Undefined' && predicate.nodeType == 'Function') {\r\n          // we can only errorr check with IsDefined function\r\n          // IsDefined has only one argument\r\n          if (predicate.name == 'IsDefined') {\r\n            handleAsserts(predicate, dependsMap, assertMap);\r\n            consDef = handleCheck(consequent, dependsMap, assertMap);\r\n          }\r\n        }\r\n\r\n        if (consequent?.outputType.status == 'Definitely') {\r\n          consDef = true;\r\n        }\r\n\r\n        if (consDef && otherDef) {\r\n          node.outputType.status = 'Definitely';\r\n        }\r\n\r\n        return errors;\r\n    }\r\n}\r\n\r\nclass MudCheckVariable implements MudChecker {\r\n    mudCheck(node: AST.VariableAssignmentNode, \r\n            nodes: AST.Node[], \r\n            registeredNodes: {[key: string]: AST.Node},\r\n            dependsMap: {[key: string]: string[]},\r\n            assertMap: string[]): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n    // First typecheck the assignment node\r\n    const assignmentErrors = mudCheckNode(node.assignment, nodes, registeredNodes, dependsMap, assertMap);\r\n    errors = errors.concat(assignmentErrors);\r\n\r\n    // Set variable assignment node output type to the same as it's assignment\r\n    node.outputType.status = node.assignment.outputType.status;\r\n    node.outputType.valueType = node.assignment.outputType.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass MudCheckIdentifier implements MudChecker {\r\n    mudCheck(node: AST.IdentifierNode, \r\n            nodes: AST.Node[], \r\n            registeredNodes: {[key: string]: AST.Node},\r\n            dependsMap: {[key: string]: string[]}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    // Maybe make assigmentId be valueId?\r\n    let valueNode = registeredNodes[node.assignmentId].assignment;\r\n\r\n    // If this assignmentId is not found in the AST, throw an error\r\n    if (valueNode == undefined) {\r\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\r\n    } else {\r\n      // If we found the assignment node, set the output type of the identifier\r\n      node.outputType.status = valueNode.outputType.status;\r\n      node.outputType.valueType = valueNode.outputType.valueType;\r\n    }\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\n// Dictionary of builtin functions that maps a function name to the type of its argument\r\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType} } = {\r\n  \"IsDefined\": {inputType: 'any', resultType: 'boolean'},\r\n  \"Inverse\": {inputType: 'number', resultType: 'number'},\r\n  \"Input\": {inputType: 'number', resultType: 'number'},\r\n  \"Sink\": {inputType: 'any', resultType: 'any'},\r\n  \"ParseOrderedPair\": {inputType: 'number', resultType: 'pair'},\r\n  \"X\": {inputType: 'pair', resultType: 'number'},\r\n  \"Y\": {inputType: 'pair', resultType: 'number'}\r\n}\r\n\r\nconst mudCheckerMap: Partial<{[K in AST.NodeType]: MudChecker}> = {\r\n  'Number' : new MudCheckNumber(),\r\n  'Boolean' : new MudCheckBoolean(),\r\n  'BinaryOperation' : new MudCheckBinary(),\r\n  'Function' : new MudCheckFunction(),\r\n  'Choose': new MudCheckChoose(),\r\n  'VariableAssignment': new MudCheckVariable(),\r\n  'Identifier': new MudCheckIdentifier()\r\n}\r\n\r\nfunction handleAsserts(predicate: AST.Node,\r\n                      dependsMap: {[key: string]: string[]},\r\n                      assertMap: string[]): void {\r\n\r\n    // look up the bases of the predicate\r\n    let predBases = findBases(predicate, dependsMap);\r\n    // set outputType to Definitely if consBases are contained in predBases\r\n    // add to assertMap\r\n    for (let k = 0; k < predBases.length; k++) {\r\n      assertMap.push(predBases[k]);\r\n    }\r\n}\r\n\r\nfunction handleCheck(consequent: AST.Node,\r\n                    dependsMap: {[key: string]: string[]},\r\n                    assertMap: string[]): boolean {\r\n\r\n  let consBases = findBases(consequent, dependsMap);\r\n\r\n  let contained = true;\r\n    for (let i = 0; i < consBases.length; i++) {\r\n      if (!assertMap.find(e => e == consBases[i])) {\r\n        contained = false;\r\n      }\r\n    }\r\n\r\n    return contained;\r\n}\r\n\r\nfunction resolveBF(predicate: AST.Node,\r\n                  consequent: AST.Node,\r\n                  dependsMap: {[key: string]: string[]},\r\n                  assertMap: string[]): boolean {\r\n\r\n  // boolean, function\r\n  if (predicate.right.name == 'IsDefined') {\r\n    handleAsserts(predicate.right, dependsMap, assertMap);\r\n    return handleCheck(consequent, dependsMap, assertMap);\r\n  }\r\n  else {\r\n    return false;\r\n  }\r\n\r\n}\r\n\r\nfunction resolveFB(predicate: AST.Node,\r\n                  consequent: AST.Node,\r\n                  dependsMap: {[key: string]: string[]},\r\n                  assertMap: string[]): boolean {\r\n  // function, boolean\r\n  if (predicate.left.name == 'IsDefined') {\r\n    handleAsserts(predicate.left, dependsMap, assertMap);\r\n    return handleCheck(consequent, dependsMap, assertMap);\r\n  }\r\n  else {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction resolveFF(predicate: AST.Node,\r\n                  consequent: AST.Node,\r\n                  dependsMap: {[key: string]: string[]},\r\n                  assertMap: string[]): boolean {\r\n  // function, function\r\n  let consDefLeft = false;\r\n  let consDefRight = false;\r\n  let consDefBoth = false;\r\n  let localAsserts: string[] = [];\r\n\r\n  if (predicate.left.name == 'IsDefined') {\r\n    handleAsserts(predicate.left, dependsMap, localAsserts);\r\n    consDefLeft = handleCheck(consequent, dependsMap, localAsserts);\r\n    if (consDefLeft) {\r\n      assertMap = assertMap.concat(localAsserts);\r\n    }\r\n    localAsserts = [];\r\n  }\r\n\r\n  if (predicate.right.name == 'IsDefined') {\r\n    handleAsserts(predicate.right, dependsMap, localAsserts);\r\n    consDefRight = handleCheck(consequent, dependsMap, localAsserts);\r\n    if (consDefRight) {\r\n      assertMap = assertMap.concat(localAsserts);\r\n    }\r\n    localAsserts = [];\r\n  }\r\n\r\n  if (predicate.left.name == 'IsDefined' && predicate.right.name == 'IsDefined' && predicate.operator == '&') {\r\n    handleAsserts(predicate.left, dependsMap, localAsserts);\r\n    handleAsserts(predicate.right, dependsMap, localAsserts);\r\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\r\n    if (consDefBoth) {\r\n      assertMap = assertMap.concat(localAsserts);\r\n    }\r\n    localAsserts = [];\r\n  }\r\n\r\n  if (predicate.operator == '&') {\r\n    return consDefLeft || consDefRight || consDefBoth;\r\n  }\r\n  else if (predicate.operator == '|') {\r\n    return consDefLeft && consDefRight;\r\n  }\r\n  else {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction resolveBBO(predicate: AST.Node,\r\n  consequent: AST.Node,\r\n  dependsMap: {[key: string]: string[]},\r\n  assertMap: string[]): boolean {\r\n  // boolean, binary operation\r\n  // recurse on the right\r\n  let consDefRight = doBinOp(predicate.right, consequent, dependsMap, assertMap);\r\n  if (predicate.left.value == false && predicate.operator == '|') {\r\n    return consDefRight;\r\n  }\r\n  if (predicate.left.value == true && predicate.operator == '&') {\r\n    return consDefRight;\r\n  }\r\n  else {\r\n    // this may change to true\r\n    return false;\r\n  }\r\n\r\n}\r\n\r\nfunction resolveBOB(predicate: AST.Node,\r\n  consequent: AST.Node,\r\n  dependsMap: {[key: string]: string[]},\r\n  assertMap: string[]): boolean {\r\n  // binary operation, boolean\r\n  let consDefLeft = doBinOp(predicate.left, consequent, dependsMap, assertMap);\r\n  if (predicate.right.value == false && predicate.operator == '|') {\r\n    return consDefLeft;\r\n  }\r\n  if (predicate.right.value == true && predicate.operator == '&') {\r\n    return consDefLeft;\r\n  }\r\n  else {\r\n    // this may change to true\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction resolveBOF(predicate: AST.Node,\r\n  consequent: AST.Node,\r\n  dependsMap: {[key: string]: string[]},\r\n  assertMap: string[]): boolean {\r\n  // binary operation, function\r\n  // recurse on the left with local asserts\r\n  let consDefLeft = false;\r\n  let consDefRight = false;\r\n  let consDefBoth = false;\r\n  let localAsserts: string[] = [];\r\n\r\n  consDefLeft = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\r\n  if (consDefLeft) {\r\n    assertMap = assertMap.concat(localAsserts);\r\n  }\r\n  localAsserts = [];\r\n\r\n  if (predicate.right.name == 'IsDefined') {\r\n    handleAsserts(predicate.right, dependsMap, localAsserts);\r\n    consDefRight = handleCheck(consequent, dependsMap, localAsserts);\r\n    if (consDefRight) {\r\n      assertMap = assertMap.concat(localAsserts);\r\n    }\r\n    localAsserts = [];\r\n  }\r\n\r\n  if (predicate.right.name == 'IsDefined' && predicate.operator == '&') {\r\n    let temp = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\r\n    handleAsserts(predicate.right, dependsMap, localAsserts);\r\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\r\n    if (consDefBoth) {\r\n      assertMap = assertMap.concat(localAsserts);\r\n    }\r\n    localAsserts = [];\r\n  }\r\n\r\n  if (predicate.operator == '&') {\r\n    return consDefLeft || consDefRight || consDefBoth;\r\n  }\r\n  else if (predicate.operator == '|') {\r\n    return consDefLeft && consDefRight;\r\n  }\r\n  else {\r\n    return false;\r\n  }\r\n  \r\n}\r\n\r\nfunction resolveFBO(predicate: AST.Node,\r\n  consequent: AST.Node,\r\n  dependsMap: {[key: string]: string[]},\r\n  assertMap: string[]): boolean {\r\n  // function, binary operation\r\n  // recurse on the left with local asserts\r\n  let consDefLeft = false;\r\n  let consDefRight = false;\r\n  let consDefBoth = false;\r\n  let localAsserts: string[] = [];\r\n\r\n  consDefRight = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\r\n  if (consDefRight) {\r\n    assertMap = assertMap.concat(localAsserts);\r\n  }\r\n  localAsserts = [];\r\n\r\n  if (predicate.left.name == 'IsDefined') {\r\n    handleAsserts(predicate.left, dependsMap, localAsserts);\r\n    consDefLeft = handleCheck(consequent, dependsMap, localAsserts);\r\n    if (consDefLeft) {\r\n      assertMap = assertMap.concat(localAsserts);\r\n    }\r\n    localAsserts = [];\r\n  }\r\n\r\n  if (predicate.left.name == 'IsDefined' && predicate.operator == '&') {\r\n    let temp = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\r\n    handleAsserts(predicate.left, dependsMap, localAsserts);\r\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\r\n    if (consDefBoth) {\r\n      assertMap = assertMap.concat(localAsserts);\r\n    }\r\n    localAsserts = [];\r\n  }\r\n\r\n  if (predicate.operator == '&') {\r\n    return consDefLeft || consDefRight || consDefBoth;\r\n  }\r\n  else if (predicate.operator == '|') {\r\n    return consDefLeft && consDefRight;\r\n  }\r\n  else {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction resolveBOBO(predicate: AST.Node,\r\n  consequent: AST.Node,\r\n  dependsMap: {[key: string]: string[]},\r\n  assertMap: string[]): boolean {\r\n  // binary operation, binary operation\r\n  let consDefLeft = false;\r\n  let consDefRight = false;\r\n  let consDefBoth = false;\r\n  let localAsserts: string[] = [];\r\n\r\n  consDefRight = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\r\n  if (consDefRight) {\r\n    assertMap = assertMap.concat(localAsserts);\r\n  }\r\n  localAsserts = [];\r\n\r\n  consDefLeft = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\r\n  if (consDefLeft) {\r\n    assertMap = assertMap.concat(localAsserts);\r\n  }\r\n  localAsserts = [];\r\n\r\n  if (predicate.operator == '&') {\r\n    let temp = doBinOp(predicate.right, consequent, dependsMap, localAsserts);\r\n    let temp2 = doBinOp(predicate.left, consequent, dependsMap, localAsserts);\r\n    consDefBoth = handleCheck(consequent, dependsMap, localAsserts);\r\n    if (consDefBoth) {\r\n      assertMap = assertMap.concat(localAsserts);\r\n    }\r\n    localAsserts = [];\r\n  }\r\n\r\n  if (predicate.operator == '&') {\r\n    return consDefLeft || consDefRight || consDefBoth;\r\n  }\r\n  else if (predicate.operator == '|') {\r\n    return consDefLeft && consDefRight;\r\n  }\r\n  else {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction doBinOp(predicate: AST.Node,\r\n  consequent: AST.Node,\r\n  dependsMap: {[key: string]: string[]},\r\n  assertMap: string[]): boolean {\r\n  let consDef = false;\r\n  // function, boolean\r\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'Boolean') {\r\n    consDef = resolveFB(predicate, consequent, dependsMap, assertMap);\r\n  }\r\n\r\n  // boolean, function\r\n  if (predicate.left.nodeType == 'Boolean' && predicate.right.nodeType == 'Function') {\r\n    consDef = resolveBF(predicate, consequent, dependsMap, assertMap);\r\n  }\r\n\r\n  // function, function\r\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'Function') {\r\n    consDef = resolveFF(predicate, consequent, dependsMap, assertMap);\r\n\r\n  }\r\n\r\n  // bool, binary op\r\n  if (predicate.left.nodeType == 'Boolean' && predicate.right.nodeType == 'BinaryOperation') {\r\n    consDef = resolveBBO(predicate, consequent, dependsMap, assertMap);\r\n  }\r\n\r\n  // binary op, bool\r\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'Boolean') {\r\n    consDef = resolveBOB(predicate, consequent, dependsMap, assertMap);\r\n  }\r\n\r\n  // function, binary op\r\n  if (predicate.left.nodeType == 'Function' && predicate.right.nodeType == 'BinaryOperation') {\r\n    consDef = resolveFBO(predicate, consequent, dependsMap, assertMap);\r\n  }\r\n\r\n  // binary op, function\r\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'Function') {\r\n    consDef = resolveBOF(predicate, consequent, dependsMap, assertMap);\r\n  }\r\n\r\n  // binary op, binary op\r\n  if (predicate.left.nodeType == 'BinaryOperation' && predicate.right.nodeType == 'BinaryOperation') {\r\n    consDef = resolveBOBO(predicate, consequent, dependsMap, assertMap);\r\n  }\r\n\r\n  return consDef;\r\n}","import {StreamParser, StringStream} from \"@codemirror/stream-parser\"\r\nimport {Diagnostic} from \"@codemirror/lint\"\r\nimport {EditorView} from \"@codemirror/view\"\r\nimport {State, getDefaultToken} from './lexer'\r\nimport {ParseError} from './position'\r\nimport {typecheck} from './typechecker';\r\nimport {mudCheck} from './mudChecker';\r\nimport {darCheck} from './darChecker';\r\nimport {parseResults} from './parseResults';\r\n\r\n/**\r\n * The extension for our language\r\n */\r\nexport const miniCL: StreamParser<State> = {\r\n  startState: function (): State {\r\n    return {line: 1, stack: ['default']};\r\n  },\r\n  token: function (stream: StringStream, state: State): string | undefined {\r\n    if (stream.eatSpace()) return null;\r\n    return token2tag(getDefaultToken(stream, state));\r\n  }\r\n};\r\n\r\n/**\r\n * The linter for our language\r\n */\r\n export const miniCLLinter = () => (view: EditorView): Diagnostic[] => {\r\n\r\n  // Get the result types\r\n  const results = view.state.field(parseResults);\r\n\r\n  // Error checking\r\n  let assertMap: string[] = [];\r\n  const mudErrors = mudCheck(results.nodes, results.registeredNodes, results.dependsMap, assertMap);\r\n  const typeErrors = typecheck(results.nodes, results.registeredNodes);\r\n  const darErrors = darCheck(results.nodes, results.registeredNodes);\r\n\r\n  // Create a diagnostic for each kind of error\r\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\r\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\r\n  const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\r\n  const darDiagnostics = darErrors.map(makeDiagnostic(view, 'warning'));\r\n\r\n  return parseDiagnostics.concat(typeDiagnostics).concat(darDiagnostics);\r\n}\r\n\r\n/**\r\n * Create a diagnostic from an error\r\n */\r\nconst makeDiagnostic = (view: EditorView, severity: 'error' | 'info' | 'warning' = 'error') => \r\n  (error): Diagnostic => {\r\n    return {\r\n      from: firstLine(view, error) + error.position.first_column,\r\n      to: lastLine(view, error) + error.position.last_column,\r\n      message: error.message,\r\n      severity: severity\r\n    }\r\n}\r\n\r\n/**\r\n * @returns the line number for the start of the error\r\n */\r\nfunction firstLine(view: EditorView, error: ParseError) {\r\n  return view.state.doc.line(error.position.first_line).from;\r\n}\r\n\r\n/**\r\n * @returns the line number for the end of the error\r\n */\r\nfunction lastLine (view: EditorView, error: ParseError) {\r\n  return view.state.doc.line(error.position.last_line).from;    \r\n}\r\n\r\n/**\r\n * Convert our bespoke parser Token type to a token type that is recognized by CodeMirror\r\n */\r\nfunction token2tag(token: string): string | undefined {\r\n  switch (token) {\r\n    case 'NUMBER':\r\n      return 'number';\r\n\r\n    case 'TRUE':\r\n      return 'boolean';\r\n\r\n    case 'FALSE':\r\n      return 'boolean';\r\n\r\n    case '(':\r\n    case ')':\r\n      return 'bracket';\r\n\r\n    case '+':\r\n    case '-':\r\n    case '*':\r\n    case '/':\r\n    case '|':\r\n    case '&':\r\n    case '=':\r\n      return 'operator';\r\n\r\n    case 'COMMENT':\r\n      return 'comment';\r\n\r\n    case 'CHOOSE1':\r\n    case 'CHOOSE2':\r\n      return 'choose';\r\n\r\n    case 'FUNCTION':\r\n      return 'function';\r\n\r\n    case 'IDENTIFIER':\r\n      return 'variable';\r\n\r\n    case 'ERROR':\r\n      return 'error';\r\n\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n","import * as d3Hierarchy from 'd3-hierarchy';\r\nimport * as d3Select from 'd3-selection';\r\nimport * as d3shape from 'd3-shape';\r\nimport * as AST from './ast';\r\n\r\nexport function visualize(nodes: AST.Node[]): void {\r\n\r\n    // Placement and size of tree\r\n    const margin = {top: 20, right: 90, bottom: 20, left: 90};\r\n    const height = 300 - margin.top - margin.bottom;\r\n    const width  = 500 - margin.left - margin.right;\r\n  \r\n    // Make the svg\r\n    d3Select.select('#viz').selectAll('svg').remove();\r\n    const viz = d3Select.select('#viz').append('svg');\r\n  \r\n    // Remove existing visualizations\r\n    viz.selectAll('*').remove();\r\n  \r\n    // Add a new visualization\r\n    viz.attr('width', width + margin.left + margin.right)\r\n       .attr('height', height + margin.top + margin.bottom);\r\n\r\n    const root: Node = {nodeType: 'Program', children: nodes}\r\n\r\n    // Visualize all the statements\r\n    // for (var statement of nodes) {\r\n\r\n      // Create the tree and layout\r\n      const treemap = d3Hierarchy.tree()\r\n        .size([height, width])\r\n        .separation(() => 1);\r\n      const treelayout = d3Hierarchy.hierarchy(root, getChildren);\r\n      const tree = treemap(treelayout);\r\n  \r\n      // Add a new graph element for this statement\r\n      const g = viz.append('g')\r\n                  //  .attr(\"transform\", `translate(${root.dy / 3},${root.dx - x0})`);\r\n                   .attr('transform', `translate(${margin.left}, ${margin.top})`)\r\n                   .attr(\"font-family\", \"sans-serif\")\r\n                   .attr(\"font-size\", 12)\r\n               \r\n      // Edge updates\r\n      const link = g.selectAll('path.link').data(tree.links());\r\n\r\n      // Edge entry\r\n      const linkEnter = link.enter().append('path', 'g');\r\n        \r\n      // general edge attributes\r\n      linkEnter.attr('class', 'link')\r\n               .attr('fill', 'none')\r\n               .attr(\"stroke-opacity\", 0.4)\r\n               .attr('stroke', '#555')\r\n               .attr(\"stroke-width\", 1.5)\r\n               .attr('d', connection);\r\n\r\n        \r\n      // Node updates\r\n      const node = g.selectAll('g.node').data(tree.descendants());\r\n\r\n      // Node entry\r\n      const nodeEnter = node.enter().append('g');\r\n\r\n      // general node attributes\r\n      nodeEnter.attr('class', 'node')\r\n               .attr('transform', d => `translate(${d.y}, ${d.x})`);\r\n\r\n      nodeEnter.append('circle')\r\n               .attr(\"fill\", getFill)\r\n               .attr('r', '2.5')\r\n               .attr('stroke-width', 10);\r\n\r\n      // add text\r\n      nodeEnter.append('text')\r\n                // .attr('dy', '-10px')\r\n                .attr(\"dy\", \"0.31em\")\r\n                .attr(\"x\", d => d.children ? -8 : 8)\r\n                .attr(\"text-anchor\", d => d.children ? \"end\" : \"start\")\r\n                .attr('fill', d => isUndefined(d) ? '#fc6666' : 'black')\r\n                .style(\"fill-opacity\", 1)\r\n                .call(getTextBox)\r\n                .datum(d => d.data)\r\n                .text(getText)\r\n          .clone(true).lower()\r\n            .attr(\"stroke\", \"white\");\r\n    \r\n      // Highlight undefined -- not working\r\n      // Inspired in part by https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\r\n      nodeEnter.filter((d,i) => isUndefined(d))\r\n        .call(yep)\r\n        .insert('rect', 'text')\r\n        .attr(\"x\", function(d){return d.bbox.x})\r\n        .attr(\"y\", function(d){return d.bbox.y})\r\n        .attr(\"width\", function(d){return d.bbox.width})\r\n        .attr(\"height\", function(d){return d.bbox.height}) \r\n        .attr('fill', 'black')             \r\n    // }\r\n}\r\n\r\n// From https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\r\nfunction getTextBox(selection) {\r\n  selection.each(function(d){d.bbox = this.getBBox();})\r\n}\r\n\r\nfunction yep(selection) {\r\n  // console.log(selection.nodes().map((d)=>d.bbox));\r\n}\r\n\r\n\r\nconst connection = d3shape.linkHorizontal().x(d => d.y).y(d => d.x)\r\n\r\nfunction getChildren(node: AST.Node): AST.Node[] {\r\n  var children: AST.Node[] = [];\r\n  switch (node.nodeType) {\r\n    case 'Program':\r\n      children = node.children;\r\n      break;\r\n    case 'Function':\r\n      children = node.args;\r\n      break;\r\n    case 'Choose':\r\n      children = [node.case.predicate, node.case.consequent, node.otherwise];\r\n      break;\r\n    case 'BinaryOperation':\r\n      children = [node.left, node.right];\r\n      break;\r\n    case 'VariableAssignment':\r\n      children = [node.assignment];\r\n      break;\r\n    default:\r\n      children = [];\r\n    }\r\n\r\n  return children;\r\n}\r\n\r\nfunction getText(node) {\r\n  var text = \"\";\r\n  switch (node.nodeType) {\r\n    case 'Program':\r\n      text = '';\r\n      break;\r\n    case 'Function':\r\n      text = node.name;\r\n      break;\r\n    case 'Choose':\r\n      text = \"choose\";\r\n      break;\r\n    case 'BinaryOperation':\r\n      text = node.operator;\r\n      break;\r\n    case 'VariableAssignment':\r\n      text = node.name;\r\n      break;\r\n    case 'Identifier':\r\n      text = node.name;\r\n      break;\r\n    case 'Number':  \r\n      text = node.value.toString();\r\n      break;\r\n    case 'Boolean':\r\n      text = node.value.toString();\r\n      break;\r\n    default:\r\n      text = \"\";\r\n  }\r\n\r\n  return text;\r\n}\r\n\r\nfunction getFill(node): string {\r\n  if (isUndefined(node)) {\r\n    return '#fc6666'\r\n  }\r\n  if (node.children) {\r\n    return '#555'\r\n  } else {\r\n    return '#999'\r\n  }\r\n}\r\n\r\nfunction isUndefined(d) {\r\n  return d.data.outputType?.status === 'Maybe-Undefined'\r\n}","import {Transaction} from \"@codemirror/state\"\r\nimport {json, jsonParseLinter} from \"@codemirror/lang-json\"\r\nimport {foldAll} from \"@codemirror/fold\"\r\nimport { visualize } from \"./visualization\"\r\nimport {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\r\nimport {linter} from \"@codemirror/lint\"\r\nimport { parseResults } from \"./parseResults\"\r\n\r\n/**\r\n * Given a transaction, update the developer tools\r\n */\r\n export function updateDevTools(tr: Transaction) {\r\n  const results = tr.state.field(parseResults)\r\n\r\n  // Display JSON for AST\r\n  const astJSON = JSON.stringify(results.nodes, null, 2)\r\n  replaceContents(astViewer, astJSON);\r\n\r\n  // Display JSON for depends map\r\n  const dependsJSON = JSON.stringify(results.dependsMap, null, 2);\r\n  replaceContents(dependsViewer, dependsJSON);\r\n\r\n  // Draw the AST\r\n  visualize(results.nodes);\r\n}\r\n\r\n// Configuration for a read-only JSON viewer with folding, line numbers, etc.\r\nfunction newJSONViewerState(): EditorState {\r\n  return EditorState.create({\r\n    extensions: [\r\n      basicSetup,\r\n      json(),\r\n      linter(jsonParseLinter()),\r\n      EditorView.editable.of(false),\r\n    ],\r\n  })\r\n}\r\n\r\n// JSON viewer for AST\r\nlet astViewer = new EditorView({\r\n  state: newJSONViewerState(),\r\n  parent: document.querySelector(\"#ast-json\"),\r\n});\r\n\r\n// JSON viewer for depends map\r\nlet dependsViewer = new EditorView({\r\n  state: newJSONViewerState(),\r\n  parent: document.querySelector(\"#depends-json\"),\r\n});\r\n\r\n/**\r\n * Replace the entire contents of an editor\r\n */\r\nfunction replaceContents(editor: EditorView, contents: string) {\r\n  const update = editor.state.update({\r\n    changes: {\r\n      from: 0,\r\n      to: editor.state.doc.length,\r\n      insert: contents\r\n    }\r\n  });\r\n  editor.update([update]);\r\n  foldAll(editor);  // By default, fold all levels\r\n}\r\n","import {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\r\nimport {Transaction} from \"@codemirror/state\"\r\nimport {linter} from \"@codemirror/lint\"\r\nimport {miniCL, miniCLLinter} from \"./miniCL\"\r\nimport {StreamLanguage} from \"@codemirror/stream-parser\"\r\nimport {parseResults} from \"./parseResults\"\r\nimport {updateDevTools} from \"./devTools\"\r\nimport \"./styles.css\"\r\nimport \"./desmos_icons.css\"\r\n\r\n// Create the CodeMirror miniCL editor and add it to the document.\r\nlet miniCLEditor = new EditorView({\r\n  state: EditorState.create({\r\n    extensions: [\r\n      basicSetup,                     // https://codemirror.net/6/docs/ref/#basic-setup\r\n      StreamLanguage.define(miniCL),  // syntax coloring for miniCL\r\n      parseResults,                   // field that holds the results of parsing\r\n      linter(miniCLLinter())          // error-checking for miniCL\r\n    ],\r\n  }),\r\n  dispatch: updateOutput,\r\n  parent: document.querySelector(\"#miniCL-editor\")\r\n})\r\n\r\n// When the content changes, update the editor and the dev tools\r\nfunction updateOutput(tr: Transaction) {\r\n  miniCLEditor.update([tr]);\r\n  updateDevTools(tr);\r\n}\r\n"]}