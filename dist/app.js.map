{"version":3,"sources":["src/miniCL.ts","src/position.ts","src/findBase.ts","src/parselet.ts","src/lexer.ts","src/tokenstream.ts","src/parser.ts","src/parseResults.ts","src/visualization.ts","src/devTools.ts","src/index.ts","src/typechecker.ts","src/darChecker.ts"],"names":["startState","line","stack","token","stream","state","eatSpace","token2tag","lexer_1","view","results","field","parseResults_1","assertMap","darErrors","darChecker_1","nodes","registeredNodes","typeErrors","typechecker_1","parseDiagnostics","parseErrors","map","makeDiagnostic","typeDiagnostics","darDiagnostics","concat","severity","error","from","firstLine","position","first_column","to","lastLine","last_column","message","doc","first_line","last_line","undefined","start","end","pos","toString","constructor","node","dependsMap","nodeType","baseMap","findBase","baseList","leftList","findBases","left","rightList","right","console","log","name","push","nodeId","i","args","length","consBases","case","consequent","otherBases","otherwise","assignmentId","BaseNumber","BaseBoolean","BaseBinary","BaseFunction","BaseChoose","BaseVariableAssignment","BaseIdentifier","BaseIterator","parse","_parser","_tokens","varMap","position_1","id","newNode","value","parseFloat","text","outputType","status","valueType","parser","tokens","_token","exp","expectToken","arg1","arg2","arg3","index","values","step","tokenType","associativity","ConsequentParselet","bindingPower","last","operator","predicate","assignment","indexOf","findBase_1","varParselet","VariableAssignmentParselet","split","stream_parser_1","string","eol","getToken","emitToken","makeEmit","fullToken","Error","getDefaultToken","type","current","match","next","filter","t","consume","peek","expectedType","actual","tokenstream_1","Parser","e","errors","bindingPowers","bindingClasses","Object","keys","consequentMap","currentBindingPower","initialParselet","initialMap","consequentParselet","AbstractParser","NUMBER","NumberParselet","TRUE","BooleanParselet","FALSE","ParenParselet","BracketParselet","FUNCTION","FunctionParselet","CHOOSE1","ChooseParselet","IDENTIFIER","IdentifierParselet","BinaryOperatorParselet","classes","state_1","define","create","emptyParseResults","update","tr","docChanged","parseProgram","contents","ast","parser_1","margin","top","bottom","height","width","select","selectAll","remove","viz","append","attr","root","children","treemap","tree","size","separation","treelayout","hierarchy","getChildren","g","link","data","links","linkEnter","enter","connection","descendants","nodeEnter","d","y","x","getFill","isUndefined","style","call","getTextBox","datum","getText","clone","lower","yep","insert","bbox","selection","each","getBBox","linkHorizontal","astJSON","JSON","stringify","replaceContents","astViewer","dependsJSON","dependsViewer","visualization_1","basic_setup_1","extensions","lang_json_1","lint_1","editable","of","newJSONViewerState","parent","document","querySelector","editor","changes","fold_1","miniCLEditor","miniCL_1","dispatch","updateOutput","devTools_1","n","typecheckNode","checkerMap","check","TypeError","arg1Errors","arg2Errors","functionName","argType","builtins","inputType","predErrors","consErrors","otherErrors","assignmentErrors","assignmentNode","valueNode","resultType","CheckNumber","CheckBoolean","CheckBinary","CheckFunction","CheckChoose","CheckVariable","CheckIdentifier","CheckIterator","CheckRangeIdentifier","darCheckNode","darCheckerMap","darCheck","evaluateOperation","getRange","out","DarCheckNumber","DarCheckAny","DarCheckBinary","DarCheckFunction","DarCheckVariable","DarCheckIdentifier","DarCheckIterator"],"mappings":"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","file":"","sourcesContent":["import {StreamParser, StringStream} from \"@codemirror/stream-parser\"\r\nimport {Diagnostic} from \"@codemirror/lint\"\r\nimport {EditorView} from \"@codemirror/view\"\r\nimport {State, getDefaultToken} from './lexer'\r\nimport {ParseError} from './position'\r\nimport {typecheck} from './typechecker';\r\n//import {mudCheck} from './mudChecker';\r\nimport {darCheck} from './darChecker';\r\nimport {parseResults} from './parseResults';\r\n\r\n/**\r\n * The extension for our language\r\n */\r\nexport const miniCL: StreamParser<State> = {\r\n  startState: function (): State {\r\n    return {line: 1, stack: ['default']};\r\n  },\r\n  token: function (stream: StringStream, state: State): string | undefined {\r\n    if (stream.eatSpace()) return null;\r\n    return token2tag(getDefaultToken(stream, state));\r\n  }\r\n};\r\n\r\n/**\r\n * The linter for our language\r\n */\r\n export const miniCLLinter = () => (view: EditorView): Diagnostic[] => {\r\n\r\n  // Get the result types\r\n  const results = view.state.field(parseResults);\r\n\r\n  // Error checking\r\n  let assertMap: string[] = [];\r\n  //const mudErrors = mudCheck(results.nodes, results.registeredNodes, results.dependsMap, assertMap);\r\n  const darErrors = darCheck(results.nodes, results.registeredNodes);\r\n  const typeErrors = typecheck(results.nodes, results.registeredNodes);\r\n  \r\n\r\n  // Create a diagnostic for each kind of error\r\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\r\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\r\n  //const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\r\n  const darDiagnostics = darErrors.map(makeDiagnostic(view, 'warning'));\r\n\r\n  return parseDiagnostics.concat(typeDiagnostics).concat(darDiagnostics);\r\n}\r\n\r\n/**\r\n * Create a diagnostic from an error\r\n */\r\nconst makeDiagnostic = (view: EditorView, severity: 'error' | 'info' | 'warning' = 'error') => \r\n  (error): Diagnostic => {\r\n    return {\r\n      from: firstLine(view, error) + error.position.first_column,\r\n      to: lastLine(view, error) + error.position.last_column,\r\n      message: error.message,\r\n      severity: severity\r\n    }\r\n}\r\n\r\n/**\r\n * @returns the line number for the start of the error\r\n */\r\nfunction firstLine(view: EditorView, error: ParseError) {\r\n  return view.state.doc.line(error.position.first_line).from;\r\n}\r\n\r\n/**\r\n * @returns the line number for the end of the error\r\n */\r\nfunction lastLine (view: EditorView, error: ParseError) {\r\n  return view.state.doc.line(error.position.last_line).from;    \r\n}\r\n\r\n/**\r\n * Convert our bespoke parser Token type to a token type that is recognized by CodeMirror\r\n */\r\nfunction token2tag(token: string): string | undefined {\r\n  switch (token) {\r\n    case 'NUMBER':\r\n      return 'number';\r\n\r\n    case 'TRUE':\r\n      return 'boolean';\r\n\r\n    case 'FALSE':\r\n      return 'boolean';\r\n\r\n    case '(':\r\n    case ')':\r\n      return 'bracket';\r\n\r\n    case '+':\r\n    case '-':\r\n    case '*':\r\n    case '/':\r\n    case '|':\r\n    case '&':\r\n    case '=':\r\n      return 'operator';\r\n\r\n    case 'COMMENT':\r\n      return 'comment';\r\n\r\n    case 'CHOOSE1':\r\n    case 'CHOOSE2':\r\n      return 'choose';\r\n\r\n    case 'FUNCTION':\r\n      return 'function';\r\n\r\n    case 'IDENTIFIER':\r\n      return 'variable';\r\n\r\n    case 'ERROR':\r\n      return 'error';\r\n\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n","import { Token } from './lexer';\r\n\r\nexport type Position = {\r\n  first_line: number;\r\n  first_column: number;\r\n  last_line: number;\r\n  last_column: number;\r\n};\r\n\r\nexport function token2pos(token: Token): Position {\r\n  return {\r\n    first_line: token.line,\r\n    last_line: token.line,\r\n    first_column: token.first_column,\r\n    last_column: token.last_column\r\n  }\r\n}\r\n\r\nexport function join(start: Position, end: Position) {\r\n  return {\r\n    first_line: start.first_line,\r\n    last_line: end.last_line,\r\n    first_column: start.first_column,\r\n    last_column: end.last_column\r\n  };\r\n}\r\n\r\nexport function pos2string(pos: Position): string {\r\n  return pos.first_line.toString() + \".\" +\r\n         pos.first_column.toString() + \".\" +\r\n         pos.last_line.toString() + \".\" +\r\n         pos.last_column.toString();\r\n}\r\n\r\n// note, extending Error in the browser is problematic\r\n// https://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node\r\nexport class ParseError {\r\n  constructor(public message: string, public position: Position) {}\r\n}\r\n","import * as AST from './ast';\r\n\r\nexport function findBases(node: AST.Node, dependsMap: {[key: string]: string[]}): string[] {\r\n\r\n    if (node == undefined || node.nodeType == undefined){\r\n        return [];\r\n    } else{\r\n        return baseMap[node.nodeType]!.findBase(node, dependsMap); \r\n    }\r\n\r\n    \r\n}\r\n\r\nexport interface BaseFinder {\r\n  findBase(node: AST.Node, dependsMap: {[key: string]: string[]}): string[];\r\n}\r\n\r\nclass BaseNumber implements BaseFinder {\r\n  findBase(node: AST.NumberNode): string[] {\r\n    return []\r\n  }\r\n}\r\n\r\nclass BaseBoolean implements BaseFinder {\r\n    findBase(node: AST.BooleanNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\nclass BaseBinary implements BaseFinder {\r\n    findBase(node: AST.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        let baseList: string[] = [];\r\n        // recursively call findBases on left and right\r\n        let leftList = findBases(node.left, dependsMap);\r\n        baseList = baseList.concat(leftList);\r\n        let rightList = findBases(node.right, dependsMap)\r\n        baseList = baseList.concat(rightList);\r\n        return baseList;\r\n    }\r\n}\r\n\r\n// examples: x = Input(3); x = IsDefined(Input(3)); z = Inverse(x)\r\n// need dependsMap for the third example\r\nclass BaseFunction implements BaseFinder {\r\n    findBase(node: AST.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        console.log(\"in base function\");\r\n        let baseList: string[] = [];\r\n        if (node.name == \"Input\") {\r\n            // this is a base\r\n            baseList.push(node.nodeId);\r\n        }\r\n        else {\r\n            // recursively call findBases on argument(s)\r\n            for (let i = 0; i < node.args.length; i++) {\r\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\r\n            }\r\n        }\r\n        return baseList;\r\n    }\r\n}\r\n\r\n// assume that choose nodes will never create their own bases\r\n// they can still error check previously defined bases\r\nclass BaseChoose implements BaseFinder {\r\n    findBase(node: AST.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        let baseList: string[] = [];\r\n        // the bases of the cons and the otherwise\r\n        letÂ consBases = findBases(node.case.consequent, dependsMap);\r\n        baseList = baseList.concat(consBases);\r\n        let otherBases = findBases(node.otherwise, dependsMap);\r\n        baseList = baseList.concat(otherBases);\r\n        return baseList;\r\n    }\r\n}\r\n\r\nclass BaseVariableAssignment implements BaseFinder {\r\n    findBase(node: AST.VariableAssignmentNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\nclass BaseIdentifier implements BaseFinder {\r\n    findBase(node: AST.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\r\n        // follow the chain in the dependsMap\r\n        return dependsMap[node.assignmentId];\r\n    }\r\n}\r\n\r\nclass BaseIterator implements BaseFinder {\r\n    findBase(node: AST.IteratorNode): string[] {\r\n        return []\r\n    }\r\n}\r\n\r\n\r\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\r\n  'Number' : new BaseNumber(),\r\n  'Boolean' : new BaseBoolean(),\r\n  'BinaryOperation' : new BaseBinary(),\r\n  'Function' : new BaseFunction(),\r\n  'Choose': new BaseChoose(),\r\n  'VariableAssignment': new BaseVariableAssignment(),\r\n  'Identifier': new BaseIdentifier(),\r\n  'Iterator': new BaseIterator()\r\n}\r\n","import { TokenStream } from './tokenstream';\r\nimport { Token, TokenType, BinaryOperationTokenType} from './lexer';\r\nimport * as AST from './ast';\r\nimport { AbstractParser } from './parser';\r\nimport {ParseError, token2pos, join, pos2string} from './position';\r\nimport {findBases} from './findBase';\r\n\r\nexport interface InitialParselet {\r\n  parse(parser: AbstractParser,\r\n        tokens: TokenStream, token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}): AST.Node;\r\n}\r\n\r\n\r\nexport class NumberParselet implements InitialParselet {\r\n  parse(_parser: AbstractParser,\r\n        _tokens: TokenStream,\r\n        token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // add node to the map\r\n    let newNode : AST.NumberNode = {\r\n      nodeType: 'Number' as 'Number',\r\n      value: parseFloat(token.text),\r\n      outputType: { status: 'Definitely' as 'Definitely',\r\n                    valueType: 'number' as 'number',\r\n                    value: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class BooleanParselet implements InitialParselet {\r\n  constructor(private value: boolean) {}\r\n  parse(_parser: AbstractParser,\r\n        _tokens: TokenStream, token: Token,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    let newNode = {\r\n      nodeType: 'Boolean' as 'Boolean',\r\n      value: this.value,\r\n      outputType: { status: 'Definitely' as 'Definitely',\r\n                    valueType: 'boolean' as 'boolean',\r\n                    value: undefined},\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class ParenParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    _token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const exp = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    tokens.expectToken(')');\r\n\r\n    return exp;\r\n  }\r\n}\r\n\r\nexport class BracketParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream, token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    const arg3 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    tokens.expectToken(']');\r\n\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // add node to the map\r\n    let newNode : AST.IteratorNode = {\r\n      nodeType: 'Iterator' as 'Iterator',\r\n      outputType: undefined,\r\n      pos: position,\r\n      nodeId: id,\r\n      index: 0,\r\n      values: [],\r\n      start: arg1,\r\n      end: arg2,\r\n      step: arg3,\r\n    };\r\n\r\n    console.log(\"The Iterator parslet is running!\")\r\n    registeredNodes[id] = newNode;\r\n\r\n\r\n    return newNode;\r\n\r\n  }\r\n}\r\n\r\nexport abstract class ConsequentParselet {\r\n  constructor(\r\n    readonly tokenType: TokenType,\r\n    readonly associativity: 'left' | 'right'\r\n  ) {}\r\n  abstract parse(\r\n    parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    left: AST.Node,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}\r\n  ): AST.Node;\r\n}\r\n\r\nexport class BinaryOperatorParselet extends ConsequentParselet {\r\n  constructor(\r\n    public tokenType: BinaryOperationTokenType,\r\n    associativity: 'left' | 'right'\r\n  ) {\r\n    super(tokenType, associativity);\r\n  }\r\n\r\n  parse(\r\n    parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    left: Exclude<Exclude<AST.Node, AST.ProgramNode>, undefined>,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}\r\n  ): AST.Node {\r\n    const bindingPower = parser.bindingPower(token);\r\n\r\n    const right = parser.parse(\r\n      tokens,\r\n      this.associativity == 'left' ? bindingPower : bindingPower - 1,\r\n      varMap,\r\n      registeredNodes,\r\n      dependsMap\r\n    );\r\n    const position = join(left.pos, token2pos(tokens.last()));\r\n    const id = pos2string(position);\r\n    let newNode = {\r\n      nodeType: 'BinaryOperation' as 'BinaryOperation',\r\n      operator: this.tokenType,\r\n      left,\r\n      right,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined,\r\n                    value: undefined},\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n\r\n    return newNode;\r\n  }\r\n}\r\n\r\n// Parse function calls\r\n// Limitation: Functions are allowed to take exactly one argument\r\nexport class FunctionParselet implements InitialParselet {\r\n  \r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    tokens.expectToken('(');\r\n    const arg1 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for one argument\r\n    let args = [arg1];\r\n    if (token.text == \"ParseOrderedPair\") {\r\n      const arg2 = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);  // allow for second argument\r\n      args.push(arg2);\r\n    }\r\n    tokens.expectToken(')');\r\n    let newNode = {\r\n      nodeType: 'Function' as 'Function',\r\n      name: token.text,\r\n      args: args,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined,\r\n                    value: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class ChooseParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n\r\n    const predicate = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    const consequent = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n    tokens.expectToken('CHOOSE2');\r\n    const otherwise = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n\r\n    let newNode = {\r\n      nodeType: 'Choose' as 'Choose',\r\n      case: { predicate: predicate, consequent: consequent },\r\n      otherwise: otherwise,\r\n      outputType: { status: 'Maybe-Undefined' as 'Maybe-Undefined',\r\n                    valueType: undefined,\r\n                    value: undefined },\r\n      pos: position,\r\n      nodeId: id\r\n    };\r\n    registeredNodes[id] = newNode;\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class VariableAssignmentParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n\r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    \r\n    //is this a special '%' assignment or identifier?\r\n\r\n\r\n    \r\n\r\n    // deal with variable assignment\r\n    tokens.expectToken('=');\r\n    const assignment = parser.parse(tokens, 0, varMap, registeredNodes, dependsMap);\r\n\r\n\r\n    // need to save the variable and its assignment in a lookup table\r\n    varMap[token.text] = id;\r\n\r\n    if (token.text.indexOf(\"%\") != -1){\r\n\r\n      let newNode = {\r\n        nodeType: 'VariableAssignment' as 'VariableAssignment',\r\n        name: token.text,\r\n        assignment: assignment,\r\n        outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                      valueType: assignment?.outputType?.valueType,\r\n                      value: undefined },\r\n        pos: position,\r\n        nodeId: id\r\n      };\r\n      registeredNodes[id] = newNode;\r\n      dependsMap[id] = findBases(assignment, dependsMap); // NEW FUNCTION HERE\r\n      return newNode;\r\n\r\n    } else {\r\n      let newNode = {\r\n        nodeType: 'VariableAssignment' as 'VariableAssignment',\r\n        name: token.text,\r\n        assignment: assignment,\r\n        outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                      valueType: assignment?.outputType?.valueType,\r\n                      value: undefined },\r\n        pos: position,\r\n        nodeId: id\r\n      };\r\n      registeredNodes[id] = newNode;\r\n      dependsMap[id] = findBases(assignment, dependsMap); // NEW FUNCTION HERE\r\n      return newNode;\r\n    }\r\n\r\n \r\n\r\n  }\r\n}\r\n\r\nexport class IdentifierParselet implements InitialParselet {\r\n  parse(parser: AbstractParser,\r\n    tokens: TokenStream,\r\n    token: Token,\r\n    varMap: {[key: string]: string},\r\n    registeredNodes: {[key: string]: AST.Node},\r\n    dependsMap: {[key: string]: string[]}) {\r\n    \r\n    const position = token2pos(token);\r\n    const id = pos2string(position);\r\n    // need to look up known variables in a lookup table (map?)\r\n\r\n\r\n    const assignmentId = varMap[token.text];\r\n\r\n    if (!assignmentId) {\r\n      //if the variable is an assignment\r\n      const varParselet = new VariableAssignmentParselet();\r\n      return varParselet.parse(parser, tokens, token, varMap, registeredNodes, dependsMap);\r\n\r\n    }\r\n    else {\r\n      if (token.text.indexOf(\"%\") != -1){\r\n        let newNode = {\r\n          nodeType: 'RangeIdentifier' as 'RangeIdentifier',\r\n          name: token.text,\r\n          assignmentId: assignmentId,\r\n          outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                        valueType: undefined,\r\n                        value: undefined },\r\n          pos: position,\r\n          nodeId: id\r\n        };\r\n        registeredNodes[id] = newNode;\r\n        return newNode;\r\n      } else {\r\n        let newNode = {\r\n          nodeType: 'Identifier' as 'Identifier',\r\n          name: token.text,\r\n          assignmentId: assignmentId,\r\n          outputType: { status: \"Maybe-Undefined\" as \"Maybe-Undefined\",\r\n                        valueType: undefined,\r\n                        value: undefined },\r\n          pos: position,\r\n          nodeId: id\r\n        };\r\n        registeredNodes[id] = newNode;\r\n        return newNode;\r\n      }\r\n\r\n    }\r\n  }\r\n}\r\n","import {StringStream} from \"@codemirror/stream-parser\"\r\n\r\nexport function getTokens(text: string): Token[] {\r\n  const tokens: Token[] = [];\r\n  const state: State = {line: 1, stack: ['default']};\r\n\r\n  for (const line of text.split('\\n')) {\r\n    const stream = new StringStream(line, 4, 1);\r\n    stream.string = line;\r\n    while (!stream.eol()) {\r\n      const token = getToken(stream, state);\r\n      const emitToken = makeEmit(stream, state);\r\n      const fullToken = emitToken(token as TokenType);\r\n      if (token != undefined) {\r\n        tokens.push(fullToken);\r\n      }\r\n\r\n      if (stream.start == stream.pos) {\r\n        throw new Error(\r\n          `getToken failed to advance stream at position ${\r\n            stream.pos\r\n          } in string ${stream.string}`,\r\n        );\r\n      }\r\n      stream.start = stream.pos;\r\n    }\r\n\r\n    state.line += 1;\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\nexport function getToken(\r\n  stream: StringStream,\r\n  state: State,\r\n): string | undefined {\r\n  //Built for codeMirror streams API\r\n  //State is a stack of states\r\n  switch (state.stack[state.stack.length - 1]) {\r\n    default:\r\n      return getDefaultToken(stream, state);\r\n  }\r\n}\r\n\r\nfunction makeEmit(stream: StringStream, state: State) {\r\n  return function emitToken(type: TokenType): Token {\r\n    return {\r\n      type,\r\n      first_column: stream.start,\r\n      last_column: stream.pos,\r\n      line: state.line,\r\n      text: stream.current(),\r\n    };\r\n  };\r\n}\r\n\r\nexport function getDefaultToken(\r\n  stream: StringStream,\r\n  state: State,\r\n): string | undefined {\r\n  // const emitToken = makeEmit(stream, state);\r\n  if (stream.eatSpace()) {\r\n    // skip whitespace\r\n    return undefined;\r\n  }\r\n\r\n  if (stream.match(/\\+/)) {\r\n    return '+';\r\n  }\r\n\r\n  if (stream.match(/\\-/)) {\r\n    return '-';\r\n  }\r\n\r\n  if (stream.match(/\\*/)) {\r\n    return '*';\r\n  }\r\n\r\n  if (stream.match(/\\//)) {\r\n    return '/';\r\n  }\r\n\r\n  if (stream.match(/\\|/)) {\r\n    return '|';\r\n  }\r\n\r\n  if (stream.match(/\\&/)) {\r\n    return '&';\r\n  }\r\n\r\n  if (stream.match(/\\(/)) {\r\n    return '(';\r\n  }\r\n\r\n  if (stream.match(/\\)/)) {\r\n    return ')';\r\n  }\r\n\r\n  if (stream.match(/\\[/)) {\r\n    return '[';\r\n  }\r\n\r\n  if (stream.match(/\\]/)) {\r\n    return ']';\r\n  }\r\n\r\n  // adding an equals operator\r\n  if (stream.match(/\\=/)) {\r\n    return '=';\r\n  }\r\n\r\n  if (stream.match(/-?[0-9]+(\\.[0-9]+)?/)) {\r\n    return 'NUMBER';\r\n  }\r\n\r\n  if (stream.match(/True/)) {\r\n    return 'TRUE';\r\n  }\r\n\r\n  if (stream.match(/False/)) {\r\n    return 'FALSE';\r\n  }\r\n\r\n  if (stream.match(/#/)) {\r\n    if (!stream.match(/\\n/)) {\r\n      // comment lasts till end of line\r\n      stream.match(/.*/); // if no eol encountered, comment lasts till end of file\r\n    }\r\n    return 'COMMENT';\r\n  }\r\n\r\n  // hardcode when to be a choose node not an identifier to get around parsing\r\n  if (stream.match(/WHEN/)) {\r\n    return 'CHOOSE1';\r\n  }\r\n\r\n  // Remove otherwise clause for now\r\n  if (stream.match(/OTHERWISE/)) {\r\n    return 'CHOOSE2';\r\n  }\r\n\r\n\r\n  if (stream.match(/[A-Z]([a-z|A-Z])*/)) {\r\n    return 'FUNCTION';\r\n  }\r\n\r\n  // Identifiers\r\n  // For now, the form of a valid identifier is: a lower-case alphabetic character,\r\n  // followed by zero or more alpha characters.\r\n  //if (stream.match(/[A-Za-z][\\w$]*(\\.[\\w$]+)?(\\[\\d+])?/)) {\r\n  //  return 'IDENTIFIER';\r\n  //}\r\n  if (stream.match(/[A-Za-z][(\\w|\\%)$]*(\\.[\\w$]+)?(\\[\\d+])?/)) {\r\n    return 'IDENTIFIER';\r\n  }\r\n\r\n\r\n\r\n  stream.next();\r\n  return 'ERROR';\r\n}\r\n\r\nexport type BinaryOperationTokenType =\r\n  | '+'\r\n  | '-'\r\n  | '*'\r\n  | '/'\r\n  | '|' // this is an or\r\n  | '&' // this is an and\r\n\r\nexport type TokenType =\r\n  | BinaryOperationTokenType\r\n  | 'NUM'\r\n  | 'TRUE'\r\n  | 'FALSE'\r\n  | '('\r\n  | ')'\r\n  | 'COMMENT'\r\n  | 'ERROR'\r\n  | 'FUNCTION'\r\n  | 'IDENTIFIER'\r\n  | 'CHOOSE1'\r\n  | 'CHOOSE2'\r\n  | '='\r\n  | 'RANGE'\r\n  | '['\r\n  | ']'\r\n  | 'RANGEIDENTIFIER'\r\n\r\nexport interface Token<T extends TokenType = TokenType> {\r\n  type: T;\r\n  text: string;\r\n  line: number;\r\n  first_column: number;\r\n  last_column: number;\r\n}\r\n\r\ntype Mode = 'default';\r\n\r\nexport interface State {\r\n  stack: Mode[];\r\n  line: number;\r\n}\r\n","import {Token, TokenType, getTokens} from './lexer';\r\nimport {ParseError, token2pos} from './position';\r\n\r\nexport class TokenStream {\r\n  tokens: Token[];\r\n  pos: number = 0;\r\n\r\n  constructor(text: string) {\r\n    this.tokens = getTokens(text).filter(t => t.type != 'COMMENT');\r\n  }\r\n\r\n  consume(): Token | undefined {\r\n    const token = this.tokens[this.pos];\r\n    if (token) {\r\n      this.pos += 1;\r\n    }\r\n    return token;\r\n  }\r\n\r\n  peek(): Token | undefined {\r\n    return this.tokens[this.pos];\r\n  }\r\n\r\n  last(): Token {\r\n    return this.tokens[this.pos - 1];\r\n  }\r\n\r\n  expectToken<T extends TokenType>(expectedType: T): Token<T> {\r\n    const actual = this.consume();\r\n\r\n    if (!actual) {\r\n      throw new ParseError(\r\n        `Expected \"${expectedType}\" token but found none.`,\r\n        token2pos(this.last()),\r\n      );\r\n    }\r\n\r\n    if (actual.type != expectedType) {\r\n      throw new ParseError(\r\n        `Expected \"${expectedType}\" token type but found \"${actual.type}\".`,\r\n        token2pos(actual),\r\n      );\r\n    }\r\n\r\n    return actual as Token<T>;\r\n  }\r\n}\r\n","import * as Parselet from './parselet';\r\nimport {Token, TokenType} from './lexer';\r\nimport {TokenStream} from './tokenstream';\r\nimport {ParseError, token2pos} from './position';\r\nimport * as AST from './ast';\r\n\r\nexport function parse(text: string,\r\n                      varMap: {[key: string]: string},\r\n                      registeredNodes: {[key: string]: AST.Node},\r\n                      dependsMap: {[key: string]: string[]}): \r\n                      {nodes: AST.Node[]; errors: ParseError[]} {\r\n  const nodes: AST.Node[] = [];\r\n\r\n  const tokens = new TokenStream(text);\r\n  const parser = new Parser();\r\n  while (tokens.peek()) {\r\n    try {\r\n      nodes.push(parser.parse(tokens, 0, varMap, registeredNodes, dependsMap));\r\n    } catch (e) {\r\n      return {\r\n        nodes,\r\n        errors: [e],\r\n      };\r\n    }\r\n  }\r\n\r\n  return {nodes, errors: []};\r\n}\r\n\r\nexport abstract class AbstractParser {\r\n  public bindingPowers: {[tokenType in TokenType]: number};\r\n\r\n  protected abstract initialMap(): Partial<\r\n    {[K in TokenType]: Parselet.InitialParselet}\r\n  >;\r\n  protected abstract consequentMap(): Partial<\r\n    {[K in TokenType]: Parselet.ConsequentParselet}\r\n  >;\r\n  protected abstract bindingClasses(): TokenType[][];\r\n\r\n  constructor() {\r\n    this.bindingPowers = {} as any;\r\n\r\n    const bindingClasses = this.bindingClasses();\r\n    for (let i = 0; i < bindingClasses.length; i++) {\r\n      for (const tokenType of bindingClasses[i]) {\r\n        this.bindingPowers[tokenType] = 10 * i + 9;\r\n      }\r\n    }\r\n\r\n    for (const tokenType of Object.keys(this.consequentMap) as TokenType[]) {\r\n      if (this.bindingPowers[tokenType] == undefined) {\r\n        throw new Error(\r\n          `Token ${tokenType} defined in consequentMap has no associated binding power.\r\n          Make sure it is also listed in bindingClasses.`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  bindingPower(token: Token): number {\r\n    if (this.bindingPowers[token.type] != undefined) {\r\n      return this.bindingPowers[token.type];\r\n    } else {\r\n      throw new ParseError(\r\n        `Unexpected token type ${token.type}.`,\r\n        token2pos(token),\r\n      );\r\n    }\r\n  }\r\n\r\n  parse(tokens: TokenStream,\r\n        currentBindingPower: number,\r\n        varMap: {[key: string]: string},\r\n        registeredNodes: {[key: string]: AST.Node},\r\n        dependsMap: {[key: string]: string[]}): AST.Node {\r\n    const token = tokens.consume();\r\n    if (!token) {\r\n      throw new ParseError(\r\n        `Unexpected end of tokens.`,\r\n        token2pos(tokens.last()),\r\n      );\r\n    }\r\n\r\n    const initialParselet = this.initialMap()[token.type];\r\n\r\n    if (!initialParselet) {\r\n      throw new ParseError(\r\n        `Unexpected token type ${token.type}`,\r\n        token2pos(token),\r\n      );\r\n    }\r\n\r\n    let left = initialParselet.parse(this, tokens, token, varMap, registeredNodes, dependsMap);\r\n\r\n    while (true) {\r\n      const next = tokens.peek();\r\n      if (!next) {\r\n        break;\r\n      }\r\n\r\n      const consequentParselet = this.consequentMap()[next.type];\r\n\r\n      if (!consequentParselet) {\r\n        break;\r\n      }\r\n\r\n      if (currentBindingPower >= this.bindingPower(next)) {\r\n        break;\r\n      }\r\n\r\n      tokens.consume();\r\n      left = consequentParselet.parse(this, tokens, left, next, varMap, registeredNodes, dependsMap);\r\n    }\r\n\r\n    return left;\r\n  }\r\n}\r\n\r\nexport class Parser extends AbstractParser {\r\n  initialMap() : any { //TODO: Setting this to any is hacky...\r\n    return {\r\n      NUMBER: new Parselet.NumberParselet(),\r\n      TRUE: new Parselet.BooleanParselet(true),\r\n      FALSE: new Parselet.BooleanParselet(false),\r\n      '(': new Parselet.ParenParselet(),\r\n      '[': new Parselet.BracketParselet(),\r\n      FUNCTION: new Parselet.FunctionParselet(),\r\n      CHOOSE1: new Parselet.ChooseParselet(),\r\n      IDENTIFIER: new Parselet.IdentifierParselet()\r\n    };\r\n  }\r\n\r\n\r\n  consequentMap() {\r\n    return {\r\n      '+': new Parselet.BinaryOperatorParselet('+', 'left'),\r\n      '-': new Parselet.BinaryOperatorParselet('-', 'left'),\r\n      '*': new Parselet.BinaryOperatorParselet('*', 'left'),\r\n      '/': new Parselet.BinaryOperatorParselet('/', 'left'),\r\n      '|': new Parselet.BinaryOperatorParselet('|', 'right'),\r\n      '&': new Parselet.BinaryOperatorParselet('&', 'right')\r\n    };\r\n  }\r\n\r\n  bindingClasses() {\r\n    const classes: TokenType[][] = [['+', '-'], ['*', '/'], ['|', '&']];\r\n    return classes;\r\n  }\r\n}\r\n","import {StateField} from \"@codemirror/state\"\r\nimport {Transaction} from \"@codemirror/state\"\r\nimport * as AST from './ast';\r\nimport {parse} from './parser';\r\nimport {ParseError} from './position';\r\n\r\n/**\r\n * A State field that holds the results of parsing\r\n */\r\nexport const parseResults: StateField<ParseResults> = StateField.define({\r\n  create() { return emptyParseResults },\r\n  update(value, tr) { return tr.docChanged ? parseProgram(tr) : value }\r\n})\r\n\r\n/**\r\n * Parse the program created from a transaction, returning a ParseResults object\r\n */\r\nfunction parseProgram(tr: Transaction) : ParseResults {\r\n  const contents = tr.state.doc.toString()\r\n\r\n  let varMap: {[key: string]: string} = {}\r\n  let registeredNodes: {[key: string]: AST.Node} = {}\r\n  let dependsMap: {[key: string]: string[]} = {}\r\n  const ast = parse(contents, varMap, registeredNodes, dependsMap)\r\n\r\n  return {\r\n    nodes: ast.nodes,\r\n    parseErrors: ast.errors,\r\n    varMap: varMap,\r\n    registeredNodes: registeredNodes,\r\n    dependsMap: dependsMap\r\n  }\r\n}\r\n\r\n/**\r\n * Type that describes the results of parsing\r\n */\r\nexport type ParseResults = {\r\n  nodes: AST.Node[];\r\n  parseErrors: ParseError[];\r\n  varMap: {[key: string]: string};\r\n  registeredNodes: {[key: string]: AST.Node};\r\n  dependsMap: {[key: string]: string[]};\r\n}\r\n\r\n/**\r\n * Can be used as the initial results of parsing\r\n */\r\nconst emptyParseResults: ParseResults = {\r\n  nodes: [],\r\n  parseErrors: [],\r\n  varMap: {},\r\n  registeredNodes: {},\r\n  dependsMap: {}\r\n}\r\n","import * as d3Hierarchy from 'd3-hierarchy';\r\nimport * as d3Select from 'd3-selection';\r\nimport * as d3shape from 'd3-shape';\r\nimport * as AST from './ast';\r\n\r\nexport function visualize(nodes: AST.Node[]): void {\r\n\r\n    // Placement and size of tree\r\n    const margin = {top: 20, right: 90, bottom: 20, left: 90};\r\n    const height = 300 - margin.top - margin.bottom;\r\n    const width  = 500 - margin.left - margin.right;\r\n  \r\n    // Make the svg\r\n    d3Select.select('#viz').selectAll('svg').remove();\r\n    const viz = d3Select.select('#viz').append('svg');\r\n  \r\n    // Remove existing visualizations\r\n    viz.selectAll('*').remove();\r\n  \r\n    // Add a new visualization\r\n    viz.attr('width', width + margin.left + margin.right)\r\n       .attr('height', height + margin.top + margin.bottom);\r\n\r\n    const root: Node = {nodeType: 'Program', children: nodes}\r\n\r\n    // Visualize all the statements\r\n    // for (var statement of nodes) {\r\n\r\n      // Create the tree and layout\r\n      const treemap = d3Hierarchy.tree()\r\n        .size([height, width])\r\n        .separation(() => 1);\r\n      const treelayout = d3Hierarchy.hierarchy(root, getChildren);\r\n      const tree = treemap(treelayout);\r\n  \r\n      // Add a new graph element for this statement\r\n      const g = viz.append('g')\r\n                  //  .attr(\"transform\", `translate(${root.dy / 3},${root.dx - x0})`);\r\n                   .attr('transform', `translate(${margin.left}, ${margin.top})`)\r\n                   .attr(\"font-family\", \"sans-serif\")\r\n                   .attr(\"font-size\", 12)\r\n               \r\n      // Edge updates\r\n      const link = g.selectAll('path.link').data(tree.links());\r\n\r\n      // Edge entry\r\n      const linkEnter = link.enter().append('path', 'g');\r\n        \r\n      // general edge attributes\r\n      linkEnter.attr('class', 'link')\r\n               .attr('fill', 'none')\r\n               .attr(\"stroke-opacity\", 0.4)\r\n               .attr('stroke', '#555')\r\n               .attr(\"stroke-width\", 1.5)\r\n               .attr('d', connection);\r\n\r\n        \r\n      // Node updates\r\n      const node = g.selectAll('g.node').data(tree.descendants());\r\n\r\n      // Node entry\r\n      const nodeEnter = node.enter().append('g');\r\n\r\n      // general node attributes\r\n      nodeEnter.attr('class', 'node')\r\n               .attr('transform', d => `translate(${d.y}, ${d.x})`);\r\n\r\n      nodeEnter.append('circle')\r\n               .attr(\"fill\", getFill)\r\n               .attr('r', '2.5')\r\n               .attr('stroke-width', 10);\r\n\r\n      // add text\r\n      nodeEnter.append('text')\r\n                // .attr('dy', '-10px')\r\n                .attr(\"dy\", \"0.31em\")\r\n                .attr(\"x\", d => d.children ? -8 : 8)\r\n                .attr(\"text-anchor\", d => d.children ? \"end\" : \"start\")\r\n                .attr('fill', d => isUndefined(d) ? '#fc6666' : 'black')\r\n                .style(\"fill-opacity\", 1)\r\n                .call(getTextBox)\r\n                .datum(d => d.data)\r\n                .text(getText)\r\n          .clone(true).lower()\r\n            .attr(\"stroke\", \"white\");\r\n    \r\n      // Highlight undefined -- not working\r\n      // Inspired in part by https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\r\n      nodeEnter.filter((d,i) => isUndefined(d))\r\n        .call(yep)\r\n        .insert('rect', 'text')\r\n        .attr(\"x\", function(d){return d.bbox.x})\r\n        .attr(\"y\", function(d){return d.bbox.y})\r\n        .attr(\"width\", function(d){return d.bbox.width})\r\n        .attr(\"height\", function(d){return d.bbox.height}) \r\n        .attr('fill', 'black')             \r\n    // }\r\n}\r\n\r\n// From https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\r\nfunction getTextBox(selection : any) {\r\n  selection.each(function(d : any){d.bbox = this.getBBox();})\r\n}\r\n\r\nfunction yep(selection : any) {\r\n  // console.log(selection.nodes().map((d)=>d.bbox));\r\n}\r\n\r\n\r\nconst connection = d3shape.linkHorizontal().x(d => d.y).y(d => d.x)\r\n\r\nfunction getChildren(node: AST.Node): AST.Node[] {\r\n  var children: AST.Node[] = [];\r\n  switch (node!.nodeType) {\r\n    case 'Program':\r\n      node = node as AST.ProgramNode;\r\n      children = node!.children;\r\n      break;\r\n    case 'Function':\r\n      node = node as AST.FunctionNode;\r\n      children = node!.args;\r\n      break;\r\n    case 'Choose':\r\n      node = node as AST.ChooseNode;\r\n      children = [node!.case.predicate, node!.case.consequent, node!.otherwise];\r\n      break;\r\n    case 'BinaryOperation':\r\n      node = node as AST.BinaryOperationNode;\r\n      children = [node!.left, node.right];\r\n      break;\r\n    case 'VariableAssignment':\r\n      node = node as AST.VariableAssignmentNode;\r\n      children = [node!.assignment];\r\n      break;\r\n    default:\r\n      children = [];\r\n    }\r\n\r\n  return children;\r\n}\r\n\r\nfunction getText(node: AST.Node) {\r\n  var text = \"\";\r\n  switch (node!.nodeType) {\r\n    case 'Program':\r\n      text = '';\r\n      break;\r\n    case 'Function':\r\n      node = node as AST.FunctionNode;\r\n      text = node.name;\r\n      break;\r\n    case 'Choose':\r\n      text = \"choose\";\r\n      break;\r\n    case 'BinaryOperation':\r\n      node = node as AST.BinaryOperationNode;\r\n      text = node.operator;\r\n      break;\r\n    case 'VariableAssignment':\r\n      node = node as AST.VariableAssignmentNode;\r\n      text = node.name;\r\n      break;\r\n    case 'Identifier':\r\n      node = node as AST.IdentifierNode;\r\n      text = node.name;\r\n      break;\r\n    case 'Number':  \r\n      node = node as AST.NumberNode;\r\n      text = node.value.toString();\r\n      break;\r\n    case 'Boolean':\r\n      node = node as AST.BooleanNode;\r\n      text = node.value.toString();\r\n      break;\r\n    default:\r\n      text = \"\";\r\n  }\r\n\r\n  return text;\r\n}\r\n\r\nfunction getFill(node : AST.ProgramNode): string {\r\n  if (isUndefined(node)) {\r\n    return '#fc6666'\r\n  }\r\n  if (node.children) {\r\n    return '#555'\r\n  } else {\r\n    return '#999'\r\n  }\r\n}\r\n\r\nfunction isUndefined(d : any) {\r\n  return d.data.outputType?.status === 'Maybe-Undefined'\r\n}","import {Transaction} from \"@codemirror/state\"\r\nimport {json, jsonParseLinter} from \"@codemirror/lang-json\"\r\nimport {foldAll} from \"@codemirror/fold\"\r\nimport { visualize } from \"./visualization\"\r\nimport {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\r\nimport {linter} from \"@codemirror/lint\"\r\nimport { parseResults } from \"./parseResults\"\r\n\r\n/**\r\n * Given a transaction, update the developer tools\r\n */\r\n export function updateDevTools(tr: Transaction) {\r\n  const results = tr.state.field(parseResults)\r\n\r\n  // Display JSON for AST\r\n  const astJSON = JSON.stringify(results.nodes, null, 2)\r\n  replaceContents(astViewer, astJSON);\r\n\r\n  // Display JSON for depends map\r\n  const dependsJSON = JSON.stringify(results.dependsMap, null, 2);\r\n  replaceContents(dependsViewer, dependsJSON);\r\n\r\n  // Draw the AST\r\n  visualize(results.nodes);\r\n}\r\n\r\n// Configuration for a read-only JSON viewer with folding, line numbers, etc.\r\nfunction newJSONViewerState(): EditorState {\r\n  return EditorState.create({\r\n    extensions: [\r\n      basicSetup,\r\n      json(),\r\n      linter(jsonParseLinter()),\r\n      EditorView.editable.of(false),\r\n    ],\r\n  })\r\n}\r\n\r\n// JSON viewer for AST\r\nlet astViewer = new EditorView({\r\n  state: newJSONViewerState(),\r\n  parent: document.querySelector(\"#ast-json\") as Element,\r\n});\r\n\r\n// JSON viewer for depends map\r\nlet dependsViewer = new EditorView({\r\n  state: newJSONViewerState(),\r\n  parent: document.querySelector(\"#depends-json\") as Element,\r\n});\r\n\r\n/**\r\n * Replace the entire contents of an editor\r\n */\r\nfunction replaceContents(editor: EditorView, contents: string) {\r\n  const update = editor.state.update({\r\n    changes: {\r\n      from: 0,\r\n      to: editor.state.doc.length,\r\n      insert: contents\r\n    }\r\n  });\r\n  editor.update([update]);\r\n  foldAll(editor);  // By default, fold all levels\r\n}\r\n","import {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\r\nimport {Transaction} from \"@codemirror/state\"\r\nimport {linter} from \"@codemirror/lint\"\r\nimport {miniCL, miniCLLinter} from \"./miniCL\"\r\nimport {StreamLanguage} from \"@codemirror/stream-parser\"\r\nimport {parseResults} from \"./parseResults\"\r\nimport {updateDevTools} from \"./devTools\"\r\nimport \"./styles.css\"\r\nimport \"./desmos_icons.css\"\r\n\r\n// Create the CodeMirror miniCL editor and add it to the document.\r\nlet miniCLEditor = new EditorView({\r\n  state: EditorState.create({\r\n    extensions: [\r\n      basicSetup,                     // https://codemirror.net/6/docs/ref/#basic-setup\r\n      StreamLanguage.define(miniCL),  // syntax coloring for miniCL\r\n      parseResults,                   // field that holds the results of parsing\r\n      linter(miniCLLinter())          // error-checking for miniCL\r\n    ],\r\n  }),\r\n  dispatch: updateOutput,\r\n  parent: document.querySelector(\"#miniCL-editor\") as Element\r\n})\r\n\r\n// When the content changes, update the editor and the dev tools\r\nfunction updateOutput(tr: Transaction) {\r\n  miniCLEditor.update([tr]);\r\n  updateDevTools(tr);\r\n}\r\n","import {Position} from './position';\r\nimport * as AST from './ast';\r\nimport {equals} from './equals';\r\n\r\n/***** ITERATION: change all outputType.valueType to simply outputType *****/\r\n\r\nexport function typecheck(nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n  const errors = nodes.map(n => typecheckNode(n, registeredNodes));\r\n  return ([] as TypeError[]).concat(...errors);\r\n}\r\n\r\nfunction typecheckNode(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n\r\n  if (node != undefined && node.nodeType != undefined && checkerMap[node.nodeType] != undefined){\r\n    return checkerMap[node.nodeType]!.check(node, registeredNodes);\r\n  } else {\r\n    return [];\r\n  }\r\n\r\n  \r\n}\r\n\r\nexport class TypeError {\r\n  constructor(public message: string, public position: Position) {}\r\n}\r\n\r\nexport interface TypeChecker {\r\n  check(node: AST.Node, registeredNodes: {[key: string]: AST.Node}): TypeError[];\r\n}\r\n\r\nclass CheckNumber implements TypeChecker {\r\n  check(node: AST.NumberNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\nclass CheckBoolean implements TypeChecker {\r\n  check(node: AST.BooleanNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\nclass CheckBinary implements TypeChecker {\r\n  check(node: AST.BinaryOperationNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    const errors: TypeError[] = typecheckNode(node.left, registeredNodes).concat(typecheckNode(node.right, registeredNodes));\r\n    \r\n    // Check if same operand type (both numbers, both booleans)\r\n    if (node.left?.outputType?.valueType != node.right?.outputType?.valueType) {\r\n      errors.push(new TypeError(\"incompatible types for binary operator\", node.pos));\r\n    }\r\n    // Check if incorrect combination of operator and operands\r\n    else if (node.right?.outputType?.valueType == 'boolean' && (node.operator != \"|\" && node.operator != '&')) {\r\n      errors.push(new TypeError(\"incompatible operation for boolean operands\", node.pos));\r\n    }\r\n    else if (node.right?.outputType?.valueType == 'number' && (node.operator == \"|\" || node.operator == '&')) {\r\n      errors.push(new TypeError(\"incompatible operation for number operands\", node.pos));\r\n    }\r\n\r\n    node.outputType!.valueType = node.left?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckFunction implements TypeChecker {\r\n  check(node: AST.FunctionNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    // First typecheck the argument\r\n    const arg1Errors = typecheckNode(node.args[0], registeredNodes);\r\n    errors = errors.concat(arg1Errors);\r\n    if (node.args.length > 1) {\r\n      const arg2Errors = typecheckNode(node.args[1], registeredNodes);\r\n      errors = errors.concat(arg2Errors);\r\n      if (node.args[0]?.outputType?.valueType != node.args[1]?.outputType?.valueType) {\r\n\r\n        errors.push(new TypeError(\"arguments must have same type\", node.args[0]!.pos));\r\n      }\r\n    }\r\n\r\n    const functionName = node.name\r\n    const argType = builtins[functionName].inputType;\r\n\r\n    // we found a builtin function\r\n    if (argType) {\r\n\r\n      // typecheck the argument\r\n      // Assume both arguments are the same type (see error produced above)\r\n      if (argType != 'any' && node.args[0]?.outputType?.valueType != argType) {\r\n        errors.push(new TypeError(\"incompatible argument type for \" + functionName, node.pos));\r\n      }\r\n    }\r\n  \r\n    // this is not a known, builtin function\r\n    else {\r\n      errors.push(new TypeError(\"unknown function\", node.pos));\r\n    }    \r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckChoose implements TypeChecker {\r\n  check(node: AST.ChooseNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    const predicate = node.case.predicate;\r\n    const consequent = node.case.consequent;\r\n    const otherwise = node.otherwise;\r\n\r\n    // First typecheck the inner nodes\r\n    const predErrors = typecheckNode(predicate, registeredNodes);\r\n    const consErrors = typecheckNode(consequent, registeredNodes);\r\n    const otherErrors = typecheckNode(otherwise, registeredNodes);\r\n    errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\r\n\r\n    // check return types are the same for both cases\r\n    if (consequent?.outputType?.valueType != otherwise?.outputType?.valueType) {\r\n      errors.push(new TypeError(\"Return types are not the same for both cases\", consequent!.pos));\r\n      errors.push(new TypeError(\"Return types are not the same for both cases\", otherwise!.pos));\r\n    }\r\n\r\n    // check that the predicate returns a boolean\r\n    if (predicate!.outputType!.valueType != 'boolean') {\r\n      errors.push(new TypeError(\"Predicate must return a boolean\", predicate!.pos));\r\n    }\r\n\r\n    node.outputType.valueType = consequent?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckVariable implements TypeChecker {\r\n  check(node: AST.VariableAssignmentNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n    // First typecheck the assignment node\r\n    const assignmentErrors = typecheckNode(node.assignment, registeredNodes);\r\n    errors = errors.concat(assignmentErrors);\r\n\r\n    node.outputType.valueType = node.assignment?.outputType?.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckIdentifier implements TypeChecker {\r\n  check(node: AST.IdentifierNode, registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    let errors: TypeError[] = [];\r\n\r\n    // Maybe make assigmentId be valueId?\r\n    let assignmentNode : any = registeredNodes[node.assignmentId];\r\n    let valueNode = assignmentNode.assignment;\r\n    //let valueNode : AST.VariableAssignmentNode = registeredNodes[node.assignmentId]!.assignment;\r\n\r\n    // If this assignmentId is not found in the AST, throw an error\r\n    if (valueNode == undefined) {\r\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\r\n    }\r\n\r\n    node.outputType.valueType = valueNode.outputType.valueType;\r\n\r\n    return errors;\r\n  }\r\n}\r\n\r\nclass CheckIterator implements TypeChecker {\r\n  check(node: AST.IteratorNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\n\r\nclass CheckRangeIdentifier implements TypeChecker {\r\n  check(node: AST.IteratorNode): TypeError[] {\r\n    return [];\r\n  }\r\n}\r\n\r\n// Dictionary of builtin functions that maps a function name to the type of its argument\r\nconst builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType} } = {\r\n  \"IsDefined\": {inputType: 'any', resultType: 'boolean'},\r\n  \"Inverse\": {inputType: 'number', resultType: 'number'},\r\n  \"Input\": {inputType: 'number', resultType: 'number'},\r\n  \"Sink\": {inputType: 'any', resultType: 'any'},\r\n  \"RandomChoice\": {inputType: 'number', resultType: 'number'},\r\n  \"TestConstant\": {inputType: 'any', resultType: 'any'},\r\n  \"ParseOrderedPair\": {inputType: 'number', resultType: 'pair'},\r\n  \"X\": {inputType: 'pair', resultType: 'number'},\r\n  \"Y\": {inputType: 'pair', resultType: 'number'}\r\n}\r\n\r\nconst checkerMap: Partial<{[K in AST.NodeType]: TypeChecker}> = {\r\n  'Number' : new CheckNumber(),\r\n  'Boolean' : new CheckBoolean(),\r\n  'BinaryOperation' : new CheckBinary(),\r\n  'Function' : new CheckFunction(),\r\n  'Choose': new CheckChoose(),\r\n  'VariableAssignment': new CheckVariable(),\r\n  'Identifier': new CheckIdentifier(),\r\n  'Iterator': new CheckIterator(),\r\n  'RangeIdentifier': new CheckRangeIdentifier(),\r\n}","import {Position} from './position';\r\nimport * as AST from './ast';\r\nimport {equals} from './equals';\r\n\r\n\r\n\r\n\r\n\r\nexport function darCheck(nodes: AST.Node[],  registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    const errors = nodes.map(n => darCheckNode(n, nodes, registeredNodes));\r\n    return ([] as TypeError[]).concat(...errors);\r\n}\r\n\r\nfunction darCheckNode(node: AST.Node, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n    if (darCheckerMap != undefined && node != undefined && node.nodeType != undefined && darCheckerMap[node.nodeType] == undefined){\r\n        return [];\r\n    }else{\r\n        return darCheckerMap[node!.nodeType]!.darCheck(node, nodes, registeredNodes);\r\n    }\r\n}\r\n\r\nexport class TypeError {\r\n    constructor(public message: string, public position: Position) {}\r\n  }\r\n\r\nexport interface DarChecker {\r\n\r\n    darCheck(node: AST.Node,\r\n            nodes: AST.Node[], \r\n            registeredNodes: {[key: string]: AST.Node},): TypeError[];\r\n  }\r\n\r\nclass DarCheckNumber implements DarChecker {\r\n    darCheck(node: AST.NumberNode): TypeError[] {\r\n\r\n        //set the value in the outputType\r\n        node.outputType.value = node.value;\r\n        return [];\r\n    }\r\n  }\r\n\r\n\r\n  class DarCheckFunction implements DarChecker{\r\n      darCheck(node: AST.FunctionNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}) : TypeError[]{\r\n        const errors: TypeError[] = [];\r\n        \r\n        if (node.name == \"TestConstant\"){\r\n            //do our test constant demo\r\n\r\n            //pre-check the arg (to assign value)\r\n            darCheckNode(node.args[0], nodes, registeredNodes)\r\n\r\n            //check if the argument has a value\r\n            if (node?.args[0]?.outputType?.value == undefined){\r\n                errors.push(new TypeError(\"Input to TestConstant() is not constant\", node.pos));\r\n            }\r\n\r\n        }\r\n        return errors;\r\n      }\r\n  }\r\n\r\nclass DarCheckBinary implements DarChecker {\r\n\r\n\r\n    evaluateOperation(left : number, right : number, operator : string): number | undefined {\r\n\r\n        //check to make sure left & right are numbers\r\n        if (typeof(left) == 'number' && typeof(right) == 'number' ){\r\n            if (operator == \"+\"){\r\n                return left + right\r\n            } else if (operator == \"-\"){\r\n                return left - right\r\n            } else if (operator == \"*\"){\r\n                return left * right\r\n            } else if (operator ==\"/\"){\r\n                return left / right\r\n            } else {\r\n                return 999999\r\n            }\r\n        } else {\r\n            //one or both sides is a non-number. We only care about numbers\r\n            return undefined\r\n        }\r\n    }\r\n\r\n    darCheck(node: AST.BinaryOperationNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n        const errors: TypeError[] = darCheckNode(node.left, nodes, registeredNodes).concat(darCheckNode(node.right, nodes, registeredNodes));\r\n        \r\n        //check if outputType of both left and right is constant\r\n        if (node.left?.outputType?.value != undefined && node.right?.outputType?.value != undefined){\r\n            \r\n            //evaluate the operation and set the value\r\n            node.outputType = {\r\n                status : node.outputType!.status,\r\n                valueType: node.left?.outputType?.valueType,\r\n                value: this.evaluateOperation(node.left?.outputType.value, node.right?.outputType.value, node.operator) \r\n            }\r\n            \r\n   \r\n        } else{\r\n            //One or both of the left + right does NOT have a value\r\n            console.log(\"One or both sides has no 'value'\");\r\n        }\r\n   \r\n        return errors;\r\n    }\r\n}\r\n\r\nclass DarCheckVariable implements DarChecker {\r\n    darCheck(node: AST.VariableAssignmentNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n\r\n\r\n        //check the assignment (and propagate value, if applicable)\r\n        darCheckNode(node.assignment, nodes, registeredNodes);\r\n\r\n        //does the assignment node have a value\r\n        if (node.assignment?.outputType?.value != undefined){\r\n            //set value of this node to the value of the assignment\r\n            node.outputType.value = node.assignment.outputType.value;\r\n        }\r\n\r\n        return [];\r\n    }\r\n}\r\n\r\nclass DarCheckIdentifier implements DarChecker {\r\n    darCheck(node: AST.IdentifierNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n\r\n        //grab the assignment node that this ident refrences\r\n        const assignmentNode = registeredNodes[node.assignmentId];\r\n\r\n        if (assignmentNode?.outputType?.value != undefined){\r\n            //set value of this node to the value of the assignment\r\n            node.outputType.value = assignmentNode.outputType.value;\r\n        }\r\n\r\n        return [];\r\n    }\r\n  }\r\n\r\n  class DarCheckIterator implements DarChecker {\r\n\r\n    getRange(start: number, end: number, step: number): number[]{\r\n        let current = start;\r\n        let out = [];\r\n        while (current < end){\r\n            out.push(current);\r\n            current += step;\r\n        }\r\n        return out;\r\n    }\r\n    darCheck(node: AST.IteratorNode, nodes: AST.Node[], registeredNodes: {[key: string]: AST.Node}): TypeError[] {\r\n        const errors: TypeError[] = [];\r\n\r\n        //pre-check nodes\r\n        darCheckNode(node.start, nodes, registeredNodes);\r\n        darCheckNode(node.end, nodes, registeredNodes);\r\n        darCheckNode(node.step, nodes, registeredNodes);\r\n\r\n\r\n        //calculate range\r\n\r\n        if (node.start?.outputType?.value != undefined && node.end?.outputType?.value != undefined && node.step?.outputType?.value != undefined){\r\n            //if start, end, and step all are constant numbers\r\n\r\n            const start = node.start?.outputType?.value;\r\n            const end = node.end?.outputType?.value;\r\n            const step = node.step?.outputType?.value;\r\n\r\n            console.log(\"start, end, step:\", start, end, step);\r\n\r\n            node.values = this.getRange(start, end, step);\r\n        } else {\r\n            console.log(\"Iterator used with non constant stuff\")\r\n            errors.push(new TypeError(\"Non constant value used in iterator decleration\", node.pos));\r\n        }\r\n\r\n\r\n        return errors;\r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\nclass DarCheckAny implements DarChecker {\r\n    darCheck(node: AST.Node): TypeError[] {\r\n        return [];\r\n    }\r\n}\r\n\r\n\r\n\r\nconst darCheckerMap: Partial<{[K in AST.NodeType]: DarChecker}> = {\r\n'Number' : new DarCheckNumber(),\r\n'Boolean' : new DarCheckAny(),\r\n'BinaryOperation' : new DarCheckBinary(),\r\n'Function' : new DarCheckFunction(),\r\n'Choose': new DarCheckAny(),\r\n'VariableAssignment': new DarCheckVariable(),\r\n'Identifier': new DarCheckIdentifier(),\r\n'Iterator': new DarCheckIterator(),\r\n'RangeIdentifier': new DarCheckAny(),\r\n'SinkAssignment': new DarCheckAny(),\r\n'String': new DarCheckAny(),\r\n'Pair': new DarCheckAny(),\r\n'CalculatorReference': new DarCheckAny(),\r\n'Program': new DarCheckAny(),\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"]}