{"version":3,"sources":["src/miniCL.ts","src/parseResults.ts","src/visualization.ts","src/devTools.ts","src/index.ts","src/lexer.ts","src/typechecker.ts","src/mudChecker.ts","src/findBase.ts","src/parser.ts","src/parselet.ts","src/position.ts","src/tokenstream.ts"],"names":["startState","line","stack","token","stream","state","eatSpace","token2tag","lexer_1","view","results","field","parseResults_1","dependsMap","registeredNodes","errors","typeErrors","aTree","analyzedNodes","typechecker_1","nodes","mudErrors","mudChecker_1","parseDiagnostics","parseErrors","map","makeDiagnostic","typeDiagnostics","mudDiagnostics","concat","severity","error","from","firstLine","position","first_column","to","lastLine","last_column","message","doc","first_line","last_line","undefined","state_1","define","create","emptyParseResults","update","value","tr","docChanged","parseProgram","contents","toString","varMap","ast","parser_1","margin","top","right","bottom","left","height","width","select","selectAll","remove","viz","append","attr","root","nodeType","children","treemap","tree","size","separation","treelayout","hierarchy","getChildren","g","link","data","links","linkEnter","enter","connection","node","descendants","nodeEnter","d","y","x","getFill","isUndefined","style","call","getTextBox","datum","text","getText","clone","lower","filter","i","yep","insert","bbox","selection","each","getBBox","linkHorizontal","args","case","predicate","consequent","otherwise","assignment","name","operator","outputType","status","astJSON","JSON","stringify","replaceContents","astViewer","dependsJSON","dependsViewer","visualization_1","basic_setup_1","extensions","lang_json_1","lint_1","editable","of","newJSONViewerState","parent","document","querySelector","editor","changes","length","fold_1","miniCLEditor","stream_parser_1","miniCL_1","dispatch","updateOutput","devTools_1","tokens","split","string","eol","getToken","emitToken","makeEmit","fullToken","push","start","pos","Error","getDefaultToken","type","current","match","next","aNodes","totalErrors","forEach","aNode","typecheckNode","checkerMap","check","constructor","newNode","valueType","asserts","constType","nodeId","lErrors","lANode","rErrors","rANode","TypeError","aArgs","arg1Errors","arg1Node","arg2Errors","arg2Node","functionName","argType","exports","inputType","resultType","predErrors","predNode","consErrors","consNode","otherErrors","otherNode","assignmentErrors","assignmentNode","valueNode","assignmentId","CheckNumber","CheckBoolean","CheckBinary","CheckFunction","CheckChoose","CheckVariable","CheckIdentifier","n","mudCheckNode","mudCheckerMap","mudCheck","intersection","leftAsserts","rightAsserts","find","e","allAsserts","bases","findBase_1","result","evaluate","consDef","otherDef","handleCheck","MudCheckNumber","MudCheckBoolean","MudCheckBinary","MudCheckFunction","MudCheckChoose","MudCheckVariable","MudCheckIdentifier","contained","consAsserts","consConsContained","consOtherContained","consBases","baseMap","findBase","baseList","leftList","findBases","rightList","otherBases","BaseNumber","BaseBoolean","BaseBinary","BaseFunction","BaseChoose","BaseVariableAssignment","BaseIdentifier","tokenstream_1","parser","Parser","peek","parse","bindingPowers","bindingClasses","tokenType","Object","keys","consequentMap","bindingPower","position_1","currentBindingPower","consume","last","initialParselet","initialMap","consequentParselet","AbstractParser","NUMBER","NumberParselet","TRUE","BooleanParselet","FALSE","ParenParselet","FUNCTION","FunctionParselet","CHOOSE1","ChooseParselet","IDENTIFIER","IdentifierParselet","BinaryOperatorParselet","classes","_parser","_tokens","id","parseFloat","_token","exp","expectToken","associativity","ConsequentParselet","arg1","arg2","varParselet","VariableAssignmentParselet","end","t","expectedType","actual"],"mappings":"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","file":"","sourcesContent":["import {StreamParser, StringStream} from \"@codemirror/stream-parser\"\nimport {Diagnostic} from \"@codemirror/lint\"\nimport {EditorView} from \"@codemirror/view\"\nimport {State, getDefaultToken} from './lexer'\nimport {ParseError} from './position'\nimport {typecheck} from './typechecker';\nimport {mudCheck} from './mudChecker';\nimport {parseResults} from './parseResults';\nimport * as AnalyzedTree from './analyzedTree';\n\n/**\n * The extension for our language\n */\nexport const miniCL: StreamParser<State> = {\n  startState: function (): State {\n    return {line: 1, stack: ['default']};\n  },\n  token: function (stream: StringStream, state: State): string | undefined {\n    if (stream.eatSpace()) return null;\n    return token2tag(getDefaultToken(stream, state));\n  }\n};\n\n/**\n * The linter for our language\n */\n export const miniCLLinter = () => (view: EditorView): Diagnostic[] => {\n\n  // Get the result types\n  const results = view.state.field(parseResults);\n\n  let dependsMap: {[key: string]: string[]} = {};\n  let registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode} = {}\n  // Error checking\n  const {errors: typeErrors, aTree: analyzedNodes} = typecheck(results.nodes, registeredNodes);\n  const mudErrors = mudCheck(analyzedNodes, registeredNodes, dependsMap);\n\n  // Create a diagnostic for each kind of error\n  const parseDiagnostics = results.parseErrors.map(makeDiagnostic(view));\n  const typeDiagnostics = typeErrors.map(makeDiagnostic(view));\n  const mudDiagnostics = mudErrors.map(makeDiagnostic(view, 'warning'));\n\n  return parseDiagnostics.concat(typeDiagnostics).concat(mudDiagnostics);\n}\n\n/**\n * Create a diagnostic from an error\n */\nconst makeDiagnostic = (view: EditorView, severity: 'error' | 'info' | 'warning' = 'error') => \n  (error): Diagnostic => {\n    return {\n      from: firstLine(view, error) + error.position.first_column,\n      to: lastLine(view, error) + error.position.last_column,\n      message: error.message,\n      severity: severity\n    }\n}\n\n/**\n * @returns the line number for the start of the error\n */\nfunction firstLine(view: EditorView, error: ParseError) {\n  return view.state.doc.line(error.position.first_line).from;\n}\n\n/**\n * @returns the line number for the end of the error\n */\nfunction lastLine (view: EditorView, error: ParseError) {\n  return view.state.doc.line(error.position.last_line).from;    \n}\n\n/**\n * Convert our bespoke parser Token type to a token type that is recognized by CodeMirror\n */\nfunction token2tag(token: string): string | undefined {\n  switch (token) {\n    case 'NUMBER':\n      return 'number';\n\n    case 'TRUE':\n      return 'boolean';\n\n    case 'FALSE':\n      return 'boolean';\n\n    case '(':\n    case ')':\n      return 'bracket';\n\n    case '+':\n    case '-':\n    case '*':\n    case '/':\n    case '|':\n    case '&':\n    case '=':\n      return 'operator';\n\n    case 'COMMENT':\n      return 'comment';\n\n    case 'CHOOSE1':\n    case 'CHOOSE2':\n      return 'choose';\n\n    case 'FUNCTION':\n      return 'function';\n\n    case 'IDENTIFIER':\n      return 'variable';\n\n    case 'ERROR':\n      return 'error';\n\n    default:\n      return undefined;\n  }\n}\n","import {StateField} from \"@codemirror/state\"\nimport {Transaction} from \"@codemirror/state\"\nimport * as AST from './ast';\nimport {parse} from './parser';\nimport {ParseError} from './position';\n\n/**\n * A State field that holds the results of parsing\n */\nexport const parseResults: StateField<ParseResults> = StateField.define({\n  create() { return emptyParseResults },\n  update(value, tr) { return tr.docChanged ? parseProgram(tr) : value }\n})\n\n/**\n * Parse the program created from a transaction, returning a ParseResults object\n */\nfunction parseProgram(tr: Transaction) : ParseResults {\n  const contents = tr.state.doc.toString()\n\n  let varMap: {[key: string]: string} = {}\n  const ast = parse(contents, varMap)\n\n  return {\n    nodes: ast.nodes,\n    parseErrors: ast.errors,\n    varMap: varMap\n  }\n}\n\n/**\n * Type that describes the results of parsing\n */\nexport type ParseResults = {\n  nodes: AST.Node[];\n  parseErrors: ParseError[];\n  varMap: {[key: string]: string};\n}\n\n/**\n * Can be used as the initial results of parsing\n */\nconst emptyParseResults: ParseResults = {\n  nodes: [],\n  parseErrors: [],\n  varMap: {}\n}\n","import * as d3Hierarchy from 'd3-hierarchy';\nimport * as d3Select from 'd3-selection';\nimport * as d3shape from 'd3-shape';\nimport * as AST from './ast';\n\nexport function visualize(nodes: AST.Node[]): void {\n\n    // Placement and size of tree\n    const margin = {top: 20, right: 90, bottom: 20, left: 90};\n    const height = 300 - margin.top - margin.bottom;\n    const width  = 500 - margin.left - margin.right;\n  \n    // Make the svg\n    d3Select.select('#viz').selectAll('svg').remove();\n    const viz = d3Select.select('#viz').append('svg');\n  \n    // Remove existing visualizations\n    viz.selectAll('*').remove();\n  \n    // Add a new visualization\n    viz.attr('width', width + margin.left + margin.right)\n       .attr('height', height + margin.top + margin.bottom);\n\n    const root: Node = {nodeType: 'Program', children: nodes}\n\n    // Visualize all the statements\n    // for (var statement of nodes) {\n\n      // Create the tree and layout\n      const treemap = d3Hierarchy.tree()\n        .size([height, width])\n        .separation(() => 1);\n      const treelayout = d3Hierarchy.hierarchy(root, getChildren);\n      const tree = treemap(treelayout);\n  \n      // Add a new graph element for this statement\n      const g = viz.append('g')\n                  //  .attr(\"transform\", `translate(${root.dy / 3},${root.dx - x0})`);\n                   .attr('transform', `translate(${margin.left}, ${margin.top})`)\n                   .attr(\"font-family\", \"sans-serif\")\n                   .attr(\"font-size\", 12)\n               \n      // Edge updates\n      const link = g.selectAll('path.link').data(tree.links());\n\n      // Edge entry\n      const linkEnter = link.enter().append('path', 'g');\n        \n      // general edge attributes\n      linkEnter.attr('class', 'link')\n               .attr('fill', 'none')\n               .attr(\"stroke-opacity\", 0.4)\n               .attr('stroke', '#555')\n               .attr(\"stroke-width\", 1.5)\n               .attr('d', connection);\n\n        \n      // Node updates\n      const node = g.selectAll('g.node').data(tree.descendants());\n\n      // Node entry\n      const nodeEnter = node.enter().append('g');\n\n      // general node attributes\n      nodeEnter.attr('class', 'node')\n               .attr('transform', d => `translate(${d.y}, ${d.x})`);\n\n      nodeEnter.append('circle')\n               .attr(\"fill\", getFill)\n               .attr('r', '2.5')\n               .attr('stroke-width', 10);\n\n      // add text\n      nodeEnter.append('text')\n                // .attr('dy', '-10px')\n                .attr(\"dy\", \"0.31em\")\n                .attr(\"x\", d => d.children ? -8 : 8)\n                .attr(\"text-anchor\", d => d.children ? \"end\" : \"start\")\n                .attr('fill', d => isUndefined(d) ? '#fc6666' : 'black')\n                .style(\"fill-opacity\", 1)\n                .call(getTextBox)\n                .datum(d => d.data)\n                .text(getText)\n          .clone(true).lower()\n            .attr(\"stroke\", \"white\");\n    \n      // Highlight undefined -- not working\n      // Inspired in part by https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\n      nodeEnter.filter((d,i) => isUndefined(d))\n        .call(yep)\n        .insert('rect', 'text')\n        .attr(\"x\", function(d){return d.bbox.x})\n        .attr(\"y\", function(d){return d.bbox.y})\n        .attr(\"width\", function(d){return d.bbox.width})\n        .attr(\"height\", function(d){return d.bbox.height}) \n        .attr('fill', 'black')             \n    // }\n}\n\n// From https://stackoverflow.com/questions/32026194/how-to-add-a-background-color-to-d3-text-elements\nfunction getTextBox(selection) {\n  selection.each(function(d){d.bbox = this.getBBox();})\n}\n\nfunction yep(selection) {\n  // console.log(selection.nodes().map((d)=>d.bbox));\n}\n\n\nconst connection = d3shape.linkHorizontal().x(d => d.y).y(d => d.x)\n\nfunction getChildren(node: AST.Node): AST.Node[] {\n  var children: AST.Node[] = [];\n  switch (node.nodeType) {\n    case 'Program':\n      children = node.children;\n      break;\n    case 'Function':\n      children = node.args;\n      break;\n    case 'Choose':\n      children = [node.case.predicate, node.case.consequent, node.otherwise];\n      break;\n    case 'BinaryOperation':\n      children = [node.left, node.right];\n      break;\n    case 'VariableAssignment':\n      children = [node.assignment];\n      break;\n    default:\n      children = [];\n    }\n\n  return children;\n}\n\nfunction getText(node) {\n  var text = \"\";\n  switch (node.nodeType) {\n    case 'Program':\n      text = '';\n      break;\n    case 'Function':\n      text = node.name;\n      break;\n    case 'Choose':\n      text = \"choose\";\n      break;\n    case 'BinaryOperation':\n      text = node.operator;\n      break;\n    case 'VariableAssignment':\n      text = node.name;\n      break;\n    case 'Identifier':\n      text = node.name;\n      break;\n    case 'Number':  \n      text = node.value.toString();\n      break;\n    case 'Boolean':\n      text = node.value.toString();\n      break;\n    default:\n      text = \"\";\n  }\n\n  return text;\n}\n\nfunction getFill(node): string {\n  if (isUndefined(node)) {\n    return '#fc6666'\n  }\n  if (node.children) {\n    return '#555'\n  } else {\n    return '#999'\n  }\n}\n\nfunction isUndefined(d) {\n  return d.data.outputType?.status === 'Maybe-Undefined'\n}","import {Transaction} from \"@codemirror/state\"\nimport {json, jsonParseLinter} from \"@codemirror/lang-json\"\nimport {foldAll} from \"@codemirror/fold\"\nimport { visualize } from \"./visualization\"\nimport {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\nimport {linter} from \"@codemirror/lint\"\nimport { parseResults } from \"./parseResults\"\n\n/**\n * Given a transaction, update the developer tools\n */\n export function updateDevTools(tr: Transaction) {\n  const results = tr.state.field(parseResults)\n\n  // Display JSON for AST\n  const astJSON = JSON.stringify(results.nodes, null, 2)\n  replaceContents(astViewer, astJSON);\n\n  // Display JSON for depends map\n  const dependsJSON = JSON.stringify(results.dependsMap, null, 2);\n  replaceContents(dependsViewer, dependsJSON);\n\n  // Draw the AST\n  visualize(results.nodes);\n}\n\n// Configuration for a read-only JSON viewer with folding, line numbers, etc.\nfunction newJSONViewerState(): EditorState {\n  return EditorState.create({\n    extensions: [\n      basicSetup,\n      json(),\n      linter(jsonParseLinter()),\n      EditorView.editable.of(false),\n    ],\n  })\n}\n\n// JSON viewer for AST\nlet astViewer = new EditorView({\n  state: newJSONViewerState(),\n  parent: document.querySelector(\"#ast-json\"),\n});\n\n// JSON viewer for depends map\nlet dependsViewer = new EditorView({\n  state: newJSONViewerState(),\n  parent: document.querySelector(\"#depends-json\"),\n});\n\n/**\n * Replace the entire contents of an editor\n */\nfunction replaceContents(editor: EditorView, contents: string) {\n  const update = editor.state.update({\n    changes: {\n      from: 0,\n      to: editor.state.doc.length,\n      insert: contents\n    }\n  });\n  editor.update([update]);\n  foldAll(editor);  // By default, fold all levels\n}\n","import {EditorState, EditorView, basicSetup} from \"@codemirror/basic-setup\"\nimport {Transaction} from \"@codemirror/state\"\nimport {linter} from \"@codemirror/lint\"\nimport {miniCL, miniCLLinter} from \"./miniCL\"\nimport {StreamLanguage} from \"@codemirror/stream-parser\"\nimport {parseResults} from \"./parseResults\"\nimport {updateDevTools} from \"./devTools\"\nimport \"./styles.css\"\nimport \"./desmos_icons.css\"\n\n// Create the CodeMirror miniCL editor and add it to the document.\nlet miniCLEditor = new EditorView({\n  state: EditorState.create({\n    extensions: [\n      basicSetup,                     // https://codemirror.net/6/docs/ref/#basic-setup\n      StreamLanguage.define(miniCL),  // syntax coloring for miniCL\n      parseResults,                   // field that holds the results of parsing\n      linter(miniCLLinter())          // error-checking for miniCL\n    ],\n  }),\n  dispatch: updateOutput,\n  parent: document.querySelector(\"#miniCL-editor\")\n})\n\n// When the content changes, update the editor and the dev tools\nfunction updateOutput(tr: Transaction) {\n  miniCLEditor.update([tr]);\n  updateDevTools(tr);\n}\n","import {StringStream} from \"@codemirror/stream-parser\"\n\nexport function getTokens(text: string): Token[] {\n  const tokens: Token[] = [];\n  const state: State = {line: 1, stack: ['default']};\n\n  for (const line of text.split('\\n')) {\n    const stream = new StringStream();\n    stream.string = line;\n    while (!stream.eol()) {\n      const token = getToken(stream, state);\n      const emitToken = makeEmit(stream, state);\n      const fullToken = emitToken(token as TokenType);\n      if (token != undefined) {\n        tokens.push(fullToken);\n      }\n\n      if (stream.start == stream.pos) {\n        throw new Error(\n          `getToken failed to advance stream at position ${\n            stream.pos\n          } in string ${stream.string}`,\n        );\n      }\n      stream.start = stream.pos;\n    }\n\n    state.line += 1;\n  }\n\n  return tokens;\n}\n\nexport function getToken(\n  stream: StringStream,\n  state: State,\n): string | undefined {\n  //Built for codeMirror streams API\n  //State is a stack of states\n  switch (state.stack[state.stack.length - 1]) {\n    default:\n      return getDefaultToken(stream, state);\n  }\n}\n\nfunction makeEmit(stream: StringStream, state: State) {\n  return function emitToken(type: TokenType): Token {\n    return {\n      type,\n      first_column: stream.start,\n      last_column: stream.pos,\n      line: state.line,\n      text: stream.current(),\n    };\n  };\n}\n\nexport function getDefaultToken(\n  stream: StringStream,\n  state: State,\n): string | undefined {\n  // const emitToken = makeEmit(stream, state);\n  if (stream.eatSpace()) {\n    // skip whitespace\n    return undefined;\n  }\n  \n  // parse both negative and positive numbers\n  if (stream.match(/-?[0-9]+(\\.[0-9]+)?/)) {\n    return 'NUMBER';\n  }\n\n  if (stream.match(/\\+/)) {\n    return '+';\n  }\n\n  // NOTE: when subtracting a positive number, make sure to use parentheses around it\n  // e.g. 1-(2) will work but 1-2 won't\n  if (stream.match(/\\-/)) {\n    return '-';\n  }\n\n  if (stream.match(/\\*/)) {\n    return '*';\n  }\n\n  if (stream.match(/\\//)) {\n    return '/';\n  }\n\n  if (stream.match(/\\|/)) {\n    return '|';\n  }\n\n  if (stream.match(/\\&/)) {\n    return '&';\n  }\n\n  if (stream.match(/\\(/)) {\n    return '(';\n  }\n\n  if (stream.match(/\\)/)) {\n    return ')';\n  }\n\n  if (stream.match(/\\=/)) {\n    return '=';\n  }\n\n  if (stream.match(/True/)) {\n    return 'TRUE';\n  }\n\n  if (stream.match(/False/)) {\n    return 'FALSE';\n  }\n\n  if (stream.match(/#/)) {\n    if (!stream.match(/\\n/)) {\n      // comment lasts till end of line\n      stream.match(/.*/); // if no eol encountered, comment lasts till end of file\n    }\n    return 'COMMENT';\n  }\n\n  // keyword WHEN begins a choose node\n  if (stream.match(/WHEN/)) {\n    return 'CHOOSE1';\n  }\n\n  // keyword OTHERWISE is used in a choose node\n  if (stream.match(/OTHERWISE/)) {\n    return 'CHOOSE2';\n  }\n\n  // functions start with a capital letter and do not contain numbers\n  if (stream.match(/[A-Z]([a-z|A-Z])*/)) {\n    return 'FUNCTION';\n  }\n\n  // The form of a valid identifier is: a lower-case alphabetic character,\n  // followed by zero or more alpha characters.\n  if (stream.match(/[a-z]([a-z|A-Z])*/)) {\n    return 'IDENTIFIER';\n  }\n  \n  stream.next();\n  return 'ERROR';\n}\n\nexport type BinaryOperationTokenType =\n  | '+'\n  | '-'\n  | '*'\n  | '/'\n  | '|' // this is an or\n  | '&' // this is an and\n\nexport type TokenType =\n  | BinaryOperationTokenType\n  | 'NUM'\n  | 'TRUE'\n  | 'FALSE'\n  | '('\n  | ')'\n  | 'COMMENT'\n  | 'ERROR'\n  | 'FUNCTION'\n  | 'IDENTIFIER'\n  | 'CHOOSE1'\n  | 'CHOOSE2'\n  | '='\n\nexport interface Token<T extends TokenType = TokenType> {\n  type: T;\n  text: string;\n  line: number;\n  first_column: number;\n  last_column: number;\n}\n\ntype Mode = 'default';\n\nexport interface State {\n  stack: Mode[];\n  line: number;\n}\n","import {Position} from './position';\nimport * as AST from './ast';\nimport * as AnalyzedTree from './analyzedTree';\n\nexport function typecheck(nodes: AST.Node[], registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\n                          {errors: TypeError[], aTree: AnalyzedTree.AnalyzedNode[]} {\n  const aNodes: AnalyzedTree.AnalyzedNode[] = [];\n  let totalErrors: TypeError[] = [];\n\n  nodes.forEach(node => {\n    let {errors, aNode} = typecheckNode(node, registeredNodes);\n    aNodes.push(aNode);\n    totalErrors = totalErrors.concat(errors);\n  });\n\n  return {errors: totalErrors, aTree: aNodes};\n}\n\nfunction typecheckNode(node: AST.Node, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\n                        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\n  return checkerMap[node.nodeType].check(node, registeredNodes);\n}\n\nexport class TypeError {\n  constructor(public message: string, public position: Position) {}\n}\n\nexport interface TypeChecker {\n  check(node: AST.Node, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode};\n}\n\n// A number requires no type checking\nclass CheckNumber implements TypeChecker {\n  check(node: AST.NumberNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\n    let newNode = {\n      nodeType: node.nodeType,\n      value: node.value,\n      outputType: {\n        status: 'Definitely' as 'Definitely',\n        valueType: node.valueType,\n        asserts: [],\n        constType: 'Constant' as 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId\n    };\n\n    registeredNodes[newNode.nodeId] = newNode;\n\n    return {errors: [], aNode: newNode};\n  }\n}\n\n// A boolean requires no type checking\nclass CheckBoolean implements TypeChecker {\n  check(node: AST.BooleanNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\n    let newNode = {\n      nodeType: node.nodeType,\n      value: node.value,\n      outputType: {\n        status: 'Definitely' as 'Definitely',\n        valueType: node.valueType,\n        asserts: [],\n        constType: 'Constant' as 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId\n    };\n\n    registeredNodes[newNode.nodeId] = newNode;\n\n    return {errors: [], aNode: newNode};\n  }\n}\n\nclass CheckBinary implements TypeChecker {\n  check(node: AST.BinaryOperationNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\n    const { errors: lErrors, aNode: lANode } = typecheckNode(node.left, registeredNodes);\n    const { errors: rErrors, aNode: rANode } = typecheckNode(node.right, registeredNodes);\n    const totalErrors = lErrors.concat(rErrors);\n    \n    // Check if left and right are the same type (both numbers or both booleans)\n    if (lANode.outputType.valueType != rANode.outputType.valueType) {\n      totalErrors.push(new TypeError(\"incompatible types for binary operator\", node.pos));\n    }\n    // Check if incorrect combination of operator and operands\n    else if (rANode.outputType.valueType == 'boolean' && (node.operator != \"|\" && node.operator != '&')) {\n      totalErrors.push(new TypeError(\"incompatible operation for boolean operands\", node.pos));\n    }\n    else if (rANode.outputType.valueType == 'number' && (node.operator == \"|\" || node.operator == '&')) {\n      totalErrors.push(new TypeError(\"incompatible operation for number operands\", node.pos));\n    }\n\n\n    let newNode = {\n      nodeType: node.nodeType,\n      operator: node.operator,\n      left: lANode,\n      right: rANode,\n      outputType: {\n        status: 'Maybe-Undefined' as 'Maybe-Undefined',\n        // Since we've already checked the left and right are the same type\n        // we can set the overall value type to the left\n        valueType: lANode.outputType.valueType,\n        asserts: [],\n        constType: 'Constant' as 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId\n    };\n\n    registeredNodes[newNode.nodeId] = newNode;\n\n    return {errors: [], aNode: newNode};\n  }\n}\n\nclass CheckFunction implements TypeChecker {\n  check(node: AST.FunctionNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\n    let totalErrors: TypeError[] = [];\n    let aArgs: AnalyzedTree.AnalyzedNode[] = [];\n\n    // First typecheck the argument(s)\n    const { errors: arg1Errors, aNode: arg1Node } = typecheckNode(node.args[0], registeredNodes);\n    totalErrors = totalErrors.concat(arg1Errors);\n    aArgs.push(arg1Node);\n    if (node.args.length > 1) {\n      const { errors: arg2Errors, aNode: arg2Node } = typecheckNode(node.args[1], registeredNodes);\n      totalErrors = totalErrors.concat(arg2Errors);\n      aArgs.push(arg2Node);\n      // Both arguments must have the same type\n      if (aArgs[0].outputType.valueType != aArgs[1].outputType.valueType) {\n        totalErrors.push(new TypeError(\"arguments must have same type\", node.args[0].pos));\n      }\n    }\n\n    const functionName = node.name\n    const argType = builtins[functionName].inputType;\n\n    let newNode = {\n      nodeType: 'Function' as 'Function',\n      name: functionName,\n      args: aArgs,\n      outputType: {\n        status: 'Maybe-Undefined' as 'Maybe-Undefined',\n        valueType: builtins[functionName].resultType, // Refer to the builtins dictionary below\n        asserts: [],\n        constType: 'Constant' as 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId\n    };\n\n    // If this is a builtin function, check it has the correct argument types\n    // otherwise throw an error (we don't know what this function is)\n    if (argType) {\n      // Assume both arguments are the same type (see error produced above)\n      if (argType != 'any' && newNode.args[0].outputType.valueType != argType) {\n        totalErrors.push(new TypeError(\"incompatible argument type for \" + functionName, node.pos));\n      }\n      \n    } else {\n      totalErrors.push(new TypeError(\"unknown function\", node.pos));\n    }\n\n    registeredNodes[newNode.nodeId] = newNode;\n\n    return {errors: totalErrors, aNode: newNode};\n  }\n}\n\nclass CheckChoose implements TypeChecker {\n  check(node: AST.ChooseNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\n    let totalErrors: TypeError[] = [];\n\n    const predicate = node.case.predicate;\n    const consequent = node.case.consequent;\n    const otherwise = node.otherwise;\n\n    // First typecheck the inner nodes\n    const { errors: predErrors, aNode: predNode } = typecheckNode(predicate, registeredNodes);\n    const { errors: consErrors, aNode: consNode } = typecheckNode(consequent, registeredNodes);\n    const { errors: otherErrors, aNode: otherNode } = typecheckNode(otherwise, registeredNodes);\n    totalErrors = totalErrors.concat(predErrors).concat(consErrors).concat(otherErrors);\n\n    // Check that the return types are the same for both consequent and otherwise\n    if (consNode.outputType.valueType != otherNode.outputType.valueType) {\n      totalErrors.push(new TypeError(\"Return types are not the same for both cases\", consequent.pos));\n      totalErrors.push(new TypeError(\"Return types are not the same for both cases\", otherwise.pos));\n    }\n\n    // Check that the predicate returns a boolean\n    if (predNode.outputType.valueType != 'boolean') {\n      totalErrors.push(new TypeError(\"Predicate must return a boolean\", predicate.pos));\n    }\n\n    let newNode = {\n      nodeType: 'Choose' as 'Choose',\n      case: { predicate: predNode, consequent: consNode },\n      otherwise: otherNode,\n      outputType: {\n        status: 'Maybe-Undefined' as 'Maybe-Undefined',\n        // Since we've already checked the consequent and otherwise statements are the same type\n        // we can set the overall value type to the consequent\n        valueType: consNode.outputType.valueType,\n        asserts: [],\n        constType: 'Constant' as 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId\n    };\n\n    registeredNodes[newNode.nodeId] = newNode;\n\n    return {errors: totalErrors, aNode: newNode};\n  }\n}\n\nclass CheckVariable implements TypeChecker {\n  check(node: AST.VariableAssignmentNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\n    let totalErrors: TypeError[] = [];\n\n    // First typecheck the assignment node\n    const { errors: assignmentErrors, aNode: assignmentNode } = typecheckNode(node.assignment, registeredNodes);\n    totalErrors = totalErrors.concat(assignmentErrors);\n\n    let newNode = {\n      nodeType: 'VariableAssignment' as 'VariableAssignment',\n      name: node.name,\n      assignment: assignmentNode,\n      outputType: {\n        status: 'Maybe-Undefined' as 'Maybe-Undefined',\n        valueType: assignmentNode.outputType.valueType,\n        asserts: [],\n        constType: 'Constant' as 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId\n    };\n\n    registeredNodes[newNode.nodeId] = newNode;\n\n    return {errors: totalErrors, aNode: newNode};\n  }\n}\n\nclass CheckIdentifier implements TypeChecker {\n  check(node: AST.IdentifierNode, registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode}):\n        {errors: TypeError[], aNode: AnalyzedTree.AnalyzedNode} {\n    let totalErrors: TypeError[] = [];\n\n    // Grab the node the identifier was previously assigned to\n    let valueNode = registeredNodes[node.assignmentId].assignment;\n\n    // If this assignmentId is not found in the AST, throw an error\n    if (valueNode == undefined) {\n      totalErrors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\n    }\n\n    let newNode = {\n      nodeType: 'Identifier' as 'Identifier',\n      name: node.name,\n      assignmentId: node.assignmentId,\n      outputType: {\n        status: 'Maybe-Undefined' as 'Maybe-Undefined',\n        valueType: valueNode.outputType.valueType, // Shouldn't be problem anymore\n        asserts: [],\n        constType: 'Constant' as 'Constant'\n      },\n      pos: node.pos,\n      nodeId: node.nodeId\n    };\n\n    registeredNodes[newNode.nodeId] = newNode;\n\n    return {errors: totalErrors, aNode: newNode};\n  }\n}\n\n// Dictionary of builtin functions that gives the necessary information for a given function name \nexport const builtins : {[name: string]: {inputType: AST.ValueType, resultType: AST.ValueType, status: string, constType: string} } = {\n  \"IsDefined\": {inputType: 'any', resultType: 'boolean', status: \"Definitely\", constType: \"Constant\"},\n  \"Inverse\": {inputType: 'number', resultType: 'number', status: \"Variable\", constType: \"Constant\"},\n  \"InputN\": {inputType: 'number', resultType: 'number', status: \"Maybe-Undefined\", constType: \"Non-Constant\"},\n  \"Sink\": {inputType: 'any', resultType: 'any', status: \"Variable\", constType: \"Constant\"},\n  \"ParseOrderedPair\": {inputType: 'number', resultType: 'pair', status: \"Variable\", constType: \"Constant\"},\n  \"X\": {inputType: 'pair', resultType: 'number', status: \"Variable\", constType: \"Constant\"},\n  \"Y\": {inputType: 'pair', resultType: 'number', status: \"Variable\", constType: \"Constant\"},\n  \"Not\": {inputType: 'boolean', resultType: 'boolean', status: \"Definitely\", constType: \"Constant\"},\n  \"InputB\": {inputType: 'boolean', resultType: 'boolean', status: \"Maybe-Undefined\", constType: \"Non-Constant\"},\n  \"Sqrt\": {inputType: 'number', resultType: 'number', status: \"Variable\", constType: \"Constant\"}\n}\n\nconst checkerMap: Partial<{[K in AST.NodeType]: TypeChecker}> = {\n  'Number' : new CheckNumber(),\n  'Boolean' : new CheckBoolean(),\n  'BinaryOperation' : new CheckBinary(),\n  'Function' : new CheckFunction(),\n  'Choose': new CheckChoose(),\n  'VariableAssignment': new CheckVariable(),\n  'Identifier': new CheckIdentifier()\n}","import {Position} from './position';\nimport * as AST from './ast';\nimport {findBases} from './findBase';\nimport {builtins} from './typechecker';\nimport * as AnalyzedTree from './analyzedTree';\n\n/*\n  The function mudCheck manipulates the status of each node's outputType.\n  It produces type errors based on that status.\n  For example, it will produce a warning when the author tries to use \n  a maybe-undefined node in a Sink function, which is user-facing.\n  It also produces a warning when the author tries to compute a \n  definitely undefined operation (e.g. Inverse(0)).\n*/\n\nexport function mudCheck(nodes: AnalyzedTree.AnalyzedNode[], \n                        registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\n                        dependsMap: {[key: string]: string[]}): TypeError[] {\n  const errors = nodes.map(n => mudCheckNode(n, nodes, registeredNodes, dependsMap));\n  return ([] as TypeError[]).concat(...errors);\n}\n\nfunction mudCheckNode(node: AnalyzedTree.AnalyzedNode, \n                    nodes: AnalyzedTree.AnalyzedNode[], \n                    registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\n                    dependsMap: {[key: string]: string[]}): TypeError[] {\n  return mudCheckerMap[node.nodeType].mudCheck(node, nodes, registeredNodes, dependsMap);\n}\n\nexport class TypeError {\n  constructor(public message: string, public position: Position) {}\n}\n\nexport interface MudChecker {\n  mudCheck(node: AnalyzedTree.AnalyzedNode, \n          nodes: AnalyzedTree.AnalyzedNode[], \n          registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\n          dependsMap: {[key: string]: string[]}): TypeError[];\n}\n\n// Numbers are always defined.\nclass MudCheckNumber implements MudChecker {\n  mudCheck(node: AnalyzedTree.NumberNode): TypeError[] {\n    return [];\n  }\n}\n\n// Booleans are always defined.\nclass MudCheckBoolean implements MudChecker {\n    mudCheck(node: AnalyzedTree.BooleanNode): TypeError[] {\n    return [];\n  }\n}\n\n// Binary operations must take into account their operands' statuses when determining their own.\nclass MudCheckBinary implements MudChecker {\n    mudCheck(node: AnalyzedTree.BinaryOperationNode, \n            nodes: AnalyzedTree.AnalyzedNode[], \n            registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\n            dependsMap: {[key: string]: string[]}): TypeError[] {\n        \n        // recursively mud-check the left and right operands\n        const errors: TypeError[] = mudCheckNode(node.left, nodes, registeredNodes, dependsMap)\n        .concat(mudCheckNode(node.right, nodes, registeredNodes, dependsMap));\n\n        // Update the output type of the node, based on the outputType of its operands\n        if (node.right.outputType.status == 'Def-Undefined' || node.left.outputType.status == 'Def-Undefined') {\n            node.outputType.status = 'Def-Undefined';\n        }\n        else if (node.right.outputType.status == 'Maybe-Undefined' || node.left.outputType.status == 'Maybe-Undefined') {\n            node.outputType.status = 'Maybe-Undefined';\n        } else {\n            node.outputType.status = 'Definitely'\n        }\n\n        // Each ORed binary operation will assert the intersection of its operands' assertions\n        if (node.operator == '|') {\n          let intersection = [];\n          let leftAsserts = node.left.outputType.asserts;\n          let rightAsserts = node.right.outputType.asserts;\n          for (let i = 0; i < leftAsserts.length; i++) {\n            if (rightAsserts.find(e => e == leftAsserts[i])) {\n              intersection.push(leftAsserts[i]);\n            }\n          }\n          node.outputType.asserts = intersection;\n        }\n        // Each ANDed binary operation will assert the union of its operands' assertions\n        else {\n          let leftAsserts = node.left.outputType.asserts;\n          let rightAsserts = node.right.outputType.asserts;\n          let allAsserts = leftAsserts.concat(rightAsserts);\n\n          node.outputType.asserts = allAsserts;\n        }\n\n        return errors;\n    }\n}\n\n// The status of a function is determined by its argument and/or its status as defined\n// in the builtins dictionary.\nclass MudCheckFunction implements MudChecker {\n    mudCheck(node: AnalyzedTree.FunctionNode, \n            nodes: AnalyzedTree.AnalyzedNode[], \n            registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\n            dependsMap: {[key: string]: string[]}): TypeError[] {\n        let errors: TypeError[] = [];\n\n        // First mud-check the argument(s)\n        const arg1Errors = mudCheckNode(node.args[0], nodes, registeredNodes, dependsMap);\n        errors = errors.concat(arg1Errors);\n        if (node.args.length > 1) {\n          const arg2Errors = mudCheckNode(node.args[1], nodes, registeredNodes, dependsMap);\n          errors = errors.concat(arg2Errors);\n        }\n\n        // IsDefined is the only function that asserts anything\n        // It asserts its argument\n        if (node.name == 'IsDefined') {\n          let bases = findBases(node.args[0], dependsMap);\n          node.outputType.asserts = node.outputType.asserts.concat(bases);\n        }\n\n        const functionName = node.name\n        \n        // If sink \"node\" takes in possibly undefined values, warn the author\n        if (functionName == 'Sink') {\n          // a sink has one argument\n          if (node.args[0]?.outputType?.status != 'Definitely') {\n              errors.push(new TypeError(\"User facing content could be undefined.\", node.args[0].pos));\n          }\n        }\n\n        // The contstant-ness of a function is whatever is defined in builtins\n        node.outputType.constType = builtins[node.name].constType;\n        \n        // If the function is variable, then its status depends on its argument's status\n        if (builtins[functionName].status == \"Variable\") {\n\n          // If the argument is constant, we can use it to evaluate the oepration\n          if (node.args[0].outputType.constType == 'Constant') {\n\n            const result = evaluate(node);\n\n            // If the result is undefined, warn the author\n            if (result) {\n              node.outputType.status = \"Definitely\";\n            } else {\n              node.outputType.status = \"Def-Undefined\";\n              errors.push(new TypeError(\"The result of this operation is undefined.\", node.pos));\n            }\n          } else {\n            node.outputType.status = node.args[0]?.outputType?.status;\n          }\n\n        }\n        else {\n          node.outputType.status = builtins[functionName].status;\n        }\n\n        return errors;\n    }\n}\n\n// The status of a choose node is determined by the status of the consequent\n// given what the predicate asserts and the status of the otherwise statement\nclass MudCheckChoose implements MudChecker {\n    mudCheck(node: AnalyzedTree.ChooseNode, \n            nodes: AnalyzedTree.AnalyzedNode[], \n            registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\n            dependsMap: {[key: string]: string[]}): TypeError[] {\n        let errors: TypeError[] = [];\n\n        const predicate = node.case.predicate;\n        const consequent = node.case.consequent;\n        const otherwise = node.otherwise;\n\n        // First typecheck the inner nodes\n        const predErrors = mudCheckNode(predicate, nodes, registeredNodes, dependsMap);\n        const consErrors = mudCheckNode(consequent, nodes, registeredNodes, dependsMap);\n        const otherErrors = mudCheckNode(otherwise, nodes, registeredNodes, dependsMap);\n        errors = errors.concat(predErrors).concat(consErrors).concat(otherErrors);\n\n        // DEFAULT status is maybe-undefined, hence default false values\n        let consDef = false;\n        let otherDef = false;\n\n        if (otherwise.outputType.status == 'Definitely') {\n          otherDef = true;\n        }\n\n        // Check the definitive status of the consequent using the predicates asserts\n        // NOTE: only binary operations and IsDefined functions have non-empty assert fields\n        consDef = handleCheck(consequent, dependsMap, predicate.outputType.asserts);\n\n        if (consequent?.outputType.status == 'Definitely') {\n          consDef = true;\n        }\n\n        if (consDef && otherDef) {\n          node.outputType.status = 'Definitely';\n        }\n\n        return errors;\n    }\n}\n\n// The status of a variable assignment is determined by the status of its assignment\nclass MudCheckVariable implements MudChecker {\n    mudCheck(node: AnalyzedTree.VariableAssignmentNode, \n            nodes: AnalyzedTree.AnalyzedNode[], \n            registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\n            dependsMap: {[key: string]: string[]}): TypeError[] {\n    let errors: TypeError[] = [];\n\n    // First mud-check the assignment node\n    const assignmentErrors = mudCheckNode(node.assignment, nodes, registeredNodes, dependsMap);\n    errors = errors.concat(assignmentErrors);\n\n    // Set variable assignment node output type to the same as its assignment\n    node.outputType.status = node.assignment.outputType.status;\n\n    // Update the dependsMap to hold the bases of this new variable\n    dependsMap[node.nodeId] = findBases(node.assignment, dependsMap);\n\n    return errors;\n  }\n}\n\n// The status of an identifier is determined by the status of its assignment,\n// given in registered nodes\nclass MudCheckIdentifier implements MudChecker {\n    mudCheck(node: AnalyzedTree.IdentifierNode, \n            nodes: AnalyzedTree.AnalyzedNode[], \n            registeredNodes: {[key: string]: AnalyzedTree.AnalyzedNode},\n            dependsMap: {[key: string]: string[]}): TypeError[] {\n    let errors: TypeError[] = [];\n\n    // Grab the node the identifier was previously assigned to\n    let valueNode = registeredNodes[node.assignmentId].assignment;\n\n    // If this assignmentId is not found in the AST, throw an error\n    if (valueNode == undefined) {\n      errors.push(new TypeError(\"This variable doesn't have a value\", node.pos));\n    } else {\n      // If we found the assignment node, set the output type of the identifier\n      node.outputType.status = valueNode.outputType.status;\n    }\n\n    return errors;\n  }\n}\n\n\nconst mudCheckerMap: Partial<{[K in AST.NodeType]: MudChecker}> = {\n  'Number' : new MudCheckNumber(),\n  'Boolean' : new MudCheckBoolean(),\n  'BinaryOperation' : new MudCheckBinary(),\n  'Function' : new MudCheckFunction(),\n  'Choose': new MudCheckChoose(),\n  'VariableAssignment': new MudCheckVariable(),\n  'Identifier': new MudCheckIdentifier()\n}\n\n// Given the consequent to a choose node, return true if the given list of asserts\n// includes all of the bases of that consequent\nfunction handleCheck(consequent: AnalyzedTree.AnalyzedNode,\n                    dependsMap: {[key: string]: string[]},\n                    asserts: string[]): boolean {\n  let contained = true;\n\n  // If the given consequent is a choose node, recursively check the its consequent and otherwise statements\n  if (consequent?.nodeType == 'Choose') {\n    // We need to check each statement's bases separately in order to exclude\n    // the next predicate's asserts in the next otherwise\n    // while including the current asserts in both\n    let consAsserts = consequent.case.predicate.outputType.asserts;\n    let consConsContained = handleCheck(consequent.case.consequent, dependsMap, asserts.concat(consAsserts));\n    let consOtherContained = handleCheck(consequent.otherwise, dependsMap, asserts);\n\n    // If either the next consequent or otherwise statements aren't covered by their asserts,\n    // the current consequent is also not covered\n    if (!(consConsContained && consOtherContained)) {\n      contained = false;\n    }\n\n  } else {\n    let consBases = findBases(consequent, dependsMap);\n\n    // Ensure that every base is in the given asserts list\n    for (let i = 0; i < consBases.length; i++) {\n      if (!asserts.find(e => e == consBases[i])) {\n        contained = false;\n      }\n    }\n  }\n\n  return contained;\n}\n\n// This funciton simulates running the body of a miniCL function (like Inverse(x))\nfunction evaluate(node: AnalyzedTree.FunctionNode): boolean {\n  // 0 is the only input to Inverse that makes it undefined\n  if (node.name == \"Inverse\") {\n    if (node.args[0].value == 0) {\n      return false;\n    }\n  }\n  // A negative number is the only input to Sqrt that makes it undefined\n  if (node.name == \"Sqrt\") {\n    if (node.args[0].value < 0) {\n      return false;\n    }\n  }\n  // No other functions can have inputs that make them definitely undefined\n  return true;\n}\n","import * as AST from './ast';\nimport {builtins} from './typechecker';\nimport * as AnalyzedTree from './analyzedTree';\n\n/*\n    The findBases function, given an AST node and the current dependsMap, determines\n    the \"bases\" of that node and returns them in a list of nodeIds.\n\n    Bases are nodes that introduce the possibility of being undefined.\n    For example, the InputN() function represents student input, and therefore\n    introduces the possibility to be undefined.\n*/\n\nexport function findBases(node: AnalyzedTree.AnalyzedNode, dependsMap: {[key: string]: string[]}): string[] {\n    return baseMap[node.nodeType].findBase(node, dependsMap); \n}\n\nexport interface BaseFinder {\n  findBase(node: AnalyzedTree.AnalyzedNode, dependsMap: {[key: string]: string[]}): string[];\n}\n\n// Numbers are constant, and therefore cannot have bases\nclass BaseNumber implements BaseFinder {\n  findBase(node: AnalyzedTree.NumberNode): string[] {\n    return []\n  }\n}\n\n// Booleans are constant, and therefore cannot have bases\nclass BaseBoolean implements BaseFinder {\n    findBase(node: AnalyzedTree.BooleanNode): string[] {\n        return []\n    }\n}\n\n// Binary operations could have bases on either side of their operator\nclass BaseBinary implements BaseFinder {\n    findBase(node: AnalyzedTree.BinaryOperationNode, dependsMap: {[key: string]: string[]}): string[] {\n        let baseList: string[] = [];\n        // recursively call findBases on left and right\n        let leftList = findBases(node.left, dependsMap);\n        baseList = baseList.concat(leftList);\n        let rightList = findBases(node.right, dependsMap)\n        // combine bases from left and right\n        baseList = baseList.concat(rightList);\n        return baseList;\n    }\n}\n\n// In this proof of concept, functions are the only bases\n// They can produce an undefined value (e.g. Inverse(0)) or are inherently non-constant (e.g. InputN)\n// Otherwise, the base of the function is determined by its argument(s)\n// This means that the base is the id of the function node itself\nclass BaseFunction implements BaseFinder {\n    findBase(node: AnalyzedTree.FunctionNode, dependsMap: {[key: string]: string[]}): string[] {\n        let baseList: string[] = [];\n\n        if (node.outputType.status == 'Def-Undefined') {\n            // e.g. with Inverse(0)\n            baseList.push(node.nodeId);\n        } else if (builtins[node.name].status == 'Variable') {\n            // recursively call findBases on argument(s)\n            for (let i = 0; i < node.args.length; i++) {\n                baseList = baseList.concat(findBases(node.args[i], dependsMap));\n            }\n        } else if (builtins[node.name].constType == 'Non-Constant') {\n            // e.g. with InputN(2)\n            baseList.push(node.nodeId);\n        }\n\n        return baseList;\n    }\n}\n\n// The bases of choose nodes are determined by the bases of their consequent and their otherwise\nclass BaseChoose implements BaseFinder {\n    findBase(node: AnalyzedTree.ChooseNode, dependsMap: {[key: string]: string[]}): string[] {\n        let baseList: string[] = [];\n \n        let consBases = findBases(node.case.consequent, dependsMap);\n        baseList = baseList.concat(consBases);\n\n        let otherBases = findBases(node.otherwise, dependsMap);\n        baseList = baseList.concat(otherBases);\n\n        return baseList;\n    }\n}\n\n// Variable assignments are constant, and therefore cannot have bases\nclass BaseVariableAssignment implements BaseFinder {\n    findBase(node: AnalyzedTree.VariableAssignmentNode): string[] {\n        return []\n    }\n}\n\n// The bases of an identifier are stored in the dependsMap, which has a reference\n// to its assignment.\nclass BaseIdentifier implements BaseFinder {\n    findBase(node: AnalyzedTree.IdentifierNode, dependsMap: {[key: string]: string[]}): string[] {\n        // follow the chain in the dependsMap\n        return dependsMap[node.assignmentId];\n    }\n}\n\nconst baseMap: Partial<{[K in AST.NodeType]: BaseFinder}> = {\n  'Number' : new BaseNumber(),\n  'Boolean' : new BaseBoolean(),\n  'BinaryOperation' : new BaseBinary(),\n  'Function' : new BaseFunction(),\n  'Choose': new BaseChoose(),\n  'VariableAssignment': new BaseVariableAssignment(),\n  'Identifier': new BaseIdentifier()\n}","import * as Parselet from './parselet';\nimport {Token, TokenType} from './lexer';\nimport {TokenStream} from './tokenstream';\nimport {ParseError, token2pos} from './position';\nimport * as AST from './ast';\n\nexport function parse(text: string,\n                      varMap: {[key: string]: string}): \n                      {nodes: AST.Node[]; errors: ParseError[]} {\n  const nodes: AST.Node[] = [];\n\n  const tokens = new TokenStream(text);\n  const parser = new Parser();\n  while (tokens.peek()) {\n    try {\n      nodes.push(parser.parse(tokens, 0, varMap));\n    } catch (e) {\n      return {\n        nodes,\n        errors: [e],\n      };\n    }\n  }\n\n  return {nodes, errors: []};\n}\n\nexport abstract class AbstractParser {\n  public bindingPowers: {[tokenType in TokenType]: number};\n\n  protected abstract initialMap(): Partial<\n    {[K in TokenType]: Parselet.InitialParselet}\n  >;\n  protected abstract consequentMap(): Partial<\n    {[K in TokenType]: Parselet.ConsequentParselet}\n  >;\n  protected abstract bindingClasses(): TokenType[][];\n\n  constructor() {\n    this.bindingPowers = {} as any;\n\n    const bindingClasses = this.bindingClasses();\n    for (let i = 0; i < bindingClasses.length; i++) {\n      for (const tokenType of bindingClasses[i]) {\n        this.bindingPowers[tokenType] = 10 * i + 9;\n      }\n    }\n\n    for (const tokenType of Object.keys(this.consequentMap) as TokenType[]) {\n      if (this.bindingPowers[tokenType] == undefined) {\n        throw new Error(\n          `Token ${tokenType} defined in consequentMap has no associated binding power.\n          Make sure it is also listed in bindingClasses.`,\n        );\n      }\n    }\n  }\n\n  bindingPower(token: Token): number {\n    if (this.bindingPowers[token.type] != undefined) {\n      return this.bindingPowers[token.type];\n    } else {\n      throw new ParseError(\n        `Unexpected token type ${token.type}.`,\n        token2pos(token),\n      );\n    }\n  }\n\n  parse(tokens: TokenStream,\n        currentBindingPower: number,\n        varMap: {[key: string]: string}): AST.Node {\n    const token = tokens.consume();\n    if (!token) {\n      throw new ParseError(\n        `Unexpected end of tokens.`,\n        token2pos(tokens.last()),\n      );\n    }\n\n    const initialParselet = this.initialMap()[token.type];\n\n    if (!initialParselet) {\n      throw new ParseError(\n        `Unexpected token type ${token.type}`,\n        token2pos(token),\n      );\n    }\n\n    let left = initialParselet.parse(this, tokens, token, varMap);\n\n    while (true) {\n      const next = tokens.peek();\n      if (!next) {\n        break;\n      }\n\n      const consequentParselet = this.consequentMap()[next.type];\n\n      if (!consequentParselet) {\n        break;\n      }\n\n      if (currentBindingPower >= this.bindingPower(next)) {\n        break;\n      }\n\n      tokens.consume();\n      left = consequentParselet.parse(this, tokens, left, next, varMap);\n    }\n\n    return left;\n  }\n}\n\nexport class Parser extends AbstractParser {\n  initialMap() {\n    return {\n      NUMBER: new Parselet.NumberParselet(),\n      TRUE: new Parselet.BooleanParselet(true),\n      FALSE: new Parselet.BooleanParselet(false),\n      '(': new Parselet.ParenParselet(),\n      FUNCTION: new Parselet.FunctionParselet(),\n      CHOOSE1: new Parselet.ChooseParselet(),\n      IDENTIFIER: new Parselet.IdentifierParselet()\n    };\n  }\n\n  consequentMap() {\n    return {\n      '+': new Parselet.BinaryOperatorParselet('+', 'left'),\n      '-': new Parselet.BinaryOperatorParselet('-', 'left'),\n      '*': new Parselet.BinaryOperatorParselet('*', 'left'),\n      '/': new Parselet.BinaryOperatorParselet('/', 'left'),\n      '|': new Parselet.BinaryOperatorParselet('|', 'right'),\n      '&': new Parselet.BinaryOperatorParselet('&', 'right')\n    };\n  }\n\n  bindingClasses() {\n    const classes: TokenType[][] = [['+', '-'], ['*', '/'], ['|', '&']];\n    return classes;\n  }\n}\n","import { TokenStream } from './tokenstream';\nimport { Token, TokenType, BinaryOperationTokenType} from './lexer';\nimport * as AST from './ast';\nimport { AbstractParser } from './parser';\nimport {token2pos, join, pos2string} from './position';\n\n// All parselets add their nodeType to the AST\nexport interface InitialParselet {\n  parse(parser: AbstractParser,\n        tokens: TokenStream, token: Token,\n        varMap: {[key: string]: string}): AST.Node;\n}\n\n\nexport class NumberParselet implements InitialParselet {\n  parse(_parser: AbstractParser,\n        _tokens: TokenStream,\n        token: Token,\n        varMap: {[key: string]: string}) {\n    const position = token2pos(token);\n    const id = pos2string(position);\n\n    let newNode = {\n      nodeType: 'Number' as 'Number',\n      value: parseFloat(token.text),\n      valueType: 'number' as 'number',\n      pos: position,\n      nodeId: id\n    };\n    \n    return newNode;\n  }\n}\n\nexport class BooleanParselet implements InitialParselet {\n  constructor(private value: boolean) {}\n  parse(_parser: AbstractParser,\n        _tokens: TokenStream, token: Token,\n        varMap: {[key: string]: string}) {\n    const position = token2pos(token);\n    const id = pos2string(position);\n\n    let newNode = {\n      nodeType: 'Boolean' as 'Boolean',\n      value: this.value,\n      valueType: 'boolean' as 'boolean',\n      pos: position,\n      nodeId: id\n    };\n\n    return newNode;\n  }\n}\n\nexport class ParenParselet implements InitialParselet {\n  parse(parser: AbstractParser,\n    tokens: TokenStream,\n    _token: Token,\n    varMap: {[key: string]: string}) {\n\n    const exp = parser.parse(tokens, 0, varMap);\n    tokens.expectToken(')');\n\n    return exp;\n  }\n}\n\nexport abstract class ConsequentParselet {\n  constructor(\n    readonly tokenType: TokenType,\n    readonly associativity: 'left' | 'right'\n  ) {}\n  abstract parse(\n    parser: AbstractParser,\n    tokens: TokenStream,\n    left: AST.Node,\n    token: Token,\n    varMap: {[key: string]: string}): AST.Node;\n}\n\nexport class BinaryOperatorParselet extends ConsequentParselet {\n  constructor(\n    public tokenType: BinaryOperationTokenType,\n    associativity: 'left' | 'right'\n  ) {\n    super(tokenType, associativity);\n  }\n\n  parse(\n    parser: AbstractParser,\n    tokens: TokenStream,\n    left: AST.Node,\n    token: Token,\n    varMap: {[key: string]: string}): AST.Node {\n    const bindingPower = parser.bindingPower(token);\n\n    const right = parser.parse(\n      tokens,\n      this.associativity == 'left' ? bindingPower : bindingPower - 1,\n      varMap\n    );\n    const position = join(left.pos, token2pos(tokens.last()));\n    const id = pos2string(position);\n    let newNode = {\n      nodeType: 'BinaryOperation' as 'BinaryOperation',\n      operator: this.tokenType,\n      left,\n      right,\n      pos: position,\n      nodeId: id\n    };\n\n    return newNode;\n  }\n}\n\nexport class FunctionParselet implements InitialParselet {\n  \n  parse(parser: AbstractParser,\n    tokens: TokenStream,\n    token: Token,\n    varMap: {[key: string]: string}) {\n\n    const position = token2pos(token);\n    const id = pos2string(position);\n\n    // All functions have at least one argument inside parens\n    tokens.expectToken('(');\n    const arg1 = parser.parse(tokens, 0, varMap);  // allow for one argument\n    let args = [arg1];\n    // ParseOrderedPair is the only function that takes two arguments\n    if (token.text == \"ParseOrderedPair\") {\n      const arg2 = parser.parse(tokens, 0, varMap);  // allow for second argument\n      args.push(arg2);\n    }\n    tokens.expectToken(')');\n\n    let newNode = {\n      nodeType: 'Function' as 'Function',\n      name: token.text,\n      args: args,\n      pos: position,\n      nodeId: id\n    };\n\n    return newNode;\n  }\n}\n\nexport class ChooseParselet implements InitialParselet {\n  parse(parser: AbstractParser,\n    tokens: TokenStream,\n    token: Token,\n    varMap: {[key: string]: string}) {\n    const position = token2pos(token);\n    const id = pos2string(position);\n\n    // Choose nodes include two nodes followed by the keyword \"OTHERWISE\" (CHOOSE2)\n    // which is followed by another node\n    const predicate = parser.parse(tokens, 0, varMap);\n    const consequent = parser.parse(tokens, 0, varMap);\n    tokens.expectToken('CHOOSE2');\n    const otherwise = parser.parse(tokens, 0, varMap);\n\n    let newNode = {\n      nodeType: 'Choose' as 'Choose',\n      case: { predicate: predicate, consequent: consequent },\n      otherwise: otherwise,\n      pos: position,\n      nodeId: id\n    };\n\n    return newNode;\n  }\n}\n\nexport class VariableAssignmentParselet implements InitialParselet {\n  parse(parser: AbstractParser,\n    tokens: TokenStream,\n    token: Token,\n    varMap: {[key: string]: string}) {\n\n    const position = token2pos(token);\n    const id = pos2string(position);\n    \n    tokens.expectToken('=');\n    const assignment = parser.parse(tokens, 0, varMap);\n\n    // Save the variable and its assignment in the variable map\n    varMap[token.text] = id;\n\n    let newNode = {\n      nodeType: 'VariableAssignment' as 'VariableAssignment',\n      name: token.text,\n      assignment: assignment,\n      pos: position,\n      nodeId: id\n    };\n\n    return newNode;\n  }\n}\n\nexport class IdentifierParselet implements InitialParselet {\n  parse(parser: AbstractParser,\n    tokens: TokenStream,\n    token: Token,\n    varMap: {[key: string]: string}) {\n    \n    const position = token2pos(token);\n    const id = pos2string(position);\n\n    // Look up the node this identifier was assigned to\n    const assignmentId = varMap[token.text];\n\n    // An identifier must be previously assigned,\n    // otherwise we call the variable assignment parselet\n    if (!assignmentId) {\n      const varParselet = new VariableAssignmentParselet();\n      return varParselet.parse(parser, tokens, token, varMap);\n    }\n    else {\n      let newNode = {\n        nodeType: 'Identifier' as 'Identifier',\n        name: token.text,\n        assignmentId: assignmentId,\n        pos: position,\n        nodeId: id\n      };\n      \n      return newNode;\n    }\n  }\n}\n","import { Token } from './lexer';\n\nexport type Position = {\n  first_line: number;\n  first_column: number;\n  last_line: number;\n  last_column: number;\n};\n\nexport function token2pos(token: Token): Position {\n  return {\n    first_line: token.line,\n    last_line: token.line,\n    first_column: token.first_column,\n    last_column: token.last_column\n  }\n}\n\nexport function join(start: Position, end: Position) {\n  return {\n    first_line: start.first_line,\n    last_line: end.last_line,\n    first_column: start.first_column,\n    last_column: end.last_column\n  };\n}\n\n// Returns a string that uniquely identifies a node's position\nexport function pos2string(pos: Position): string {\n  return pos.first_line.toString() + \".\" +\n         pos.first_column.toString() + \".\" +\n         pos.last_line.toString() + \".\" +\n         pos.last_column.toString();\n}\n\n// note, extending Error in the browser is problematic\n// https://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node\nexport class ParseError {\n  constructor(public message: string, public position: Position) {}\n}\n","import {Token, TokenType, getTokens} from './lexer';\nimport {ParseError, token2pos} from './position';\n\nexport class TokenStream {\n  tokens: Token[];\n  pos: number = 0;\n\n  constructor(text: string) {\n    this.tokens = getTokens(text).filter(t => t.type != 'COMMENT');\n  }\n\n  consume(): Token | undefined {\n    const token = this.tokens[this.pos];\n    if (token) {\n      this.pos += 1;\n    }\n    return token;\n  }\n\n  peek(): Token | undefined {\n    return this.tokens[this.pos];\n  }\n\n  last(): Token {\n    return this.tokens[this.pos - 1];\n  }\n\n  expectToken<T extends TokenType>(expectedType: T): Token<T> {\n    const actual = this.consume();\n\n    if (!actual) {\n      throw new ParseError(\n        `Expected \"${expectedType}\" token but found none.`,\n        token2pos(this.last()),\n      );\n    }\n\n    if (actual.type != expectedType) {\n      throw new ParseError(\n        `Expected \"${expectedType}\" token type but found \"${actual.type}\".`,\n        token2pos(actual),\n      );\n    }\n\n    return actual as Token<T>;\n  }\n}\n"]}